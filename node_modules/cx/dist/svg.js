import { innerTextTrim, isArray, isNumber } from "./util";
import { PureContainer, ResizeManager, VDOM, Widget } from "./ui";

var classCallCheck = function(instance, Constructor) {
	if (!(instance instanceof Constructor)) {
		throw new TypeError("Cannot call a class as a function");
	}
};

var _extends =
	Object.assign ||
	function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];

			for (var key in source) {
				if (Object.prototype.hasOwnProperty.call(source, key)) {
					target[key] = source[key];
				}
			}
		}

		return target;
	};

var inherits = function(subClass, superClass) {
	if (typeof superClass !== "function" && superClass !== null) {
		throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
	}

	subClass.prototype = Object.create(superClass && superClass.prototype, {
		constructor: {
			value: subClass,
			enumerable: false,
			writable: true,
			configurable: true
		}
	});
	if (superClass)
		Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : (subClass.__proto__ = superClass);
};

var possibleConstructorReturn = function(self, call) {
	if (!self) {
		throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	}

	return call && (typeof call === "object" || typeof call === "function") ? call : self;
};

var Rect = (function() {
	function Rect(config) {
		classCallCheck(this, Rect);

		Object.assign(this, config);
	}

	Rect.prototype.width = function width() {
		return this.r - this.l;
	};

	Rect.prototype.height = function height() {
		return this.b - this.t;
	};

	Rect.prototype.valid = function valid() {
		return this.r > this.l && this.b > this.t;
	};

	Rect.prototype.makeValid = function makeValid() {
		return new Rect({
			l: Math.min(this.l, this.r),
			r: Math.max(this.l, this.r),
			t: Math.min(this.t, this.b),
			b: Math.max(this.t, this.b)
		});
	};

	Rect.prototype.isEqual = function isEqual(r) {
		if (!r || !r.isRect) return false;

		return r.l == this.l && r.r == this.r && r.t == this.t && r.b == this.b;
	};

	Rect.add = function add(a, b) {
		return new Rect({
			l: a.l + b.l,
			t: a.t + b.t,
			r: a.r + b.r,
			b: a.b + b.b
		});
	};

	Rect.multiply = function multiply(a, b) {
		return new Rect({
			l: a.l + (a.r - a.l) * b.l,
			r: a.l + (a.r - a.l) * b.r,
			t: a.t + (a.b - a.t) * b.t,
			b: a.t + (a.b - a.t) * b.b
		});
	};

	Rect.margin = function margin(r, m) {
		var mr = Rect.convertMargin(m);
		return Rect.add(r, mr);
	};

	Rect.convertMargin = function convertMargin(m) {
		if (!m) return new Rect();

		if (m.isRect) return m;

		if (isNumber(m)) return new Rect({ l: m, t: m, r: -m, b: -m });

		var m = Rect.convert(m);
		m.b = -m.b;
		m.r = -m.r;
		return m;
	};

	Rect.convert = function convert(r) {
		if (!r) return new Rect({ l: 0, r: 0, t: 0, b: 0 });

		if (r.isRect) return r;

		if (typeof r === "string") r = r.split(" ");

		if (isArray(r)) {
			return new Rect({
				t: parseFloat(r[0]),
				r: parseFloat(r[1]),
				b: parseFloat(r[2]),
				l: parseFloat(r[3])
			});
		}

		return new Rect(r);
	};

	return Rect;
})();

Rect.prototype.isRect = true;

Rect.prototype.l = 0; //left;
Rect.prototype.r = 0; //right
Rect.prototype.t = 0; //top
Rect.prototype.b = 0; //bottom

var BoundedObject = (function(_PureContainer) {
	inherits(BoundedObject, _PureContainer);

	function BoundedObject() {
		classCallCheck(this, BoundedObject);
		return possibleConstructorReturn(this, _PureContainer.apply(this, arguments));
	}

	BoundedObject.prototype.declareData = function declareData() {
		var _PureContainer$protot;

		return (_PureContainer$protot = _PureContainer.prototype.declareData).call.apply(
			_PureContainer$protot,
			[
				this,
				{
					anchors: undefined,
					offset: undefined,
					margin: undefined,
					padding: undefined
				}
			].concat(Array.prototype.slice.call(arguments))
		);
	};

	BoundedObject.prototype.prepareData = function prepareData(context, instance) {
		_PureContainer.prototype.prepareData.call(this, context, instance);
		var data = instance.data;

		data.anchors = Rect.convert(data.anchors);
		data.offset = Rect.convert(data.offset);
		data.margin = Rect.convertMargin(data.margin);
		data.padding = Rect.convertMargin(data.padding);
	};

	BoundedObject.prototype.calculateBounds = function calculateBounds(context, instance) {
		var data = instance.data;

		return Rect.add(Rect.add(Rect.multiply(instance.parentRect, data.anchors), data.offset), data.margin);
	};

	BoundedObject.prototype.prepareBounds = function prepareBounds(context, instance) {
		var data = instance.data;

		if (
			instance.shouldUpdate ||
			!instance.cached.parentRect ||
			!instance.cached.parentRect.isEqual(context.parentRect) ||
			!data.bounds
		) {
			if (!context.parentRect) throw new Error("Parent bounds were not provided through the context.");
			instance.parentRect = context.parentRect;
			instance.cache("parentRect", context.parentRect);
			instance.markShouldUpdate(context);
			data.bounds = this.calculateBounds(context, instance);
			data.childrenBounds = Rect.add(data.bounds, data.padding);
		}
	};

	BoundedObject.prototype.prepare = function prepare(context, instance) {
		this.prepareBounds(context, instance);
		context.push("parentRect", instance.data.childrenBounds);
	};

	BoundedObject.prototype.prepareCleanup = function prepareCleanup(context, instance) {
		context.pop("parentRect");
	};

	return BoundedObject;
})(PureContainer);

BoundedObject.prototype.anchors = 0;
BoundedObject.prototype.margin = 0;
BoundedObject.prototype.offset = 0;
BoundedObject.prototype.padding = 0;
BoundedObject.prototype.styled = true;

var Text = (function(_BoundedObject) {
	inherits(Text, _BoundedObject);

	function Text() {
		classCallCheck(this, Text);
		return possibleConstructorReturn(this, _BoundedObject.apply(this, arguments));
	}

	Text.prototype.declareData = function declareData() {
		var _BoundedObject$protot;

		return (_BoundedObject$protot = _BoundedObject.prototype.declareData).call.apply(
			_BoundedObject$protot,
			[this].concat(Array.prototype.slice.call(arguments), [
				{
					value: undefined,
					dx: undefined,
					dy: undefined,
					textAnchor: undefined,
					fill: undefined,
					stroke: undefined
				}
			])
		);
	};

	Text.prototype.init = function init() {
		if (this.ta) this.textAnchor = this.ta;

		if (this.bind) {
			this.value = {
				bind: this.bind
			};
		} else if (this.tpl) {
			this.value = {
				tpl: this.tpl
			};
		} else if (this.expr) {
			this.value = {
				expr: this.expr
			};
		}

		_BoundedObject.prototype.init.call(this);
	};

	Text.prototype.render = function render(context, instance, key) {
		var data = instance.data;
		var bounds = data.bounds;

		return VDOM.createElement(
			"text",
			{
				key: key,
				className: data.classNames,
				x: bounds.l,
				y: bounds.t,
				dx: data.dx,
				dy: data.dy,
				textAnchor: data.textAnchor,
				style: data.style,
				fill: data.fill,
				stroke: data.stroke
			},
			data.value,
			this.renderChildren(context, instance)
		);
	};

	return Text;
})(BoundedObject);

Text.prototype.anchors = "0.5 0.5 0.5 0.5";
Text.prototype.baseClass = "text";

Widget.alias("svg.text", Text);

var TextualBoundedObject = (function(_BoundedObject) {
	inherits(TextualBoundedObject, _BoundedObject);

	function TextualBoundedObject() {
		classCallCheck(this, TextualBoundedObject);
		return possibleConstructorReturn(this, _BoundedObject.apply(this, arguments));
	}

	TextualBoundedObject.prototype.add = function add(widget) {
		var _BoundedObject$protot;

		if (typeof widget != "string")
			return (_BoundedObject$protot = _BoundedObject.prototype.add).call.apply(
				_BoundedObject$protot,
				[this].concat(Array.prototype.slice.call(arguments))
			);

		if (this.trimWhitespace) widget = innerTextTrim(widget);

		if (!widget) return;

		return this.add({
			type: Text,
			value: widget,
			textAnchor: "middle",
			dy: "0.4em"
		});
	};

	return TextualBoundedObject;
})(BoundedObject);

var Svg = (function(_BoundedObject) {
	inherits(Svg, _BoundedObject);

	function Svg() {
		classCallCheck(this, Svg);
		return possibleConstructorReturn(this, _BoundedObject.apply(this, arguments));
	}

	Svg.prototype.initState = function initState(context, instance) {
		var size = {
			width: 0,
			height: 0
		};
		instance.state = { size: size };
	};

	Svg.prototype.prepare = function prepare(context, instance) {
		var size = instance.state.size;

		context.parentRect = new Rect({
			l: 0,
			t: 0,
			r: size.width,
			b: size.height
		});

		instance.clipRects = {};
		instance.clipRectId = 0;
		context.push("addClipRect", function(rect) {
			var id = "clip-" + ++instance.clipRectId;
			instance.clipRects[id] = rect;
			return id;
		});
		_BoundedObject.prototype.prepare.call(this, context, instance);
	};

	Svg.prototype.prepareCleanup = function prepareCleanup(context, instance) {
		_BoundedObject.prototype.prepareCleanup.call(this, context, instance);
		context.pop("addClipRect");
	};

	Svg.prototype.render = function render(context, instance, key) {
		return VDOM.createElement(
			SvgComponent,
			{
				key: key,
				instance: instance,
				data: instance.data,
				options: context.options,
				size: instance.state.size,
				shouldUpdate: instance.shouldUpdate
			},
			this.renderChildren(context, instance)
		);
	};

	return Svg;
})(BoundedObject);

Svg.prototype.anchors = "0 1 1 0";
Svg.prototype.baseClass = "svg";
Svg.prototype.autoWidth = false;
Svg.prototype.autoHeight = false;
Svg.prototype.aspectRatio = 1.618;

function sameSize(a, b) {
	if (!a || !b) return false;

	return a.width == b.width && a.height == b.height;
}

var SvgComponent = (function(_VDOM$Component) {
	inherits(SvgComponent, _VDOM$Component);

	function SvgComponent() {
		classCallCheck(this, SvgComponent);
		return possibleConstructorReturn(this, _VDOM$Component.apply(this, arguments));
	}

	SvgComponent.prototype.shouldComponentUpdate = function shouldComponentUpdate(props) {
		return props.shouldUpdate;
	};

	SvgComponent.prototype.render = function render() {
		var _this3 = this;

		var _props = this.props,
			instance = _props.instance,
			data = _props.data,
			size = _props.size,
			children = _props.children;
		var widget = instance.widget;

		var defs = [];
		for (var k in instance.clipRects) {
			var cr = instance.clipRects[k];
			defs.push(
				VDOM.createElement(
					"clipPath",
					{ key: k, id: k },
					VDOM.createElement("rect", {
						x: cr.l,
						y: cr.t,
						width: Math.max(0, cr.width()),
						height: Math.max(0, cr.height())
					})
				)
			);
		}

		var style = data.style;
		if (widget.autoHeight)
			style = _extends({}, style, {
				height: size.height + "px"
			});
		if (widget.autoWidth)
			style = _extends({}, style, {
				width: size.width + "px"
			});

		//parent div is needed because clientWidth doesn't work on the svg element in FF

		return VDOM.createElement(
			"div",
			{
				ref: function ref(el) {
					_this3.el = el;
				},
				className: data.classNames,
				style: style
			},
			VDOM.createElement("svg", null, VDOM.createElement("defs", null, defs), children)
		);
	};

	SvgComponent.prototype.onResize = function onResize() {
		var instance = this.props.instance;
		var widget = this.props.instance.widget;

		var size = {
			width: this.el.clientWidth,
			height: this.el.clientHeight
		};

		if (widget.autoHeight) size.height = size.width / widget.aspectRatio;

		if (widget.autoWidth) size.width = size.height * widget.aspectRatio;

		if (!sameSize(instance.state.size, size))
			instance.setState({
				size: size
			});
	};

	SvgComponent.prototype.componentDidMount = function componentDidMount() {
		this.offResize = ResizeManager.subscribe(this.onResize.bind(this));
		this.onResize();
	};

	SvgComponent.prototype.componentDidUpdate = function componentDidUpdate() {
		this.onResize();
	};

	SvgComponent.prototype.componentWillUnmount = function componentWillUnmount() {
		if (this.offResize) {
			this.offResize();
			delete this.offResize;
		}
	};

	return SvgComponent;
})(VDOM.Component);

Widget.alias("svg", Svg);

var Rectangle = (function(_TextualBoundedObject) {
	inherits(Rectangle, _TextualBoundedObject);

	function Rectangle() {
		classCallCheck(this, Rectangle);
		return possibleConstructorReturn(this, _TextualBoundedObject.apply(this, arguments));
	}

	Rectangle.prototype.declareData = function declareData() {
		var _TextualBoundedObject2;

		(_TextualBoundedObject2 = _TextualBoundedObject.prototype.declareData).call.apply(
			_TextualBoundedObject2,
			[this].concat(Array.prototype.slice.call(arguments), [
				{
					colorIndex: undefined,
					fill: undefined,
					stroke: undefined
				}
			])
		);
	};

	Rectangle.prototype.render = function render(context, instance, key) {
		var data = instance.data;
		var bounds = data.bounds,
			colorIndex = data.colorIndex;

		if (!bounds.valid()) return false;
		return VDOM.createElement(
			"g",
			{ key: key, className: data.classNames },
			VDOM.createElement("rect", {
				className: this.CSS.element(this.baseClass, "rect", colorIndex != null && "color-" + colorIndex),
				x: bounds.l,
				y: bounds.t,
				width: bounds.width(),
				height: bounds.height(),
				style: data.style,
				fill: data.fill,
				stroke: data.stroke
			}),
			this.renderChildren(context, instance, key)
		);
	};

	return Rectangle;
})(TextualBoundedObject);

Rectangle.prototype.baseClass = "rectangle";
Rectangle.prototype.anchors = "0 1 1 0";

Widget.alias("rectangle", Rectangle);

var ClipRect = (function(_BoundedObject) {
	inherits(ClipRect, _BoundedObject);

	function ClipRect() {
		classCallCheck(this, ClipRect);
		return possibleConstructorReturn(this, _BoundedObject.apply(this, arguments));
	}

	ClipRect.prototype.prepareBounds = function prepareBounds(context, instance) {
		_BoundedObject.prototype.prepareBounds.call(this, context, instance);
		var data = instance.data;

		data.clipId = context.addClipRect(data.bounds);
	};

	ClipRect.prototype.render = function render(context, instance, key) {
		var data = instance.data;

		return VDOM.createElement(
			"g",
			{ key: key, clipPath: "url(#" + data.clipId + ")" },
			this.renderChildren(context, instance)
		);
	};

	return ClipRect;
})(BoundedObject);

ClipRect.prototype.anchors = "0 1 1 0";

var Ellipse = (function(_TextualBoundedObject) {
	inherits(Ellipse, _TextualBoundedObject);

	function Ellipse() {
		classCallCheck(this, Ellipse);
		return possibleConstructorReturn(this, _TextualBoundedObject.apply(this, arguments));
	}

	Ellipse.prototype.declareData = function declareData() {
		var _TextualBoundedObject2;

		(_TextualBoundedObject2 = _TextualBoundedObject.prototype.declareData).call.apply(
			_TextualBoundedObject2,
			[this].concat(Array.prototype.slice.call(arguments), [
				{
					colorIndex: undefined,
					fill: undefined,
					stroke: undefined
				}
			])
		);
	};

	Ellipse.prototype.render = function render(context, instance, key) {
		var data = instance.data;
		var bounds = data.bounds,
			colorIndex = data.colorIndex;

		if (!bounds.valid()) return false;
		return VDOM.createElement(
			"g",
			{ key: key, className: data.classNames },
			VDOM.createElement("ellipse", {
				className: this.CSS.element(this.baseClass, "rect", colorIndex != null && "color-" + colorIndex),
				cx: (bounds.l + bounds.r) / 2,
				cy: (bounds.t + bounds.b) / 2,
				rx: bounds.width() / 2,
				ry: bounds.height() / 2,
				style: data.style,
				fill: data.fill,
				stroke: data.stroke
			}),
			this.renderChildren(context, instance, key)
		);
	};

	return Ellipse;
})(TextualBoundedObject);

Ellipse.prototype.baseClass = "ellipse";
Ellipse.prototype.anchors = "0 1 1 0";

Widget.alias("ellipse", Ellipse);

var Line = (function(_TextualBoundedObject) {
	inherits(Line, _TextualBoundedObject);

	function Line() {
		classCallCheck(this, Line);
		return possibleConstructorReturn(this, _TextualBoundedObject.apply(this, arguments));
	}

	Line.prototype.declareData = function declareData() {
		var _TextualBoundedObject2;

		(_TextualBoundedObject2 = _TextualBoundedObject.prototype.declareData).call.apply(
			_TextualBoundedObject2,
			[this].concat(Array.prototype.slice.call(arguments), [
				{
					colorIndex: undefined,
					stroke: undefined
				}
			])
		);
	};

	Line.prototype.render = function render(context, instance, key) {
		var data = instance.data,
			colorIndex = instance.colorIndex;
		var bounds = data.bounds;

		return VDOM.createElement(
			"g",
			{ key: key, className: data.classNames },
			VDOM.createElement("line", {
				className: this.CSS.element(this.baseClass, "line", colorIndex != null && "color-" + colorIndex),
				x1: bounds.l,
				y1: bounds.t,
				x2: bounds.r,
				y2: bounds.b,
				style: data.style,
				stroke: data.stroke
			}),
			this.renderChildren(context, instance, key)
		);
	};

	return Line;
})(TextualBoundedObject);

Line.prototype.anchors = "0 1 1 0";
Line.prototype.baseClass = "line";

Widget.alias("line", Line);

export { Rect, BoundedObject, TextualBoundedObject, Svg, Rectangle, ClipRect, Ellipse, Line, Text };
