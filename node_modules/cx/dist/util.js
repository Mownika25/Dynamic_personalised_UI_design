var Console = {
	log: function log() {
		var _console;

		if (typeof window != "undefined" && window.console) (_console = console).log.apply(_console, arguments);
	},

	warn: function warn() {
		var _console2;

		if (typeof window != "undefined" && window.console) (_console2 = console).warn.apply(_console2, arguments);
	}
};

var activeFlags = {
	deprecated: true
};

function debug(flag) {
	if (process.env.NODE_ENV !== "production") {
		if (!activeFlags[flag]) return;

		Console.log.apply(Console, arguments);
	}
}

var Debug = {
	enable: function enable(flag) {
		if (process.env.NODE_ENV !== "production") {
			activeFlags[flag] = true;
		}
	},

	disable: function disable(flag) {
		if (process.env.NODE_ENV !== "production") {
			activeFlags[flag] = false;
		}
	},

	log: debug
};

var renderFlag = "render";
var prepareFlag = "prepare";
var processDataFlag = "process-data";
var cleanupFlag = "cleanup";
var menuFlag = "menu";
var focusFlag = "focus";
var internalFlag = "internal";
var shouldUpdateFlag = "should-update";
var appDataFlag = "app-data";
var tooltipsFlag = "tooltips";
var deprecatedFlag = "deprecated";
var destroyFlag = "destroy";

function isNumber(n) {
	return typeof n === "number";
}

function findFirst(el, condition) {
	if (condition(el)) return el;

	var children = el.childNodes;
	if (children)
		for (var i = 0; i < children.length; i++) {
			var child = findFirst(children[i], condition);
			if (child) return child;
		}
	return null;
}

function findFirstChild(el, condition) {
	var children = el.childNodes;
	if (children)
		for (var i = 0; i < children.length; i++) {
			var child = findFirst(children[i], condition);
			if (child) return child;
		}
	return null;
}

function closest(el, condition) {
	while (el) {
		if (condition(el)) return el;
		el = el.parentNode;
	}
	return null;
}

function closestParent(el, condition) {
	return el && closest(el.parentNode, condition);
}

function isFocused(el) {
	return document.activeElement == el;
}

function isFocusedDeep(el) {
	return document.activeElement == el || el.contains(document.activeElement);
}

var focusableWithoutTabIndex = ["INPUT", "SELECT", "TEXTAREA", "A", "BUTTON"];

function isFocusable(el) {
	var firstPass = el && isNumber(el.tabIndex) && el.tabIndex >= 0;
	if (!firstPass) return false;

	if (focusableWithoutTabIndex.indexOf(el.tagName) != -1 && !el.hasAttribute("disabled")) return true;

	return el.hasAttribute("tabindex");
}

function getFocusedElement() {
	return document.activeElement;
}

function isDescendant(el, descEl) {
	return el.contains(descEl);
}

function isSelfOrDescendant(el, descEl) {
	return el == descEl || el.contains(descEl);
}

var _typeof =
	typeof Symbol === "function" && typeof Symbol.iterator === "symbol"
		? function(obj) {
				return typeof obj;
			}
		: function(obj) {
				return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype
					? "symbol"
					: typeof obj;
			};

var classCallCheck = function(instance, Constructor) {
	if (!(instance instanceof Constructor)) {
		throw new TypeError("Cannot call a class as a function");
	}
};

var globalCacheIdentifier = 1;

var GlobalCacheIdentifier = (function() {
	function GlobalCacheIdentifier() {
		classCallCheck(this, GlobalCacheIdentifier);
	}

	GlobalCacheIdentifier.get = function get$$1() {
		return globalCacheIdentifier;
	};

	GlobalCacheIdentifier.change = function change() {
		globalCacheIdentifier++;
	};

	return GlobalCacheIdentifier;
})();

function isUndefined(v) {
	return v === undefined;
}

function isArray(a) {
	return Array.isArray(a);
}

//Culture dependent formatters are defined in the ui package.

var defaultFormatter = function defaultFormatter(v) {
	return v.toString();
};

var formatFactory = {
	string: function string() {
		return defaultFormatter;
	},

	wrap: function wrap(part0, prefix, suffix) {
		if (!prefix) prefix = "";

		if (!suffix) suffix = "";

		return function(value) {
			return prefix + value.toString() + suffix;
		};
	},

	fixed: function fixed(part0, digits) {
		return function(value) {
			return value.toFixed(digits);
		};
	},

	prefix: function prefix(part0, _prefix) {
		if (!_prefix) _prefix = "";

		return function(value) {
			return _prefix + value.toString();
		};
	},

	suffix: function suffix(part0, _suffix) {
		if (!_suffix) _suffix = "";

		return function(value) {
			return value.toString() + _suffix;
		};
	},

	uppercase: function uppercase() {
		return function(value) {
			return value.toString().toUpperCase();
		};
	},

	lowercase: function lowercase() {
		return function(value) {
			return value.toString().toLowerCase();
		};
	},

	urlencode: function urlencode() {
		return function(value) {
			return encodeURIComponent(value);
		};
	},

	number: function number(part0, minFractionDigits, maxFractionDigits) {
		var _resolveMinMaxFractio = resolveMinMaxFractionDigits(minFractionDigits, maxFractionDigits),
			minimumFractionDigits = _resolveMinMaxFractio.minimumFractionDigits,
			maximumFractionDigits = _resolveMinMaxFractio.maximumFractionDigits;

		var trimmable = maximumFractionDigits - minimumFractionDigits;
		if (trimmable > 0) {
			if (minimumFractionDigits == 0) ++trimmable;
			return function(value) {
				return trimFractionZeros(value.toFixed(maximumFractionDigits), trimmable);
			};
		}
		return function(value) {
			return value.toFixed(maximumFractionDigits);
		};
	},

	percentage: function percentage(part0, minFractionDigits, maxFractionDigits) {
		var numberFormatter = formatFactory.number(part0, minFractionDigits, maxFractionDigits);
		return function(value) {
			return numberFormatter(value * 100) + "%";
		};
	},

	percentageSign: function percentageSign(part0, minFractionDigits, maxFractionDigits) {
		var numberFormatter = formatFactory.number(part0, minFractionDigits, maxFractionDigits);
		return function(value) {
			return numberFormatter(value) + "%";
		};
	},

	date: function date() {
		return function(value) {
			var date = new Date(value);
			return date.getMonth() + 1 + "/" + date.getDate() + "/" + date.getFullYear();
		};
	},

	time: function time() {
		return function(value) {
			var date = new Date(value);
			var h = date.getHours() >= 10 ? date.getHours() : "0" + date.getHours();
			var m = date.getMinutes() >= 10 ? date.getMinutes() : "0" + date.getMinutes();
			return h + ":" + m;
		};
	},

	datetime: function datetime() {
		var date = formatFactory.date();
		var time = formatFactory.time();
		return function(value) {
			return date(value) + " " + time(value);
		};
	}
};

formatFactory.s = formatFactory.str = formatFactory.string;
formatFactory.f = formatFactory.fixed;
formatFactory.n = formatFactory.number;
formatFactory.p = formatFactory.percentage;
formatFactory.ps = formatFactory.percentageSign;
formatFactory.d = formatFactory.date;
formatFactory.t = formatFactory.time;
formatFactory.dt = formatFactory.datetime;

function buildFormatter(format) {
	var formatter = defaultFormatter;
	if (format) {
		var pipeParts = format.split("|");
		var nullText = pipeParts[1] || "";
		var colonSepParts = pipeParts[0].split(":");
		for (var i = 0; i < colonSepParts.length; i++) {
			var parts = colonSepParts[i].split(";");
			var factory = formatFactory[parts[0]];
			if (!factory) debug("Unknown string format: " + format);
			else if (i == 0) formatter = factory.apply(undefined, parts);
			else {
				var outerFmt = factory.apply(undefined, parts);
				var innerFmt = formatter;
				formatter = function formatter(v) {
					return outerFmt(innerFmt(v));
				};
			}
		}
	}
	return function(v) {
		return v == null || v === "" ? nullText : formatter(v);
	};
}

var format = {
	cache: {}
};

function getFormatCache() {
	if (format.cacheIdentifier != GlobalCacheIdentifier.get()) {
		format = {
			cache: {},
			cacheIdentifier: GlobalCacheIdentifier.get()
		};
	}
	return format.cache;
}

function getFormatter(format) {
	if (!format) format = "";
	var formatCache = getFormatCache();
	var formatter = formatCache[format];
	if (!formatter) formatter = formatCache[format] = buildFormatter(format);

	return formatter;
}

var Format = (function() {
	function Format() {
		classCallCheck(this, Format);
	}

	Format.value = function value(v, format) {
		var formatter = getFormatter(format);
		return formatter(v);
	};

	Format.parse = function parse(format) {
		return getFormatter(format);
	};

	Format.register = function register(format, formatter) {
		this.registerFactory(format, function() {
			return formatter;
		});
	};

	Format.registerFactory = function registerFactory(format, factory) {
		var _this = this;

		if (isArray(format))
			format.forEach(function(f) {
				return _this.registerFactory(f, factory);
			});
		else formatFactory[format] = factory;
	};

	return Format;
})();

function resolveMinMaxFractionDigits(minimumFractionDigits, maximumFractionDigits) {
	minimumFractionDigits = minimumFractionDigits != null ? Number(minimumFractionDigits) : minimumFractionDigits;
	maximumFractionDigits = maximumFractionDigits != null ? Number(maximumFractionDigits) : maximumFractionDigits;

	if (isNumber(minimumFractionDigits)) {
		if (isUndefined(maximumFractionDigits)) maximumFractionDigits = minimumFractionDigits;
		else if (isNumber(maximumFractionDigits) && maximumFractionDigits < minimumFractionDigits)
			maximumFractionDigits = minimumFractionDigits;
	} else if (minimumFractionDigits == null && maximumFractionDigits == null) {
		minimumFractionDigits = 0;
		maximumFractionDigits = 18;
	}

	return {
		minimumFractionDigits: minimumFractionDigits,
		maximumFractionDigits: maximumFractionDigits
	};
}

function trimFractionZeros(str, max) {
	var cnt = 0,
		l = str.length;
	while (cnt < max && (str[l - 1 - cnt] === "0" || str[l - 1 - cnt] === ".")) {
		cnt++;
	}
	return cnt > 0 ? str.substring(0, l - cnt) : str;
}

//http://stackoverflow.com/questions/36428283/arrow-function-eval-preprocessor

function expandFatArrows(code) {
	var arrowHeadRegex = RegExp(/(\((?:\w+,)*\w+\)|\(\)|\w+)[\r\t ]*=>\s*/);
	var arrowHeadMatch = arrowHeadRegex.exec(code);

	if (arrowHeadMatch) {
		//if no match return as it is
		var params = arrowHeadMatch[1];
		if (params.charAt(0) !== "(") {
			params = "(" + params + ")";
		}
		var index = arrowHeadMatch.index;
		var startCode = code.substring(0, index);

		var bodyAndNext = code.substring(index + arrowHeadMatch[0].length);

		var curlyCount = 0;
		var curlyPresent = false;
		var singleLineBodyEnd = 0;
		var bodyEnd = 0;

		for (var i = 0; i < bodyAndNext.length; i++) {
			var ch = bodyAndNext[i];
			if (ch === "{") {
				curlyPresent = true;
				curlyCount++;
			} else if (ch === "}") {
				curlyCount--;
			} else if (!curlyPresent) {
				//any character other than { or }
				singleLineBodyEnd = getSingeLineBodyEnd(bodyAndNext, i);
				break;
			}
			if (curlyPresent && curlyCount === 0) {
				bodyEnd = i;
				break;
			}
		}

		var body;

		if (curlyPresent) {
			if (curlyCount !== 0) {
				throw Error("Could not match curly braces for function at : " + index);
			}
			body = bodyAndNext.substring(0, bodyEnd + 1);

			var restCode = bodyAndNext.substring(bodyEnd + 1);
			var expandedFun = "(function " + params + body + ").bind(this)";
			code = startCode + expandedFun + restCode;
		} else {
			if (singleLineBodyEnd <= 0) {
				throw Error("could not get function body at : " + index);
			}

			body = bodyAndNext.substring(0, singleLineBodyEnd + 1);

			restCode = bodyAndNext.substring(singleLineBodyEnd + 1);
			expandedFun = "(function " + params + "{return " + body + "}).bind(this)";
			code = startCode + expandedFun + restCode;
		}

		return expandFatArrows(code); //recursive call
	}
	return code;
}

function getSingeLineBodyEnd(bodyCode, startI) {
	var braceCount = 0;
	var openingQuote = null;

	for (var i = startI; i < bodyCode.length; i++) {
		var ch = bodyCode[i];
		var lastCh = null;
		if (ch === '"' || ch === "'") {
			openingQuote = ch;
			i = skipQuotedString(bodyCode, openingQuote, i);
			ch = bodyCode[i];
		}

		if (i !== 0 && !bodyCode[i - 1].match(/[\t\r ]/)) {
			lastCh = bodyCode[i - 1];
		}

		if (ch === "{" || ch === "(") {
			braceCount++;
		} else if (ch === "}" || ch === ")") {
			braceCount--;
		}

		if (braceCount < 0 || (lastCh !== "." && ch === "\n")) {
			return i - 1;
		}
	}

	return bodyCode.length;
}

function skipQuotedString(bodyAndNext, openingQuote, i) {
	var matchFound = false; //matching quote
	var openingQuoteI = i;
	i++;
	for (; i < bodyAndNext.length; i++) {
		var ch = bodyAndNext[i];
		var lastCh = i !== 0 ? bodyAndNext[i - 1] : null;

		if (ch !== openingQuote || (ch === openingQuote && lastCh === "\\")) {
			continue; //skip quoted string
		} else if (ch === openingQuote) {
			//matched closing quote
			matchFound = false;
			break;
		}
	}
	if (matchFound) {
		throw new Error("Could not find closing quote for quote at : " + openingQuoteI);
	}
	return i;
}

function innerTextTrim(str) {
	str = str.replace(/\t/g, "");
	str = str.replace(/(\s*[\r\n]\s*)/g, "");
	return str;
}

function isDigit(x) {
	return x >= "0" && x <= "9";
}

function isFunction(f) {
	return typeof f === "function";
}

function isObject(o) {
	return o !== null && (typeof o === "undefined" ? "undefined" : _typeof(o)) === "object";
}

function isPromise(x) {
	return isObject(x) && isFunction(x.then);
}

var isTouch = null;

function isTouchDevice() {
	if (isTouch == null) isTouch = typeof window != "undefined" && "ontouchstart" in window;
	return isTouch;
}

var KeyCode = {
	backspace: 8,
	tab: 9,
	enter: 13,
	shift: 16,
	ctrl: 17,
	alt: 18,
	esc: 27,
	space: 32,
	pageUp: 33,
	pageDown: 34,
	end: 35,
	home: 36,
	left: 37,
	up: 38,
	right: 39,
	down: 40,
	insert: 45,
	delete: 46
};

function parseStyle(str) {
	if (typeof str != "string") return str;

	var style = {},
		parts = str.split(";");

	for (var i = 0; i < parts.length; i++) {
		var part = parts[i];

		var colonIndex = part.indexOf(":");
		if (colonIndex == -1) continue;

		var name = part.substring(0, colonIndex).trim();
		var value = part.substring(colonIndex + 1).trim();

		name = name
			.split("-")
			.map(function(p, i) {
				return i == 0 ? p : p[0].toUpperCase() + p.substring(1);
			})
			.join("");
		style[name] = value;
	}

	return style;
}

function quoteStr(str) {
	if (str == null) return str;
	return "'" + str.replace(/'/g, "\\i") + "'";
}

function findScrollableParent(sourceEl) {
	var horizontal = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

	var scrollParent =
		sourceEl &&
		closest(sourceEl, function(el) {
			if (el.nodeType != Node.ELEMENT_NODE) return false;
			if (el.offsetHeight >= el.scrollHeight) return false;
			var oy = getComputedStyle(el)[horizontal ? "overflow-x" : "overflow-y"];
			return oy == "auto" || oy == "scroll";
		});
	return scrollParent || document.scrollingElement || document.documentElement;
}

function getScrollerBoundingClientRect(scrollEl) {
	if (scrollEl == document.body || scrollEl == document.documentElement)
		return {
			left: 0,
			top: 0,
			right: window.innerWidth,
			bottom: window.innerHeight,
			width: window.innerWidth,
			height: window.innerHeight
		};

	return scrollEl.getBoundingClientRect();
}

function scrollElementIntoView(el) {
	var parentEl = findScrollableParent(el);
	if (!parentEl) return false;

	var pr = getScrollerBoundingClientRect(parentEl);
	var er = el.getBoundingClientRect();

	if (er.bottom > pr.bottom) parentEl.scrollTop = Math.max(0, parentEl.scrollTop + er.bottom - pr.bottom);

	if (er.top < pr.top) parentEl.scrollTop = Math.max(0, parentEl.scrollTop + er.top - pr.top);

	return true;
}

function shallowEquals(v1, v2) {
	if (v1 === v2) return true;

	var t1 = typeof v1 === "undefined" ? "undefined" : _typeof(v1),
		t2 = typeof v2 === "undefined" ? "undefined" : _typeof(v2),
		k = void 0,
		i = void 0;

	if (t1 != t2) return false;

	if (v1 == null || v2 == null)
		//this captures undefined too
		return false;

	if (t1 == "object") {
		if (isArray(v1)) {
			if (!isArray(v2) || v1.length != v2.length) return false;

			for (i = 0; i < v1.length; i++) {
				if (!shallowEquals(v1[i], v2[i])) return false;
			}
			return true;
		} else {
			for (k in v1) {
				if (v1.hasOwnProperty(k) && (!v2.hasOwnProperty(k) || v1[k] !== v2[k])) return false;
			}
			for (k in v2) {
				if (v2.hasOwnProperty(k) && (!v1.hasOwnProperty(k) || v1[k] !== v2[k])) return false;
			}
			return true;
		}
	}
	return v1 === v2;
}

var appLoopFlag = "app-loop";
var vdomRenderFlag = "vdom-render";

var counter = {};
var activeFlags$1 = {};

var nowImpl = function nowImpl() {
	return Date.now();
};

function now() {
	if (process.env.NODE_ENV !== "production") {
		return nowImpl();
	} else {
		return 0;
	}
}

function enable(flag) {
	if (process.env.NODE_ENV !== "production") {
		activeFlags$1[flag] = true;
	}
}

function disable(flag) {
	if (process.env.NODE_ENV !== "production") {
		activeFlags$1[flag] = false;
	}
}

function count(flag) {
	if (process.env.NODE_ENV !== "production") {
		if (!activeFlags$1[flag]) return;
		return (counter[flag] = (counter[flag] || 0) + 1);
	}
}

function log(flag) {
	if (process.env.NODE_ENV !== "production") {
		if (!activeFlags$1[flag]) return;

		Console.log.apply(Console, arguments);
	}
}

if (
	process.env.NODE_ENV !== "production" &&
	typeof window != "undefined" &&
	window.performance &&
	window.performance.now
) {
	nowImpl = function nowImpl() {
		return performance.now();
	};
}

var Timing = {
	now: now,
	enable: enable,
	disable: disable,
	count: count,
	log: log
};

function dateDiff(d1, d2) {
	return d1.getTime() - d2.getTime();
}

function zeroTime(d) {
	return new Date(d.getFullYear(), d.getMonth(), d.getDate());
}

function monthStart(d) {
	return new Date(d.getFullYear(), d.getMonth(), 1);
}

function lowerBoundCheck(date, minDate) {
	var exclusive = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

	var d = dateDiff(date, minDate);
	return d > 0 || (d == 0 && !exclusive);
}

function upperBoundCheck(date, maxDate) {
	var exclusive = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

	var d = dateDiff(date, maxDate);
	return d < 0 || (d == 0 && !exclusive);
}

function maxDate() {
	var max = arguments[0];
	for (var i = 1; i < arguments.length; i++) {
		if (dateDiff(max, arguments[i]) < 0) max = arguments[i];
	}
	return max;
}

function minDate() {
	var min = arguments[0];
	for (var i = 1; i < arguments.length; i++) {
		if (dateDiff(min, arguments[i]) > 0) min = arguments[i];
	}
	return min;
}

function sameDate(d1, d2) {
	return d1.getDate() == d2.getDate() && d1.getMonth() == d2.getMonth() && d1.getYear() == d2.getYear();
}

function hue2rgb(p, q, t) {
	if (t < 0) t += 1;
	if (t > 1) t -= 1;
	if (t < 1 / 6) return p + (q - p) * 6 * t;
	if (t < 1 / 2) return q;
	if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
	return p;
}

function hslToRgb(h, s, l) {
	h /= 360;
	s /= 100;
	l /= 100;
	var r, g, b;

	if (s == 0) {
		r = g = b = l; // achromatic
	} else {
		var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
		var p = 2 * l - q;
		r = hue2rgb(p, q, h + 1 / 3);
		g = hue2rgb(p, q, h);
		b = hue2rgb(p, q, h - 1 / 3);
	}

	return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
}

function parseColor(color) {
	if (!color) return null;

	if (color[0] == "#") return parseHexColor(color);

	if (color.indexOf("rgb") == 0) return parseRgbColor(color);

	if (color.indexOf("hsl") == 0) return parseHslColor(color);

	throw new Error("Unknown color format: " + color + ".");
}

function parseHexColor(color) {
	if (!color) return null;

	if (color[0] != "#") throw new Error("Invalid color " + color + ".");

	if (color.length == 4)
		return {
			type: "rgba",
			r: parseInt(color.charAt(1), 16) * 0x11,
			g: parseInt(color.charAt(2), 16) * 0x11,
			b: parseInt(color.charAt(3), 16) * 0x11,
			a: 1
		};

	if (color.length != 7) throw new Error("Invalid color " + color + ".");

	return {
		type: "rgba",
		r: parseInt(color.substr(1, 2), 16),
		g: parseInt(color.substr(3, 2), 16),
		b: parseInt(color.substr(5, 2), 16),
		a: 1
	};
}

function parseRgbColor(color) {
	if (!color) return null;

	color = color.trim();
	var values;

	if (color.indexOf("rgba(") == 0) {
		values = color
			.substring(5, color.length - 1)
			.split(",")
			.map(function(x) {
				return parseFloat(x.trim());
			});
		if (values.length != 4) throw new Error("Invalid color " + color + ".");

		return {
			type: "rgba",
			r: values[0],
			g: values[1],
			b: values[2],
			a: values[3]
		};
	}

	if (color.indexOf("rgb(") != 0) throw new Error("Invalid color " + color + ".");

	values = color
		.substring(5, color.length - 1)
		.split(",")
		.map(function(x) {
			return parseFloat(x.trim());
		});
	if (values.length != 3) throw new Error("Invalid color " + color + ".");

	return {
		type: "rgba",
		r: values[0],
		g: values[1],
		b: values[2],
		a: 1
	};
}

function parseHslColor(color) {
	if (!color) return null;

	color = color.trim();
	var values;

	if (color.indexOf("hsla(") == 0) {
		values = color
			.substring(5, color.length - 1)
			.split(",")
			.map(function(x) {
				return parseFloat(x.trim());
			});
		if (values.length != 4) throw new Error("Invalid color " + color + ".");

		return {
			type: "hsla",
			h: values[0],
			s: values[1],
			l: values[2],
			a: values[3]
		};
	}

	if (color.indexOf("hsl(") != 0) throw new Error("Invalid color " + color + ".");

	values = color
		.substring(5, color.length - 1)
		.split(",")
		.map(function(x) {
			return parseFloat(x.trim());
		});
	if (values.length != 3) throw new Error("Invalid color " + color + ".");

	return {
		type: "hsla",
		h: values[0],
		s: values[1],
		l: values[2],
		a: 1
	};
}

function componentToHex(c) {
	var hex = c.toString(16);
	return hex.length == 1 ? "0" + hex : hex;
}

function rgbToHex(r, g, b) {
	return "#" + componentToHex(r) + componentToHex(g) + componentToHex(b);
}

function rgbToHsl(r, g, b) {
	r /= 255;
	g /= 255;
	b /= 255;
	var max = Math.max(r, g, b),
		min = Math.min(r, g, b);
	var h,
		s,
		l = (max + min) / 2;

	if (max == min) {
		h = s = 0; // achromatic
	} else {
		var d = max - min;
		s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
		switch (max) {
			case r:
				h = (g - b) / d + (g < b ? 6 : 0);
				break;
			case g:
				h = (b - r) / d + 2;
				break;
			case b:
				h = (r - g) / d + 4;
				break;
		}
		h /= 6;
	}

	return [h * 360, s * 100, l * 100];
}

//shamelessly taken from https://davidwalsh.name/vendor-prefix

var getPrefixes = function getPrefixes() {
	var styles = window.getComputedStyle(document.documentElement, ""),
		pre = (Array.prototype.slice
			.call(styles)
			.join("")
			.match(/-(moz|webkit|ms)-/) ||
			(styles.OLink === "" && ["", "o"]))[1],
		dom = "WebKit|Moz|MS|O".match(new RegExp("(" + pre + ")", "i"))[1];
	return {
		dom: dom,
		lowercase: pre,
		css: "-" + pre + "-",
		js: pre[0].toUpperCase() + pre.substr(1)
	};
};

var prefixes;

function getVendorPrefix(type) {
	if (!prefixes) prefixes = getPrefixes();

	return prefixes[type];
}

var stopPropagation = function stopPropagation(e) {
	return e.stopPropagation();
};
var preventDefault = function preventDefault(e) {
	return e.preventDefault();
};

function escapeSpecialRegexCharacters(s) {
	return s.replace(/[\\^$*+?.()|[\]{}]/g, "\\$&");
}

function getSearchQueryPredicate(query, options) {
	if (!query)
		return function() {
			return true;
		};

	var terms = query.split(" ").filter(Boolean);
	if (terms.length == 0)
		return function() {
			return true;
		};

	var regexes = terms.map(function(w) {
		return new RegExp(escapeSpecialRegexCharacters(w), "gi");
	});

	if (regexes.length == 1) {
		var regex = regexes[0];
		return function(text) {
			return text.match(regex);
		};
	}

	return function(text) {
		return regexes.every(function(re) {
			return text.match(re);
		});
	};
}

var passiveEventsSupported = null;

function browserSupportsPassiveEventHandlers() {
	if (passiveEventsSupported == null) {
		try {
			passiveEventsSupported = false;
			var options = Object.defineProperty({}, "passive", {
				get: function get() {
					passiveEventsSupported = true;
				}
			});
			window.addEventListener("test", null, options);
		} catch (e) {}
	}

	return passiveEventsSupported;
}

// This is primarily used for tooltips which behave differently on touch.
// For example, tooltips are commonly toggled on touch or disabled completely.
// To detect if mousemove is actually caused by a touch event, we check
// if device supports touch events and when the last touch event happened.
// Touch detection might cause bad scroll performance on devices which do not
// support passive event listeners, and in that case detection relies only on
// presence of touch events, without inspection of each event.

var insideTouchEvent = 0;
var lastTouchEvent = 0;
var isTouchDetectionEnabled = false;

function enableTouchEventDetection() {
	if (isTouchDevice() && !isTouchDetectionEnabled) {
		var options = void 0;

		if (browserSupportsPassiveEventHandlers())
			options = {
				passive: true
			};

		document.addEventListener(
			"touchstart",
			function() {
				insideTouchEvent++;
				//console.log('TOUCHSTART');
				lastTouchEvent = new Date().getTime();
			},
			options
		);

		document.addEventListener(
			"touchmove",
			function() {
				//console.log('TOUCHMOVE');
				lastTouchEvent = new Date().getTime();
			},
			options
		);

		document.addEventListener(
			"touchend",
			function() {
				insideTouchEvent--;
				lastTouchEvent = new Date().getTime();
				//console.log('TOUCHEND');
			},
			options
		);

		isTouchDetectionEnabled = true;
	}
}

function isTouchEvent() {
	return isTouchDevice() && (!isTouchDetectionEnabled || new Date().getTime() - lastTouchEvent < 1000);
}

//enable touch event detection if there is no performance penalty on scrolling
if (isTouchDevice() && browserSupportsPassiveEventHandlers()) enableTouchEventDetection();

function debounce(callback, delay) {
	var timer = void 0;

	return function() {
		var context = this,
			args = arguments;

		clearTimeout(timer);

		timer = setTimeout(function() {
			callback.apply(context, args);
		}, delay);
	};
}

function throttle(callback, delay) {
	var timer = void 0,
		context = void 0,
		args = void 0;

	return function() {
		context = this;
		args = arguments;

		if (!timer)
			timer = setTimeout(function() {
				callback.apply(context, args);
				timer = null;
			}, delay);
	};
}

var SubscriberList = (function() {
	function SubscriberList() {
		classCallCheck(this, SubscriberList);

		this.clear();
	}

	SubscriberList.prototype.getSlot = function getSlot() {
		if (this.freeSlots.length) return this.freeSlots.pop();

		var slot = String(this.nextSlot++);
		return slot;
	};

	SubscriberList.prototype.recycle = function recycle(slot, callback) {
		if (this.subscriptions[slot] === callback) {
			this.freeSlots.push(slot);
			delete this.subscriptions[slot];
		}
	};

	SubscriberList.prototype.subscribe = function subscribe(callback) {
		var _this = this;

		var slot = this.getSlot();
		this.subscriptions[slot] = callback;
		return function() {
			_this.recycle(slot, callback);
		};
	};

	SubscriberList.prototype.clear = function clear() {
		this.subscriptions = {};
		this.freeSlots = [];
		this.nextSlot = 1;
	};

	SubscriberList.prototype.getSubscribers = function getSubscribers() {
		var result = [];
		for (var key in this.subscriptions) {
			result.push(this.subscriptions[key]);
		}
		return result;
	};

	SubscriberList.prototype.notify = function notify() {
		for (var key in this.subscriptions) {
			var _subscriptions;

			(_subscriptions = this.subscriptions)[key].apply(_subscriptions, arguments);
		}
	};

	SubscriberList.prototype.execute = function execute(callback) {
		for (var key in this.subscriptions) {
			callback(this.subscriptions[key]);
		}
	};

	return SubscriberList;
})();

function isNonEmptyArray(x) {
	return Array.isArray(x) && x.length > 0;
}

function isString(s) {
	return typeof s === "string";
}

function isDefined(v) {
	return v !== undefined;
}

function routeAppend(base, path) {
	var result = base;
	if (path) {
		if (path[0] == "/") {
			if (result[result.length - 1] == "/") result += path.substring(1);
			else result += path;
		} else if (result[result.length - 1] == "/") result += path;
		else result += "/" + path;
	}
	return result;
}

function reverseSlice(array, start) {
	var last = array.length - 1;
	while (start < last) {
		var x = array[start];
		array[start] = array[last];
		array[last] = x;
		start++;
		last--;
	}
}

export {
	Console,
	debug,
	Debug,
	renderFlag,
	prepareFlag,
	processDataFlag,
	cleanupFlag,
	menuFlag,
	focusFlag,
	internalFlag,
	shouldUpdateFlag,
	appDataFlag,
	tooltipsFlag,
	deprecatedFlag,
	destroyFlag,
	findFirst,
	findFirstChild,
	closest,
	closestParent,
	isFocused,
	isFocusedDeep,
	isFocusable,
	getFocusedElement,
	isDescendant,
	isSelfOrDescendant,
	Format,
	resolveMinMaxFractionDigits,
	trimFractionZeros,
	expandFatArrows,
	GlobalCacheIdentifier,
	innerTextTrim,
	isDigit,
	isPromise,
	isTouchDevice,
	KeyCode,
	parseStyle,
	quoteStr,
	scrollElementIntoView,
	shallowEquals,
	appLoopFlag,
	vdomRenderFlag,
	now,
	Timing,
	dateDiff,
	zeroTime,
	monthStart,
	lowerBoundCheck,
	upperBoundCheck,
	maxDate,
	minDate,
	sameDate,
	hslToRgb,
	parseColor,
	parseHexColor,
	parseRgbColor,
	parseHslColor,
	rgbToHex,
	rgbToHsl,
	getVendorPrefix,
	stopPropagation,
	preventDefault,
	getSearchQueryPredicate,
	escapeSpecialRegexCharacters,
	browserSupportsPassiveEventHandlers,
	enableTouchEventDetection,
	isTouchEvent,
	debounce,
	throttle,
	SubscriberList,
	findScrollableParent,
	getScrollerBoundingClientRect,
	isNonEmptyArray,
	isArray,
	isObject,
	isNumber,
	isFunction,
	isString,
	isUndefined,
	isDefined,
	routeAppend,
	reverseSlice
};
