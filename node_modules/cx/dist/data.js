import {
	Format,
	SubscriberList,
	expandFatArrows,
	isArray,
	isDefined,
	isDigit,
	isFunction,
	isString,
	isUndefined,
	quoteStr
} from "./util";

var _typeof =
	typeof Symbol === "function" && typeof Symbol.iterator === "symbol"
		? function(obj) {
				return typeof obj;
			}
		: function(obj) {
				return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype
					? "symbol"
					: typeof obj;
			};

var classCallCheck = function(instance, Constructor) {
	if (!(instance instanceof Constructor)) {
		throw new TypeError("Cannot call a class as a function");
	}
};

var _extends =
	Object.assign ||
	function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];

			for (var key in source) {
				if (Object.prototype.hasOwnProperty.call(source, key)) {
					target[key] = source[key];
				}
			}
		}

		return target;
	};

var inherits = function(subClass, superClass) {
	if (typeof superClass !== "function" && superClass !== null) {
		throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
	}

	subClass.prototype = Object.create(superClass && superClass.prototype, {
		constructor: {
			value: subClass,
			enumerable: false,
			writable: true,
			configurable: true
		}
	});
	if (superClass)
		Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : (subClass.__proto__ = superClass);
};

var possibleConstructorReturn = function(self, call) {
	if (!self) {
		throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	}

	return call && (typeof call === "object" || typeof call === "function") ? call : self;
};

var bindingCache = {};
var Binding = (function() {
	function Binding(path) {
		classCallCheck(this, Binding);

		this.path = path;
		this.parts = path.split(".");
		var fstr = "return (x";
		var cpath = "x";

		for (var i = 0; i < this.parts.length; i++) {
			if (this.parts[i][0] >= "0" && this.parts[i][0] <= "9") cpath += "[" + this.parts[i] + "]";
			else cpath += "." + this.parts[i];

			if (i + 1 < this.parts.length) fstr += " && " + cpath;
			else fstr += " ? " + cpath + " : undefined";
		}

		fstr += ")";
		this.value = new Function("x", fstr);
	}

	Binding.prototype.set = function set$$1(state, value) {
		var cv = this.value(state);
		if (cv === value) return state;

		var ns = Object.assign({}, state);
		var o = ns;

		for (var i = 0; i < this.parts.length; i++) {
			var part = this.parts[i];
			var no = i == this.parts.length - 1 ? value : Object.assign({}, o[part]);
			o[part] = no;
			o = no;
		}

		return ns;
	};

	Binding.prototype.delete = function _delete(state) {
		var ns = Object.assign({}, state);
		var o = ns;
		var part;

		for (var i = 0; i < this.parts.length - 1; i++) {
			part = this.parts[i];
			var no = Object.assign({}, o[part]);
			o[part] = no;
			o = no;
		}

		part = this.parts[this.parts.length - 1];
		if (!o.hasOwnProperty(part)) return state;

		delete o[part];

		return ns;
	};

	Binding.get = function get$$1(path) {
		if (isString(path)) {
			var b = bindingCache[path];
			if (b) return b;

			b = new Binding(path);
			bindingCache[path] = b;
			return b;
		}
		return path; //if binding instance is provided return it
	};

	return Binding;
})();

function computable() {
	for (var _len = arguments.length, selectorsAndCompute = Array(_len), _key = 0; _key < _len; _key++) {
		selectorsAndCompute[_key] = arguments[_key];
	}

	if (selectorsAndCompute.length == 0)
		throw new Error("computable requires at least a compute function to be passed in arguments.");

	var compute = selectorsAndCompute[selectorsAndCompute.length - 1];
	if (typeof compute != "function") throw new Error("Last argument to the computable function should be a function.");

	var inputs = [],
		a = void 0;

	for (var i = 0; i + 1 < selectorsAndCompute.length; i++) {
		a = selectorsAndCompute[i];
		if (isString(a)) inputs.push(Binding.get(a).value);
		else if (a.createSelector) inputs.push(a.createSelector());
		else if (isFunction(a)) inputs.push(a);
		else
			throw new Error(
				"Invalid selector type '" + (typeof a === "undefined" ? "undefined" : _typeof(a)) + "' received."
			);
	}

	function memoize(amnesia, warmupData) {
		var lastValue = void 0,
			lastArgs =
				warmupData &&
				inputs.map(function(s, i) {
					return s(warmupData);
				});

		return function(data) {
			var dirty = amnesia;

			if (!lastArgs) {
				lastArgs = Array.from({ length: inputs.length });
				dirty = true;
			}

			for (var _i = 0; _i < inputs.length; _i++) {
				var v = inputs[_i](data);
				if (v !== lastArgs[_i]) dirty = true;
				lastArgs[_i] = v;
			}

			if (dirty) lastValue = compute.apply(null, lastArgs);

			return lastValue;
		};
	}

	var selector = memoize(true);
	selector.memoize = memoize;
	return selector;
}

/*
   Helper usage example

   Expression.registerHelper('_', _);
   let e = Expression.compile('_.min({data})');
 */

var expCache = {};
var helpers = {};
var helperNames = [];
var helperValues = [];
var expFatArrows = null;

function getExpr(expr) {
	if (expr.memoize) return expr;

	function memoize() {
		var lastValue = void 0,
			lastRunBindings = {},
			lastRunResults = {},
			getters = {},
			currentData = void 0,
			len = -1;

		var get = function get(bindingWithFormat) {
			var getter = getters[bindingWithFormat];
			if (!getter) {
				var binding = bindingWithFormat,
					format = void 0;
				var colonIndex = bindingWithFormat.indexOf(":");
				if (colonIndex != -1) {
					format = Format.parse(bindingWithFormat.substring(colonIndex + 1));
					binding = bindingWithFormat.substring(0, colonIndex);
				}
				var b = Binding.get(binding);
				getter = function getter(data) {
					var value = b.value(data);
					lastRunBindings[len] = b.value;
					lastRunResults[len] = value;
					len++;
					return value;
				};

				if (format) {
					var valueGetter = getter;
					getter = function getter(data) {
						return format(valueGetter(data));
					};
				}

				getters[bindingWithFormat] = getter;
			}
			return getter(currentData);
		};

		return function(data) {
			var i = 0;
			for (; i < len; i++) {
				if (lastRunBindings[i](data) !== lastRunResults[i]) break;
			}
			if (i !== len) {
				len = 0;
				currentData = data;
				lastValue = expr(get);
			}
			return lastValue;
		};
	}

	var result = memoize();
	result.memoize = memoize;
	return result;
}

function expression(str) {
	var _ref;

	if (isFunction(str)) return getExpr(str);

	var r = expCache[str];
	if (r) return r;

	var quote = false;

	var termStart = -1,
		curlyBrackets = 0,
		percentExpression = void 0;

	var fb = ["return ("];

	var args = {};
	var formats = [];
	var subExpr = 0;

	for (var i = 0; i < str.length; i++) {
		var c = str[i];
		switch (c) {
			case "{":
				if (curlyBrackets > 0) curlyBrackets++;
				else {
					if (!quote && termStart < 0 && (str[i + 1] != "{" || str[i - 1] == "%")) {
						termStart = i + 1;
						curlyBrackets = 1;
						percentExpression = str[i - 1] == "%";
						if (percentExpression) fb.pop(); //%
					} else if (str[i - 1] != "{") fb.push(c);
				}
				break;

			case "}":
				if (termStart >= 0) {
					if (--curlyBrackets == 0) {
						var term = str.substring(termStart, i);
						var formatStart = 0;
						if (term[0] == "[") formatStart = term.indexOf("]");
						var colon = term.indexOf(":", formatStart > 0 ? formatStart : 0);
						var binding = colon == -1 ? term : term.substring(0, colon);
						var format = colon == -1 ? null : term.substring(colon + 1);
						var argName = binding.replace(/\./g, "_");
						if (isDigit(argName[0])) argName = "$" + argName;
						if (percentExpression || (binding[0] == "[" && binding[binding.length - 1] == "]")) {
							argName = "expr" + ++subExpr;
							args[argName] = expression(percentExpression ? binding : binding.substring(1, binding.length - 1));
						} else args[argName] = binding;
						if (format) {
							var formatter = "fmt" + formats.length;
							fb.push(formatter, "(", argName, ", ", quoteStr(format), ")");
							formats.push(Format.parse(format));
						} else fb.push(argName);
						termStart = -1;
					}
				} else fb.push(c);

				break;

			case '"':
			case "'":
				if (curlyBrackets == 0) {
					if (!quote) quote = c;
					else if (str[i - 1] != "\\" && quote == c) quote = false;
					fb.push(c);
				}
				break;

			default:
				if (termStart < 0) fb.push(c);
				break;
		}
	}

	fb.push(")");

	var body = fb.join("");

	if (expFatArrows) body = expFatArrows(body);

	//console.log(body);
	var keys = Object.keys(args);

	var compute = (_ref = new (Function.prototype.bind.apply(
		Function,
		[null].concat(
			formats.map(function(f, i) {
				return "fmt" + i;
			}),
			keys,
			helperNames,
			[body]
		)
	))()).bind.apply(_ref, [Format].concat(formats, helperValues));
	var selector = computable.apply(
		undefined,
		keys
			.map(function(k) {
				return args[k];
			})
			.concat([compute])
	);
	expCache[str] = selector;
	return selector;
}

var Expression = {
	get: function get(str) {
		return expression(str);
	},

	compile: function compile(str) {
		return this.get(str).memoize();
	},

	registerHelper: function registerHelper(name, helper) {
		helpers[name] = helper;
		helperNames = Object.keys(helpers);
		helperValues = helperNames.map(function(n) {
			return helpers[n];
		});
	}
};

function plugFatArrowExpansion(impl) {
	expFatArrows = impl;
}

function plus(str) {
	return str.length ? str + " + " : str;
}

var tplCache = {};

function stringTemplate(str) {
	var expr = tplCache[str];
	if (expr) return expr;

	expr = "";

	var termStart = -1,
		quoteStart = 0,
		term,
		bracketsOpen = 0,
		percentSign;

	for (var i = 0; i < str.length; i++) {
		var c = str[i];
		switch (c) {
			case "{":
				if (termStart < 0) {
					if (str[i + 1] == "{" && str[i - 1] != "%") {
						expr = plus(expr) + quoteStr(str.substring(quoteStart, i) + "{");
						i++;
						quoteStart = i + 1;
					} else {
						termStart = i + 1;
						percentSign = str[i - 1] == "%";
						if (i > quoteStart) expr = plus(expr) + quoteStr(str.substring(quoteStart, percentSign ? i - 1 : i));
						bracketsOpen = 1;
					}
				} else bracketsOpen++;
				break;

			case "}":
				if (termStart >= 0) {
					if (--bracketsOpen == 0) {
						term = str.substring(termStart, i);
						if (term.indexOf(":") == -1) term += ":s";
						expr = plus(expr) + (percentSign ? "%{" : "{") + term + "}";
						termStart = -1;
						quoteStart = i + 1;
						bracketsOpen = 0;
					}
				} else if (str[i + 1] == "}") {
					expr = plus(expr) + quoteStr(str.substring(quoteStart, i) + "}");
					i++;
					quoteStart = i + 1;
				}
				break;
		}
	}

	if (quoteStart < str.length) expr = plus(expr) + quoteStr(str.substring(quoteStart));

	//console.log(expr);

	return (tplCache[str] = expression(expr));
}

var StringTemplate = {
	get: function get(str) {
		return stringTemplate(str);
	},

	compile: function compile(str) {
		return stringTemplate(str).memoize();
	},

	format: function format(_format) {
		for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
			args[_key - 1] = arguments[_key];
		}

		return stringTemplate(_format)(args);
	}
};

var View = (function() {
	function View(config) {
		classCallCheck(this, View);

		Object.assign(this, config);
		this.cache = {
			version: -1
		};
		if (this.store) this.setStore(this.store);
	}

	View.prototype.getData = function getData() {
		throw new Error("abstract method");
	};

	View.prototype.init = function init(path, value) {
		if (path instanceof Binding) path = path.path;
		else if ((typeof path === "undefined" ? "undefined" : _typeof(path)) == "object" && path != null) {
			var changed = false;
			for (var key in path) {
				if (path.hasOwnProperty(key) && this.get(key) === undefined && this.setItem(key, path[key])) changed = true;
			}
			return changed;
		}

		if (this.get(path) === undefined) return this.setItem(path, value);

		return false;
	};

	View.prototype.set = function set$$1(path, value) {
		if (path instanceof Binding) path = path.path;
		else if ((typeof path === "undefined" ? "undefined" : _typeof(path)) == "object" && path != null) {
			var changed = false;
			for (var key in path) {
				if (path.hasOwnProperty(key) && this.setItem(key, path[key])) changed = true;
			}
			return changed;
		}
		return this.setItem(path, value);
	};

	View.prototype.copy = function copy(from, to) {
		var value = this.get(from);
		this.set(to, value);
	};

	View.prototype.move = function move(from, to) {
		var _this = this;

		this.batch(function() {
			_this.copy(from, to);
			_this.delete(from);
		});
	};

	//protected

	View.prototype.setItem = function setItem(path, value) {
		if (this.store) return this.store.setItem(path, value);

		throw new Error("abstract method");
	};

	View.prototype.delete = function _delete(path) {
		var _this2 = this;

		if (path instanceof Binding) path = path.path;
		else if (arguments.length > 1) path = Array.from(arguments);

		if (isArray(path))
			return path
				.map(function(arg) {
					return _this2.deleteItem(arg);
				})
				.some(Boolean);

		return this.deleteItem(path);
	};

	//protected

	View.prototype.deleteItem = function deleteItem(path) {
		if (this.store) return this.store.deleteItem(path);

		throw new Error("abstract method");
	};

	View.prototype.clear = function clear() {
		if (this.store) return this.store.clear();

		throw new Error("abstract method");
	};

	View.prototype.get = function get$$1(path) {
		var storeData = this.getData();

		if (arguments.length > 1) path = Array.from(arguments);

		if (isArray(path))
			return path.map(function(arg) {
				return Binding.get(arg).value(storeData);
			});

		return Binding.get(path).value(storeData);
	};

	View.prototype.toggle = function toggle(path) {
		return this.set(path, !this.get(path));
	};

	View.prototype.update = function update(path, updateFn) {
		for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
			args[_key - 2] = arguments[_key];
		}

		return this.set(path, updateFn.apply(null, [this.get(path)].concat(args)));
	};

	View.prototype.batch = function batch(callback) {
		var dirty = this.silently(callback);
		if (dirty) this.notify();
		return dirty;
	};

	View.prototype.silently = function silently(callback) {
		if (this.store) return this.store.silently(callback);

		throw new Error("abstract method");
	};

	View.prototype.notify = function notify(path) {
		if (this.notificationsSuspended) this.dirty = true;
		else this.doNotify(path);
	};

	View.prototype.doNotify = function doNotify(path) {
		if (this.store) return this.store.notify(path);

		throw new Error("abstract method");
	};

	View.prototype.subscribe = function subscribe(callback) {
		if (this.store) return this.store.subscribe(callback);

		throw new Error("abstract method");
	};

	View.prototype.load = function load(data) {
		return this.batch(function(store) {
			for (var key in data) {
				store.set(key, data[key]);
			}
		});
	};

	View.prototype.dispatch = function dispatch(action) {
		if (this.store) return this.store.dispatch(action);

		throw new Error("The underlying store doesn't support dispatch.");
	};

	View.prototype.getMeta = function getMeta() {
		return this.meta;
	};

	View.prototype.setStore = function setStore(store) {
		this.store = store;
		this.meta = store.getMeta();
	};

	return View;
})();

View.prototype.sealed = false; //indicate that data should be copied before virtual items are added

var SubscribableView = (function(_View) {
	inherits(SubscribableView, _View);

	function SubscribableView(config) {
		classCallCheck(this, SubscribableView);

		var _this = possibleConstructorReturn(this, _View.call(this, config));

		_this.subscribers = new SubscriberList();
		_this.changes = [];
		return _this;
	}

	SubscribableView.prototype.subscribe = function subscribe(callback) {
		return this.subscribers.subscribe(callback);
	};

	SubscribableView.prototype.unsubscribeAll = function unsubscribeAll() {
		this.subscribers.clear();
	};

	SubscribableView.prototype.doNotify = function doNotify(path) {
		var _this2 = this;

		if (this.notificationsSuspended) return;

		if (!this.async) {
			this.subscribers.notify([path]);
		} else {
			this.changes.push(path || "");
			if (!this.scheduled) {
				this.scheduled = true;
				setTimeout(function() {
					_this2.scheduled = false;
					var changes = _this2.changes;
					_this2.changes = [];
					_this2.subscribers.notify(changes);
				}, 0);
			}
		}
	};

	SubscribableView.prototype.silently = function silently(callback) {
		this.notificationsSuspended = (this.notificationsSuspended || 0) + 1;
		var wasDirty = this.dirty,
			dirty = void 0;
		this.dirty = false;
		try {
			callback(this);
		} finally {
			this.notificationsSuspended--;
			dirty = this.dirty;
			this.dirty = wasDirty;
		}
		return dirty;
	};

	return SubscribableView;
})(View);

SubscribableView.prototype.async = false;

var Store = (function(_SubscribableView) {
	inherits(Store, _SubscribableView);

	function Store() {
		var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
		classCallCheck(this, Store);

		var _this = possibleConstructorReturn(this, _SubscribableView.call(this));

		_this.data = config.data || {};
		_this.meta = {
			version: 0
		};
		return _this;
	}

	Store.prototype.getData = function getData() {
		return this.data;
	};

	Store.prototype.setItem = function setItem(path, value) {
		var next = Binding.get(path).set(this.data, value);
		if (next != this.data) {
			this.data = next;
			this.meta.version++;
			this.notify(path);
			return true;
		}
		return false;
	};

	Store.prototype.deleteItem = function deleteItem(path) {
		var next = Binding.get(path).delete(this.data);
		if (next != this.data) {
			this.data = next;
			this.meta.version++;
			this.notify(path);
			return true;
		}
		return false;
	};

	Store.prototype.clear = function clear() {
		this.data = {};
		this.meta.version++;
		this.notify();
	};

	return Store;
})(SubscribableView);

Store.prototype.async = false;

var ExposedRecordView = (function(_View) {
	inherits(ExposedRecordView, _View);

	function ExposedRecordView() {
		classCallCheck(this, ExposedRecordView);
		return possibleConstructorReturn(this, _View.apply(this, arguments));
	}

	ExposedRecordView.prototype.getData = function getData() {
		if (this.cache.durable && this.meta.version === this.cache.version && this.cache.itemIndex === this.itemIndex)
			return this.cache.result;

		this.cache.result = this.embed(this.store.getData());
		this.cache.version = this.meta.version;
		this.cache.itemIndex = this.itemIndex;
		this.cache.durable = this.immutable || this.store.sealed;
		return this.cache.result;
	};

	ExposedRecordView.prototype.embed = function embed(data) {
		var collection = this.collectionBinding.value(data);
		var record = collection[this.itemIndex];
		var copy = this.immutable || this.store.sealed ? _extends({}, data) : data;
		copy[this.recordName] = record;
		if (this.indexName) copy[this.indexName] = this.itemIndex;
		return copy;
	};

	ExposedRecordView.prototype.setIndex = function setIndex(index) {
		this.itemIndex = index;
	};

	ExposedRecordView.prototype.setItem = function setItem(path, value) {
		if (path == this.recordName || path.indexOf(this.recordName + ".") == 0) {
			var storeData = this.store.getData();
			var collection = this.collectionBinding.value(storeData);
			var data = this.embed(storeData);
			var d = Binding.get(path).set(data, value);
			if (d === data) return false;
			var record = d[this.recordName];
			var newCollection = [].concat(
				collection.slice(0, this.itemIndex),
				[record],
				collection.slice(this.itemIndex + 1)
			);
			return this.store.setItem(this.collectionBinding.path, newCollection);
		}
		return this.store.setItem(path, value);
	};

	ExposedRecordView.prototype.deleteItem = function deleteItem(path) {
		var storeData, collection, newCollection;

		if (path == this.recordName) {
			storeData = this.store.getData();
			collection = this.collectionBinding.value(storeData);
			newCollection = [].concat(collection.slice(0, this.itemIndex), collection.slice(this.itemIndex + 1));
			return this.store.setItem(this.collectionBinding.path, newCollection);
		} else if (path.indexOf(this.recordName + ".") == 0) {
			storeData = this.store.getData();
			collection = this.collectionBinding.value(storeData);
			var data = this.embed(storeData);
			var d = Binding.get(path).delete(data);
			if (d === data) return false;
			var record = d[this.recordName];
			newCollection = [].concat(collection.slice(0, this.itemIndex), [record], collection.slice(this.itemIndex + 1));
			return this.store.setItem(this.collectionBinding.path, newCollection);
		}

		return this.store.deleteItem(path);
	};

	return ExposedRecordView;
})(View);

ExposedRecordView.prototype.immutable = false;

var ExposedValueView = (function(_View) {
	inherits(ExposedValueView, _View);

	function ExposedValueView() {
		classCallCheck(this, ExposedValueView);
		return possibleConstructorReturn(this, _View.apply(this, arguments));
	}

	ExposedValueView.prototype.getData = function getData() {
		if (this.cache.durable && this.meta.version === this.cache.version && this.cache.key === this.key)
			return this.cache.result;

		var data = this.store.getData();
		var container = this.containerBinding.value(data) || {};
		var record = container[this.key];

		this.cache.version = this.meta.version;
		this.cache.key = this.key;
		this.cache.durable = this.immutable || this.store.sealed;
		this.cache.result = this.immutable || this.store.sealed ? _extends({}, data) : data;
		this.cache.result[this.recordName] = record;
		return this.cache.result;
	};

	ExposedValueView.prototype.setKey = function setKey(key) {
		this.key = key;
	};

	ExposedValueView.prototype.getKey = function getKey() {
		return this.key;
	};

	ExposedValueView.prototype.setItem = function setItem(path, value) {
		if (path == this.recordName || path.indexOf(this.recordName + ".") == 0) {
			var data = this.getData();
			var d = Binding.get(path).set(data, value);
			if (d === data) return false;
			var container = this.containerBinding.value(d);
			var record = d[this.recordName];
			var newContainer = Object.assign({}, container);
			newContainer[this.key] = record;
			return this.store.setItem(this.containerBinding.path, newContainer);
		}
		return this.store.setItem(path, value);
	};

	ExposedValueView.prototype.deleteItem = function deleteItem(path) {
		var data, container, newContainer;

		if (path == this.recordName) {
			data = this.getData();
			container = this.containerBinding.value(data);
			if (!container.hasOwnProperty(path)) return false;
			newContainer = Object.assign({}, container);
			delete newContainer[this.key];
			this.store.set(this.containerBinding.path, newContainer);
		} else if (path.indexOf(this.recordName + ".") == 0) {
			data = this.getData();
			var d = Binding.get(path).delete(data);
			if (d === data) return false;
			container = this.containerBinding.value(d);
			var record = d[this.recordName];
			newContainer = Object.assign({}, container);
			newContainer[this.key] = record;
			return this.store.setItem(this.containerBinding.path, newContainer);
		}

		return this.store.deleteItem(path);
	};

	return ExposedValueView;
})(View);

ExposedValueView.prototype.immutable = false;

var ReadOnlyDataView = (function(_View) {
	inherits(ReadOnlyDataView, _View);

	function ReadOnlyDataView() {
		classCallCheck(this, ReadOnlyDataView);
		return possibleConstructorReturn(this, _View.apply(this, arguments));
	}

	ReadOnlyDataView.prototype.getData = function getData() {
		if (this.cache.durable && this.meta.version === this.cache.version && this.cache.data === this.data)
			return this.cache.result;

		var data = this.store.getData();
		this.cache.durable = this.immutable || this.store.sealed;
		this.cache.result = this.cache.durable ? Object.assign({}, data, this.data) : Object.assign(data, this.data);
		this.cache.version = this.meta.version;
		this.cache.data = this.data;
		return this.cache.result;
	};

	ReadOnlyDataView.prototype.setData = function setData(data) {
		this.data = data;
	};

	return ReadOnlyDataView;
})(View);

ReadOnlyDataView.prototype.immutable = false;

var ZoomIntoPropertyView = (function(_View) {
	inherits(ZoomIntoPropertyView, _View);

	function ZoomIntoPropertyView() {
		classCallCheck(this, ZoomIntoPropertyView);
		return possibleConstructorReturn(this, _View.apply(this, arguments));
	}

	ZoomIntoPropertyView.prototype.getData = function getData() {
		if (this.cache.version != this.meta.version) {
			var _babelHelpers$extends;

			var data = this.store.getData();
			var x = this.binding.value(data);
			if (x != null && (typeof x === "undefined" ? "undefined" : _typeof(x)) != "object")
				throw new Error("Zoomed value must be an object.");
			this.cache.result = _extends(
				{},
				x,
				((_babelHelpers$extends = {}),
				(_babelHelpers$extends[this.rootName] = !this.store.sealed ? _extends({}, data) : data),
				_babelHelpers$extends)
			);
			this.cache.version = this.meta.version;
		}
		return this.cache.result;
	};

	ZoomIntoPropertyView.prototype.setItem = function setItem(path, value) {
		if (path.indexOf(this.rootName + ".") == 0) this.store.setItem(path.substring(this.rootName.length + 1), value);
		else this.store.setItem(this.binding.path + "." + path, value);
	};

	ZoomIntoPropertyView.prototype.deleteItem = function deleteItem(path) {
		if (path instanceof Binding) path = path.path;

		if (path.indexOf(this.rootName + ".") == 0) this.store.deleteItem(path.substring(this.rootName.length + 1));
		else this.store.deleteItem(this.binding.path + "." + path);
	};

	return ZoomIntoPropertyView;
})(View);

ZoomIntoPropertyView.prototype.rootName = "$root";

function createStructuredSelector(selector, constants) {
	var lastResult = Object.assign({}, constants);

	var keys = Object.keys(selector);
	if (keys.length == 0)
		return function() {
			return lastResult;
		};

	return function(data) {
		var result = lastResult,
			k = void 0,
			v = void 0,
			i = void 0;
		for (i = 0; i < keys.length; i++) {
			k = keys[i];
			v = selector[k](data);
			if (result === lastResult) {
				if (v === lastResult[k]) continue;
				result = Object.assign({}, lastResult);
			}
			result[k] = v;
		}
		return (lastResult = result);
	};
}

function isSelector(config) {
	if (config == null) return true;

	switch (typeof config === "undefined" ? "undefined" : _typeof(config)) {
		case "object":
			if (config.type || config.$type) return false;
			if (config.bind) return true;
			if (config.tpl) return true;
			if (config.expr) return true;
			return false;

		case "function":
			return true;

		case "string":
			return true;

		case "number":
			return true;

		case "boolean":
			return true;
	}

	return false;
}

var nullF = function nullF() {
	return null;
};

function getSelector(config) {
	if (config == null) return nullF;

	switch (typeof config === "undefined" ? "undefined" : _typeof(config)) {
		case "object":
			if (isArray(config)) {
				var _selectors = config.map(function(x) {
					return getSelector(x);
				});
				return function(data) {
					return _selectors.map(function(elementSelector) {
						return elementSelector(data);
					});
				};
			}

			if (config.bind) return Binding.get(config.bind).value;

			if (config.tpl) return StringTemplate.get(config.tpl);

			if (config.expr) return Expression.get(config.expr);

			var selectors = {};
			var constants = {};

			for (var key in config) {
				if (isSelector(config[key])) selectors[key] = getSelector(config[key]);
				else constants[key] = config[key];
			}
			return createStructuredSelector(selectors, constants);

		case "function":
			return config;

		default:
			return function() {
				return config;
			};
	}
}

function defaultValue(pv) {
	if ((typeof pv === "undefined" ? "undefined" : _typeof(pv)) == "object" && pv && pv.structured)
		return pv.defaultValue;

	return pv;
}

function getSelectorConfig(props, values, nameMap) {
	var functions = {},
		structures = {},
		defaultValues = {},
		constants = void 0,
		p = void 0,
		v = void 0,
		pv = void 0,
		constant = true;

	for (p in props) {
		v = values[p];
		pv = props[p];

		if (isUndefined(v) && pv && (pv.bind || pv.tpl || pv.expr)) v = pv;

		if (v === null) {
			if (!constants) constants = {};
			constants[p] = null;
		} else if ((typeof v === "undefined" ? "undefined" : _typeof(v)) == "object") {
			if (v.bind) {
				if (isUndefined(v.defaultValue) && v != pv) v.defaultValue = defaultValue(pv);
				if (isDefined(v.defaultValue)) defaultValues[v.bind] = v.defaultValue;
				nameMap[p] = v.bind;
				functions[p] = Binding.get(v.bind).value;
				constant = false;
			} else if (v.expr) {
				functions[p] = Expression.get(v.expr);
				constant = false;
			} else if (v.tpl) {
				functions[p] = StringTemplate.get(v.tpl);
				constant = false;
			} else if (pv && (typeof pv === "undefined" ? "undefined" : _typeof(pv)) == "object" && pv.structured) {
				if (isArray(v)) functions[p] = getSelector(v);
				else structures[p] = getSelectorConfig(v, v, {});
				constant = false;
			} else {
				if (!constants) constants = {};
				constants[p] = v;
			}
		} else if (isFunction(v)) {
			functions[p] = v;
			constant = false;
		} else {
			if (isUndefined(v)) {
				if (isUndefined(pv)) continue;
				v = defaultValue(pv);
			}

			if (isUndefined(v)) continue;

			if (!constants) constants = {};

			constants[p] = v;
		}
	}

	return {
		functions: functions,
		structures: structures,
		defaultValues: defaultValues,
		constants: constants,
		constant: constant
	};
}

function createSelector(_ref) {
	var functions = _ref.functions,
		structures = _ref.structures,
		constants = _ref.constants;

	var selector = {};

	for (var n in functions) {
		var f = functions[n];
		selector[n] = f.memoize ? f.memoize() : f;
	}

	for (var _n in structures) {
		selector[_n] = createSelector(structures[_n]);
	}
	return createStructuredSelector(selector, constants);
}

var StructuredSelector = (function() {
	function StructuredSelector(_ref2) {
		var props = _ref2.props,
			values = _ref2.values;
		classCallCheck(this, StructuredSelector);

		this.nameMap = {};
		this.config = getSelectorConfig(props, values, this.nameMap);
	}

	StructuredSelector.prototype.init = function init(store) {
		store.init(this.config.defaultValues);
	};

	StructuredSelector.prototype.create = function create() {
		return createSelector(this.config);
	};

	StructuredSelector.prototype.createStoreSelector = function createStoreSelector() {
		if (this.config.constant) {
			var result = _extends({}, this.config.constants);
			return function() {
				return result;
			};
		}
		var selector = this.create();
		return function(store) {
			return selector(store.getData());
		};
	};

	return StructuredSelector;
})();

var AggregateFunction = (function() {
	function AggregateFunction() {
		classCallCheck(this, AggregateFunction);
	}

	AggregateFunction.sum = function sum() {
		return new Sum();
	};

	AggregateFunction.avg = function avg() {
		return new Avg();
	};

	AggregateFunction.count = function count() {
		return new Count();
	};

	AggregateFunction.distinct = function distinct() {
		return new Distinct();
	};

	AggregateFunction.min = function min() {
		return new Min();
	};

	AggregateFunction.max = function max() {
		return new Max();
	};

	return AggregateFunction;
})();

var Sum = (function() {
	function Sum() {
		classCallCheck(this, Sum);
	}

	Sum.prototype.process = function process(value) {
		this.empty = false;
		if (!isNaN(value)) this.result += value;
		else this.invalid = true;
	};

	Sum.prototype.getResult = function getResult() {
		if (this.invalid) return null;
		return this.result;
	};

	return Sum;
})();

Sum.prototype.result = 0;
Sum.prototype.empty = true;

var Avg = (function() {
	function Avg() {
		classCallCheck(this, Avg);
	}

	Avg.prototype.process = function process(value) {
		var count = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

		this.empty = false;
		if (!isNaN(value) && !isNaN(count)) {
			this.result += value * count;
			this.count += count;
		} else this.invalid = true;
	};

	Avg.prototype.getResult = function getResult() {
		if (this.empty || this.invalid || this.count == 0) return null;
		return this.result / this.count;
	};

	return Avg;
})();

Avg.prototype.result = 0;
Avg.prototype.count = 0;
Avg.prototype.empty = true;

var Count = (function() {
	function Count() {
		classCallCheck(this, Count);
	}

	Count.prototype.process = function process(value) {
		this.empty = false;
		if (value != null) this.result++;
	};

	Count.prototype.getResult = function getResult() {
		if (this.empty || this.invalid) return null;
		return this.result;
	};

	return Count;
})();

Count.prototype.result = 0;
Count.prototype.empty = true;

var Distinct = (function() {
	function Distinct() {
		classCallCheck(this, Distinct);

		this.values = {};
	}

	Distinct.prototype.process = function process(value) {
		if (value == null || this.values[value]) return;
		this.values[value] = true;
		this.empty = false;
		this.result++;
	};

	Distinct.prototype.getResult = function getResult() {
		if (this.empty || this.invalid) return null;
		return this.result;
	};

	return Distinct;
})();

Distinct.prototype.result = 0;
Distinct.prototype.empty = true;

var Max = (function() {
	function Max() {
		classCallCheck(this, Max);
	}

	Max.prototype.process = function process(value) {
		if (!isNaN(value)) {
			if (this.empty) this.result = value;
			else if (value > this.result) this.result = value;
			this.empty = false;
		} else this.invalid = true;
	};

	Max.prototype.getResult = function getResult() {
		if (this.empty || this.invalid) return null;
		return this.result;
	};

	return Max;
})();

Max.prototype.result = 0;
Max.prototype.empty = true;

var Min = (function() {
	function Min() {
		classCallCheck(this, Min);
	}

	Min.prototype.process = function process(value) {
		if (!isNaN(value)) {
			if (this.empty) this.result = value;
			else if (value < this.result) this.result = value;
			this.empty = false;
		} else this.invalid = true;
	};

	Min.prototype.getResult = function getResult() {
		if (this.empty || this.invalid) return null;
		return this.result;
	};

	return Min;
})();

Min.prototype.result = 0;
Min.prototype.empty = true;

/*
 'column': {
   index: 0,
   sort: 'asc',
   group: true
   aggregate: 'count'
 }
 */

function transform(o, f) {
	var res = {};
	for (var k in o) {
		res[k] = f(o[k], k);
	}
	return res;
}

var Grouper = (function() {
	function Grouper(key, aggregates, dataGetter, nameGetter) {
		classCallCheck(this, Grouper);

		this.keys = Object.keys(key).map(function(k) {
			return {
				name: k,
				value: getSelector(key[k])
			};
		});
		if (nameGetter) this.nameGetter = getSelector(nameGetter);
		this.dataGetter =
			dataGetter ||
			function(x) {
				return x;
			};
		this.aggregates =
			aggregates &&
			transform(aggregates, function(prop) {
				if (!AggregateFunction[prop.type]) throw new Error("Unknown aggregate function '" + prop.type + "'.");

				return {
					value: getSelector(prop.value),
					weight: getSelector(prop.weight || 1),
					type: prop.type
				};
			});
		this.reset();
	}

	Grouper.prototype.reset = function reset() {
		this.groups = this.initGroup(this.keys.length == 0);
	};

	Grouper.prototype.initGroup = function initGroup(leaf) {
		if (!leaf) return {};

		return {
			records: [],
			indexes: [],
			aggregates:
				this.aggregates &&
				transform(this.aggregates, function(prop) {
					var f = AggregateFunction[prop.type];
					return {
						processor: f(),
						value: prop.value,
						weight: prop.weight
					};
				})
		};
	};

	Grouper.prototype.process = function process(record, index) {
		var data = this.dataGetter(record);
		var key = this.keys.map(function(k) {
			return k.value(data);
		});
		var g = this.groups;
		for (var i = 0; i < key.length; i++) {
			var sg = g[key[i]];
			if (!sg) {
				sg = g[key[i]] = this.initGroup(i + 1 == key.length);
				if (this.nameGetter) sg.name = this.nameGetter(data);
			}
			g = sg;
		}

		g.records.push(record);
		g.indexes.push(index);

		if (g.aggregates) {
			for (var k in g.aggregates) {
				g.aggregates[k].processor.process(g.aggregates[k].value(data), g.aggregates[k].weight(data));
			}
		}
	};

	Grouper.prototype.processAll = function processAll(records, indexes) {
		var _this = this;

		if (indexes) {
			for (var i = 0; i < records.length; i++) {
				this.process(records[i], indexes[i]);
			}
		} else
			records.forEach(function(r, i) {
				return _this.process(r, i);
			});
	};

	Grouper.prototype.report = function report(g, path, level, results) {
		var _this2 = this;

		if (level == this.keys.length) {
			var key = {};
			this.keys.forEach(function(k, i) {
				return (key[k.name] = path[i]);
			});
			results.push({
				key: key,
				name: g.name,
				records: g.records,
				indexes: g.indexes,
				aggregates: transform(g.aggregates, function(p) {
					return p.processor.getResult();
				})
			});
		} else {
			Object.keys(g).forEach(function(k) {
				return _this2.report(g[k], [].concat(path, [k]), level + 1, results);
			});
		}
	};

	Grouper.prototype.getResults = function getResults() {
		var g = this.groups;
		var results = [];
		this.report(g, [], 0, results);
		return results;
	};

	return Grouper;
})();

function getComparer(sorters, dataAccessor) {
	var data = (sorters || []).map(function(s) {
		var selector = s.field
			? function(x) {
					return x[s.field];
				}
			: getSelector(s.value);
		return {
			getter: dataAccessor
				? function(x) {
						return selector(dataAccessor(x));
					}
				: selector,
			factor: s.direction && s.direction[0].toLowerCase() == "d" ? -1 : 1
		};
	});

	return function(a, b) {
		var d = void 0,
			av = void 0,
			bv = void 0;
		for (var i = 0; i < data.length; i++) {
			d = data[i];
			av = d.getter(a);
			bv = d.getter(b);
			if (av == null) {
				if (bv == null) return 0;
				return -d.factor;
			} else {
				if (bv == null) return d.factor;

				if (av < bv) return -d.factor;

				if (av > bv) return d.factor;
			}
		}
		return 0;
	};
}

function indexSorter(sorters, dataAccessor) {
	var cmp = getComparer(sorters, dataAccessor);
	return function(data) {
		var result = Array.from({ length: data.length }, function(v, k) {
			return k;
		});
		result.sort(function(ia, ib) {
			return cmp(data[ia], data[ib]);
		});
		return result;
	};
}

function sorter(sorters, dataAccessor) {
	var cmp = getComparer(sorters, dataAccessor);

	return function(data) {
		var result = [].concat(data);
		result.sort(cmp);
		return result;
	};
}

function enableFatArrowExpansion() {
	plugFatArrowExpansion(expandFatArrows);
}

function append(array) {
	for (var _len = arguments.length, items = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
		items[_key - 1] = arguments[_key];
	}

	if (items.length == 0) return array;
	if (!array) return items;
	return [].concat(array, items);
}

function merge(item, data) {
	var result = item;
	if (data)
		for (var key in data) {
			result = Binding.get(key).set(result, data[key]);
		}
	return result;
}

function filter(array, callback) {
	if (array == null) return array;
	var result = array.filter(callback);
	if (result.length == array.length) return array;
	return result;
}

function updateArray(array, updateCallback, itemFilter, removeFilter) {
	if (!array) return array;

	var newArray = [];
	var dirty = false;

	for (var index = 0; index < array.length; index++) {
		var item = array[index];
		if (removeFilter && removeFilter(item, index)) {
			dirty = true;
			continue;
		}
		if (!itemFilter || itemFilter(item, index)) {
			var newItem = updateCallback(item, index);
			newArray.push(newItem);
			if (newItem !== item) dirty = true;
		} else newArray.push(item);
	}
	return dirty ? newArray : array;
}

function updateTree(array, updateCallback, itemFilter, childrenField, removeFilter) {
	return updateArray(
		array,
		function(item) {
			var _babelHelpers$extends;

			if (itemFilter(item)) return updateCallback(item);

			var children = item[childrenField];
			if (!Array.isArray(children)) return item;

			var updatedChildren = updateTree(children, updateCallback, itemFilter, childrenField, removeFilter);

			if (updatedChildren != children)
				return _extends(
					{},
					item,
					((_babelHelpers$extends = {}),
					(_babelHelpers$extends[childrenField] = updatedChildren),
					_babelHelpers$extends)
				);

			return item;
		},
		null,
		removeFilter
	);
}

function removeTreeNodes(array, criteria, childrenField) {
	return updateTree(
		array,
		null,
		function(item) {
			return false;
		},
		childrenField,
		criteria
	);
}

function diffArrays(oldArray, newArray, keyFn) {
	if (!keyFn)
		keyFn = function keyFn(e) {
			return e;
		};

	var map = new Map();

	for (var i = 0; i < oldArray.length; i++) {
		map.set(keyFn(oldArray[i]), oldArray[i]);
	}
	var added = [],
		changed = [],
		unchanged = [];

	for (var _i = 0; _i < newArray.length; _i++) {
		var el = newArray[_i];
		var k = keyFn(el);
		var old = map.get(k);
		if (isUndefined(old)) added.push(el);
		else {
			map.delete(k);
			if (el == old) unchanged.push(el);
			else
				changed.push({
					before: old,
					after: el
				});
		}
	}

	var removed = Array.from(map.values());

	return {
		added: added,
		changed: changed,
		unchanged: unchanged,
		removed: removed
	};
}

export {
	Binding,
	expression,
	Expression,
	plugFatArrowExpansion,
	stringTemplate,
	StringTemplate,
	View,
	SubscribableView,
	Store,
	ExposedRecordView,
	ExposedValueView,
	ReadOnlyDataView,
	ZoomIntoPropertyView,
	StructuredSelector,
	computable,
	getSelector,
	isSelector,
	Grouper,
	getComparer,
	indexSorter,
	sorter,
	enableFatArrowExpansion,
	append,
	merge,
	filter,
	updateArray,
	updateTree,
	removeTreeNodes,
	diffArrays
};
