import { CSS, Format, PureContainer, Selection, VDOM, Widget, getContent } from "./ui";
import { BoundedObject, Rect } from "./svg";
import {
	Format as Format$1,
	closest,
	debug,
	isArray,
	isDefined,
	isNumber,
	isUndefined,
	shallowEquals,
	stopPropagation
} from "./util";
import {
	HtmlElement,
	captureMouseOrTouch,
	getCursorPos,
	tooltipMouseLeave,
	tooltipMouseMove,
	tooltipParentDidMount,
	tooltipParentWillReceiveProps,
	tooltipParentWillUnmount
} from "./widgets";

var _typeof =
	typeof Symbol === "function" && typeof Symbol.iterator === "symbol"
		? function(obj) {
				return typeof obj;
			}
		: function(obj) {
				return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype
					? "symbol"
					: typeof obj;
			};

var classCallCheck = function(instance, Constructor) {
	if (!(instance instanceof Constructor)) {
		throw new TypeError("Cannot call a class as a function");
	}
};

var _extends =
	Object.assign ||
	function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];

			for (var key in source) {
				if (Object.prototype.hasOwnProperty.call(source, key)) {
					target[key] = source[key];
				}
			}
		}

		return target;
	};

var inherits = function(subClass, superClass) {
	if (typeof superClass !== "function" && superClass !== null) {
		throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
	}

	subClass.prototype = Object.create(superClass && superClass.prototype, {
		constructor: {
			value: subClass,
			enumerable: false,
			writable: true,
			configurable: true
		}
	});
	if (superClass)
		Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : (subClass.__proto__ = superClass);
};

var possibleConstructorReturn = function(self, call) {
	if (!self) {
		throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	}

	return call && (typeof call === "object" || typeof call === "function") ? call : self;
};

var Axis = (function(_BoundedObject) {
	inherits(Axis, _BoundedObject);

	function Axis() {
		classCallCheck(this, Axis);
		return possibleConstructorReturn(this, _BoundedObject.apply(this, arguments));
	}

	Axis.prototype.init = function init() {
		if (this.labelAnchor == "auto") this.labelAnchor = this.vertical ? (this.secondary ? "start" : "end") : "middle";

		if (this.labelDx == "auto") this.labelDx = 0;

		if (this.labelDy == "auto") this.labelDy = this.vertical ? "0.4em" : this.secondary ? 0 : "0.8em";

		if (isUndefined(this.minLabelDistance))
			this.minLabelDistance = this.vertical ? this.minLabelDistanceVertical : this.minLabelDistanceHorizontal;

		if (this.labelLineCountDyFactor == "auto")
			this.labelLineCountDyFactor = this.vertical ? -0.5 : this.secondary ? -1 : 0;

		_BoundedObject.prototype.init.call(this);
	};

	Axis.prototype.declareData = function declareData() {
		var _BoundedObject$protot;

		(_BoundedObject$protot = _BoundedObject.prototype.declareData).call.apply(
			_BoundedObject$protot,
			[
				this,
				{
					anchors: undefined,
					hideLabels: undefined,
					labelRotation: undefined
				}
			].concat(Array.prototype.slice.call(arguments))
		);
	};

	Axis.prototype.report = function report(context, instance) {
		return instance.calculator;
	};

	Axis.prototype.renderTicksAndLabels = function renderTicksAndLabels(context, instance, valueFormatter) {
		var _this2 = this;

		if (this.hidden) return false;

		var data = instance.data,
			calculator = instance.calculator;
		var bounds = data.bounds;

		var size = calculator.findTickSize(this.minLabelDistance);

		var labelClass = this.CSS.element(this.baseClass, "label");
		var offsetClass = this.CSS.element(this.baseClass, "label-offset");

		var x1,
			y1,
			x2,
			y2,
			tickSize = this.tickSize;

		if (this.vertical) {
			x1 = x2 = this.secondary ? bounds.r : bounds.l;
			y1 = bounds.b;
			y2 = bounds.t;
		} else {
			x1 = bounds.l;
			x2 = bounds.r;
			y1 = y2 = this.secondary ? bounds.t : bounds.b;
		}

		var res = [
			VDOM.createElement("line", {
				key: "line",
				className: this.CSS.element(this.baseClass, "line"),
				x1: x1,
				y1: y1,
				x2: x2,
				y2: y2
			}),
			null
		];
		var t = [];
		if (size > 0 && !data.hideLabels) {
			var ticks = calculator.getTicks([size]);
			ticks.forEach(function(serie, si) {
				serie.forEach(function(v, i) {
					var s = calculator.map(v);

					if (_this2.secondary) {
						x1 = _this2.vertical ? bounds.r : s;
						y1 = _this2.vertical ? s : bounds.t;
						x2 = _this2.vertical ? bounds.r + tickSize : s;
						y2 = _this2.vertical ? s : bounds.t - tickSize;
					} else {
						x1 = _this2.vertical ? bounds.l : s;
						y1 = _this2.vertical ? s : bounds.b;
						x2 = _this2.vertical ? bounds.l - tickSize : s;
						y2 = _this2.vertical ? s : bounds.b + tickSize;
					}

					t.push("M " + x1 + " " + y1 + " L " + x2 + " " + y2);

					var x, y;
					if (_this2.secondary) {
						x = _this2.vertical ? bounds.r + _this2.labelOffset : s;
						y = _this2.vertical ? s : bounds.t - _this2.labelOffset;
					} else {
						x = _this2.vertical ? bounds.l - _this2.labelOffset : s;
						y = _this2.vertical ? s : bounds.b + _this2.labelOffset;
					}

					var transform = data.labelRotation ? "rotate(" + data.labelRotation + " " + x + " " + y + ")" : null;
					res.push(
						VDOM.createElement(
							"text",
							{
								key: "label-" + si + "-" + i,
								className: labelClass,
								x: x,
								y: y,
								dx: _this2.labelDx,
								textAnchor: _this2.labelAnchor,
								transform: transform
							},
							_this2.wrapLines(valueFormatter(v), x, _this2.labelDy, offsetClass)
						)
					);
				});
			});
		}
		res[1] = VDOM.createElement("path", {
			key: "ticks",
			className: this.CSS.element(this.baseClass, "ticks"),
			d: t.join(" ")
		});
		return res;
	};

	Axis.prototype.wrapLines = function wrapLines(str, x, dy, offsetClass) {
		if (!this.labelWrap || typeof str != "string") return VDOM.createElement("tspan", { x: x, dy: dy }, str);

		var parts = str.split(" ");
		if (parts.length == 0) return null;

		var lines = [];
		var line = null;
		for (var i = 0; i < parts.length; i++) {
			if (!line) line = parts[i];
			else if (parts[i].length + line.length < this.labelMaxLineLength) line += " " + parts[i];
			else {
				lines.push(line);
				line = parts[i];
			}
		}
		lines.push(line);

		if (lines.length == 1) return VDOM.createElement("tspan", { x: x, dy: dy }, str);

		var offset = this.labelLineCountDyFactor * (lines.length - 1);
		var result = [dy != null && VDOM.createElement("tspan", { key: -2, className: offsetClass, dy: dy }, "_")];

		lines.forEach(function(p, i) {
			result.push(VDOM.createElement("tspan", { key: i, dy: (i == 0 ? offset : 1) + "em", x: x }, p));
		});

		return result;
	};

	Axis.prototype.prepare = function prepare(context, instance) {
		_BoundedObject.prototype.prepare.call(this, context, instance);
		var bounds = instance.data.bounds;

		var _ref = !this.vertical ? [bounds.l, bounds.r] : [bounds.b, bounds.t],
			a = _ref[0],
			b = _ref[1];

		instance.calculator.measure(a, b);
		if (!instance.calculator.isSame(instance.cached.axis)) instance.markShouldUpdate(context);
	};

	Axis.prototype.cleanup = function cleanup(context, instance) {
		var cached = instance.cached,
			calculator = instance.calculator;

		cached.axis = calculator.hash();
	};

	return Axis;
})(BoundedObject);

Axis.prototype.anchors = "0 1 1 0";
Axis.prototype.vertical = false;
Axis.prototype.secondary = false;
Axis.prototype.inverted = false;
Axis.prototype.hidden = false;
Axis.prototype.hideLabels = false;

Axis.prototype.tickSize = 3;
Axis.prototype.minTickDistance = 25;
Axis.prototype.minLabelDistanceVertical = 40;
Axis.prototype.minLabelDistanceHorizontal = 50;
Axis.prototype.labelOffset = 10;
Axis.prototype.labelRotation = 0;
Axis.prototype.labelAnchor = "auto";
Axis.prototype.labelDx = "auto";
Axis.prototype.labelDy = "auto";
Axis.prototype.labelWrap = false;
Axis.prototype.labelLineCountDyFactor = "auto";
Axis.prototype.labelMaxLineLength = 10;

Axis.namespace = "ui.svg.chart.axis";

var Chart = (function(_BoundedObject) {
	inherits(Chart, _BoundedObject);

	function Chart() {
		classCallCheck(this, Chart);
		return possibleConstructorReturn(this, _BoundedObject.apply(this, arguments));
	}

	Chart.prototype.init = function init() {
		_BoundedObject.prototype.init.call(this);

		if (!this.axes) this.axes = {};

		for (var axis in this.axes) {
			this.axes[axis] = Axis.create(this.axes[axis]);
		}
	};

	Chart.prototype.explore = function explore(context, instance) {
		var calculators = _extends({}, context.axes);

		context.push("axes", calculators);

		_BoundedObject.prototype.explore.call(this, context, instance);

		instance.axes = {};

		//because tree exploration uses depth-first search using a stack,
		//axes need to be registered last in order to be processed first
		for (var axis in this.axes) {
			var axisInstance = instance.getChild(context, this.axes[axis]);
			if (axisInstance.scheduleExploreIfVisible(context)) {
				instance.axes[axis] = axisInstance;
				calculators[axis] = this.axes[axis].report(context, axisInstance);
			}
		}

		instance.calculators = calculators;
	};

	Chart.prototype.exploreCleanup = function exploreCleanup(context, instance) {
		context.pop("axes");
	};

	Chart.prototype.prepare = function prepare(context, instance) {
		context.push("axes", instance.calculators);
		_BoundedObject.prototype.prepare.call(this, context, instance);
	};

	Chart.prototype.prepareCleanup = function prepareCleanup(context, instance) {
		context.pop("axes");
		_BoundedObject.prototype.prepareCleanup.call(this, context, instance);
	};

	Chart.prototype.render = function render(context, instance, key) {
		var axes = [];
		for (var k in instance.axes) {
			axes.push(getContent(instance.axes[k].render(context, key + "-axis-" + k)));
		}

		return [axes, this.renderChildren(context, instance, key)];
	};

	return Chart;
})(BoundedObject);

Chart.prototype.anchors = "0 1 1 0";
Chart.prototype.styled = true;

Widget.alias("chart", Chart);

var PieChart = (function(_BoundedObject) {
	inherits(PieChart, _BoundedObject);

	function PieChart() {
		classCallCheck(this, PieChart);
		return possibleConstructorReturn(this, _BoundedObject.apply(this, arguments));
	}

	PieChart.prototype.declareData = function declareData() {
		var _BoundedObject$protot;

		(_BoundedObject$protot = _BoundedObject.prototype.declareData).call.apply(
			_BoundedObject$protot,
			[this].concat(Array.prototype.slice.call(arguments), [
				{
					angle: undefined
				}
			])
		);
	};

	PieChart.prototype.explore = function explore(context, instance) {
		if (!instance.pie) instance.pie = new PieCalculator();
		var data = instance.data;

		instance.pie.reset(data.angle);

		context.push("pie", instance.pie);
		_BoundedObject.prototype.explore.call(this, context, instance);
	};

	PieChart.prototype.exploreCleanup = function exploreCleanup(context, instance) {
		context.pop("pie");
	};

	PieChart.prototype.prepare = function prepare(context, instance) {
		this.prepareBounds(context, instance);
		var data = instance.data,
			pie = instance.pie;

		pie.measure(data.bounds);
		var hash = pie.hash();
		instance.cache("hash", hash);
		pie.shouldUpdate = !shallowEquals(hash, instance.cached.hash);
		if (!pie.shouldUpdate) instance.markShouldUpdate(context);
		_BoundedObject.prototype.prepare.call(this, context, instance);
	};

	return PieChart;
})(BoundedObject);

PieChart.prototype.anchors = "0 1 1 0";

var PieCalculator = (function() {
	function PieCalculator() {
		classCallCheck(this, PieCalculator);
	}

	PieCalculator.prototype.reset = function reset(angle) {
		this.angleTotal = angle / 180 * Math.PI;
		this.stacks = {};
	};

	PieCalculator.prototype.acknowledge = function acknowledge(stack, value) {
		var s = this.stacks[stack];
		if (!s) s = this.stacks[stack] = { total: 0 };
		if (value > 0) s.total += value;
	};

	PieCalculator.prototype.hash = function hash() {
		var _this2 = this;

		return {
			angleTotal: this.angleTotal,
			stacks: Object.keys(this.stacks)
				.map(function(s) {
					return "" + _this2.stacks[s].angleFactor;
				})
				.join(":"),
			cx: this.cx,
			cy: this.cy,
			R: this.R
		};
	};

	PieCalculator.prototype.measure = function measure(rect) {
		for (var s in this.stacks) {
			var stack = this.stacks[s];
			stack.angleFactor = stack.total > 0 ? this.angleTotal / stack.total : 0;
			stack.lastAngle = 0;
		}
		this.cx = (rect.l + rect.r) / 2;
		this.cy = (rect.t + rect.b) / 2;
		this.R = Math.max(0, Math.min(rect.width(), rect.height())) / 2;
	};

	PieCalculator.prototype.map = function map(stack, value) {
		var s = this.stacks[stack];
		var angle = value * s.angleFactor;
		var startAngle = s.lastAngle;
		s.lastAngle += angle;
		return {
			startAngle: startAngle,
			endAngle: s.lastAngle,
			midAngle: (startAngle + s.lastAngle) / 2,
			cx: this.cx,
			cy: this.cy,
			R: this.R
		};
	};

	return PieCalculator;
})();

function createSvgArc(x, y, r0, r, startAngle, endAngle) {
	if (startAngle > endAngle) {
		var s = startAngle;
		startAngle = endAngle;
		endAngle = s;
	}

	var largeArc = endAngle - startAngle <= Math.PI ? 0 : 1;

	if (endAngle - startAngle >= 2 * Math.PI - 0.0001) endAngle = startAngle + 2 * Math.PI - 0.0001;

	var result = [];

	var startX, startY;

	if (r0 > 0) {
		startX = x + Math.cos(endAngle) * r0;
		startY = y - Math.sin(endAngle) * r0;
		result.push("M", startX, startY);

		result.push("A", r0, r0, 0, largeArc, 1, x + Math.cos(startAngle) * r0, y - Math.sin(startAngle) * r0);
	} else {
		startX = x;
		startY = y;
		result.push("M", startX, startY);
	}

	result.push(
		"L",
		x + Math.cos(startAngle) * r,
		y - Math.sin(startAngle) * r,
		"A",
		r,
		r,
		0,
		largeArc,
		0,
		x + Math.cos(endAngle) * r,
		y - Math.sin(endAngle) * r,
		"L",
		startX,
		startY
	);
	return result.join(" ");
}

PieChart.prototype.anchors = "0 1 1 0";
PieChart.prototype.angle = 360;

Widget.alias("pie-slice");
var PieSlice = (function(_PureContainer) {
	inherits(PieSlice, _PureContainer);

	function PieSlice() {
		classCallCheck(this, PieSlice);
		return possibleConstructorReturn(this, _PureContainer.apply(this, arguments));
	}

	PieSlice.prototype.init = function init() {
		this.selection = Selection.create(this.selection);
		_PureContainer.prototype.init.call(this);
	};

	PieSlice.prototype.declareData = function declareData() {
		var _PureContainer$protot;

		var selection = this.selection.configureWidget(this);
		(_PureContainer$protot = _PureContainer.prototype.declareData).call.apply(
			_PureContainer$protot,
			[this].concat(Array.prototype.slice.call(arguments), [
				selection,
				{
					active: true,
					r0: undefined,
					r: undefined,
					colorIndex: undefined,
					colorMap: undefined,
					colorName: undefined,
					offset: undefined,
					value: undefined,
					disabled: undefined,
					innerPointRadius: undefined,
					outerPointRadius: undefined,
					name: undefined,
					stack: undefined,
					legend: undefined
				}
			])
		);
	};

	PieSlice.prototype.prepareData = function prepareData(context, instance) {
		var data = instance.data;

		if (data.name && !data.colorName) data.colorName = data.name;

		_PureContainer.prototype.prepareData.call(this, context, instance);
	};

	PieSlice.prototype.explore = function explore(context, instance) {
		instance.pie = context.pie;
		if (!instance.pie) throw new Error("Pie.Slice must be placed inside a Pie.");

		var data = instance.data;

		instance.valid = isNumber(data.value) && data.value > 0;

		instance.colorMap = data.colorMap && context.getColorMap && context.getColorMap(data.colorMap);
		if (instance.colorMap && data.colorName) instance.colorMap.acknowledge(data.colorName);

		if (instance.valid && data.active) {
			instance.pie.acknowledge(data.stack, data.value);
			_PureContainer.prototype.explore.call(this, context, instance);
		}
	};

	PieSlice.prototype.prepare = function prepare(context, instance) {
		var _this4 = this;

		var data = instance.data,
			segment = instance.segment,
			pie = instance.pie,
			colorMap = instance.colorMap;

		if (colorMap && data.colorName) {
			data.colorIndex = colorMap.map(data.colorName);
			if (instance.cache("colorIndex", data.colorIndex)) instance.markShouldUpdate(context);
		}

		if (instance.valid && data.active) {
			var seg = pie.map(data.stack, data.value);

			if (
				!segment ||
				instance.shouldUpdate ||
				seg.startAngle != segment.startAngle ||
				seg.endAngle != segment.endAngle ||
				pie.shouldUpdate
			) {
				if (data.offset > 0) {
					seg.ox = seg.cx + Math.cos(seg.midAngle) * data.offset;
					seg.oy = seg.cy - Math.sin(seg.midAngle) * data.offset;
				} else {
					seg.ox = seg.cx;
					seg.oy = seg.cy;
				}

				seg.radiusMultiplier = 1;
				if (this.percentageRadius) seg.radiusMultiplier = seg.R / 100;

				var innerR = data.innerPointRadius != null ? data.innerPointRadius : data.r0;
				var outerR = data.outerPointRadius != null ? data.outerPointRadius : data.r;

				var ix = seg.ox + Math.cos(seg.midAngle) * innerR * seg.radiusMultiplier;
				var iy = seg.oy - Math.sin(seg.midAngle) * innerR * seg.radiusMultiplier;
				var ox = seg.ox + Math.cos(seg.midAngle) * outerR * seg.radiusMultiplier;
				var oy = seg.oy - Math.sin(seg.midAngle) * outerR * seg.radiusMultiplier;

				instance.segment = seg;
				instance.bounds = new Rect({
					l: ix,
					r: ox,
					t: iy,
					b: oy
				});

				instance.markShouldUpdate(context);
			}

			context.push("parentRect", instance.bounds);
		}

		if (data.name && data.legend && context.addLegendEntry)
			context.addLegendEntry(data.legend, {
				name: data.name,
				active: data.active,
				colorIndex: data.colorIndex,
				disabled: data.disabled,
				selected: this.selection.isInstanceSelected(instance),
				style: data.style,
				shape: "rect",
				onClick: function onClick(e) {
					_this4.onLegendClick(e, instance);
				}
			});
	};

	PieSlice.prototype.prepareCleanup = function prepareCleanup(context, instance) {
		if (instance.valid && instance.data.active) {
			context.pop("parentRect");
		}
	};

	PieSlice.prototype.onLegendClick = function onLegendClick(e, instance) {
		var allActions = this.legendAction == "auto";
		var data = instance.data;

		if (allActions || this.legendAction == "toggle") if (instance.set("active", !data.active)) return;

		if (allActions || this.legendAction == "select") this.handleClick(e, instance);
	};

	PieSlice.prototype.render = function render(context, instance, key) {
		var _stateMods,
			_this5 = this;

		var segment = instance.segment,
			data = instance.data;

		if (!instance.valid || !data.active) return null;

		var stateMods = ((_stateMods = {
			selected: this.selection.isInstanceSelected(instance),
			disabled: data.disabled,
			selectable: !this.selection.isDummy
		}),
		(_stateMods["color-" + data.colorIndex] = data.colorIndex != null),
		_stateMods);

		var d = createSvgArc(
			segment.ox,
			segment.oy,
			data.r0 * segment.radiusMultiplier,
			data.r * segment.radiusMultiplier,
			segment.startAngle,
			segment.endAngle
		);
		return VDOM.createElement(
			"g",
			{ key: key, className: data.classNames },
			VDOM.createElement("path", {
				className: this.CSS.element(this.baseClass, "slice", stateMods),
				style: data.style,
				d: d,
				onMouseMove: function onMouseMove(e) {
					tooltipMouseMove(e, instance, _this5.tooltip);
				},
				onMouseLeave: function onMouseLeave(e) {
					tooltipMouseLeave(e, instance, _this5.tooltip);
				},
				onClick: function onClick(e) {
					_this5.handleClick(e, instance);
				}
			}),
			this.renderChildren(context, instance)
		);
	};

	PieSlice.prototype.handleClick = function handleClick(e, instance) {
		if (!this.selection.isDummy) {
			this.selection.selectInstance(instance);
			e.stopPropagation();
			e.preventDefault();
		}
	};

	return PieSlice;
})(PureContainer);

PieSlice.prototype.offset = 0;
PieSlice.prototype.r0 = 0;
PieSlice.prototype.r = 50;
PieSlice.prototype.percentageRadius = true;
PieSlice.prototype.baseClass = "pieslice";
PieSlice.prototype.legend = "legend";
PieSlice.prototype.active = true;
PieSlice.prototype.stack = "stack";
PieSlice.prototype.legendAction = "auto";
PieSlice.prototype.styled = true;

Widget.alias("pie-chart", PieChart);

debug("The Pie class is deprecated. Please use PieChart instead.");

var Pie = PieChart;
Pie.Slice = PieSlice;

var ColumnBarBase = (function(_PureContainer) {
	inherits(ColumnBarBase, _PureContainer);

	function ColumnBarBase() {
		classCallCheck(this, ColumnBarBase);
		return possibleConstructorReturn(this, _PureContainer.apply(this, arguments));
	}

	ColumnBarBase.prototype.init = function init() {
		this.selection = Selection.create(this.selection);
		_PureContainer.prototype.init.call(this);
	};

	ColumnBarBase.prototype.declareData = function declareData() {
		var _PureContainer$protot;

		var selection = this.selection.configureWidget(this);

		return (_PureContainer$protot = _PureContainer.prototype.declareData).call.apply(
			_PureContainer$protot,
			[this].concat(Array.prototype.slice.call(arguments), [
				selection,
				{
					x: undefined,
					y: undefined,
					style: { structured: true },
					class: { structured: true },
					className: { structured: true },
					disabled: undefined,
					colorIndex: undefined,
					colorMap: undefined,
					colorName: undefined,
					name: undefined,
					active: true,
					stacked: undefined,
					stack: undefined,
					offset: undefined
				}
			])
		);
	};

	ColumnBarBase.prototype.prepareData = function prepareData(context, instance) {
		instance.axes = context.axes;
		instance.xAxis = context.axes[this.xAxis];
		instance.yAxis = context.axes[this.yAxis];
		var data = instance.data;

		data.valid = this.checkValid(data);
		if (!data.colorName && data.name) data.colorName = data.name;
		_PureContainer.prototype.prepareData.call(this, context, instance);
	};

	ColumnBarBase.prototype.checkValid = function checkValid(data) {
		return true;
	};

	ColumnBarBase.prototype.prepare = function prepare(context, instance) {
		var _this2 = this;

		var data = instance.data,
			colorMap = instance.colorMap;

		if (colorMap && data.colorName) {
			data.colorIndex = colorMap.map(data.colorName);
			if (instance.cache("colorIndex", data.colorIndex)) instance.markShouldUpdate(context);
		}

		if (!data.valid) return;

		if (data.active) {
			instance.bounds = this.calculateRect(instance);
			instance.cache("bounds", instance.bounds);
			if (!instance.bounds.isEqual(instance.cached.bounds)) instance.markShouldUpdate(context);

			context.push("parentRect", instance.bounds);
			if (instance.xAxis.shouldUpdate || instance.yAxis.shouldUpdate) instance.markShouldUpdate(context);
		}

		if (data.name && context.addLegendEntry)
			context.addLegendEntry(this.legend, {
				name: data.name,
				active: data.active,
				colorIndex: data.colorIndex,
				disabled: data.disabled,
				selected: this.selection.isInstanceSelected(instance),
				style: data.style,
				shape: this.legendShape,
				onClick: function onClick(e) {
					_this2.onLegendClick(e, instance);
				}
			});
	};

	ColumnBarBase.prototype.prepareCleanup = function prepareCleanup(context, instance) {
		var data = instance.data;

		if (data.valid && data.active) context.pop("parentRect");
	};

	ColumnBarBase.prototype.onLegendClick = function onLegendClick(e, instance) {
		var allActions = this.legendAction == "auto";
		var data = instance.data;

		if (allActions || this.legendAction == "toggle") if (instance.set("active", !data.active)) return;

		if (allActions || this.legendAction == "select") this.handleClick(e, instance);
	};

	ColumnBarBase.prototype.calculateRect = function calculateRect(context, instance) {
		throw new Error("Abstract method.");
	};

	ColumnBarBase.prototype.render = function render(context, instance, key) {
		var _stateMods,
			_this3 = this;

		var data = instance.data,
			bounds = instance.bounds;

		if (!data.active || !data.valid) return null;

		var stateMods = ((_stateMods = {
			selected: this.selection.isInstanceSelected(instance),
			disabled: data.disabled,
			selectable: !this.selection.isDummy
		}),
		(_stateMods["color-" + data.colorIndex] = data.colorIndex != null),
		_stateMods);

		return VDOM.createElement(
			"g",
			{ className: data.classNames, key: key },
			VDOM.createElement("rect", {
				className: this.CSS.element(this.baseClass, "rect", stateMods),
				style: data.style,
				x: bounds.l,
				y: bounds.t,
				width: Math.max(0.0001, bounds.width()),
				height: Math.max(0.0001, bounds.height()),
				onMouseMove: function onMouseMove(e) {
					tooltipMouseMove(e, instance, _this3.tooltip);
				},
				onMouseLeave: function onMouseLeave(e) {
					tooltipMouseLeave(e, instance, _this3.tooltip);
				},
				onClick: function onClick(e) {
					_this3.handleClick(e, instance);
				}
			}),
			this.renderChildren(context, instance)
		);
	};

	ColumnBarBase.prototype.handleClick = function handleClick(e, instance) {
		if (!this.selection.isDummy) {
			this.selection.selectInstance(instance);
			e.stopPropagation();
			e.preventDefault();
		}
	};

	return ColumnBarBase;
})(PureContainer);

ColumnBarBase.prototype.xAxis = "x";
ColumnBarBase.prototype.yAxis = "y";
ColumnBarBase.prototype.offset = 0;
ColumnBarBase.prototype.legend = "legend";
ColumnBarBase.prototype.legendAction = "auto";
ColumnBarBase.prototype.active = true;
ColumnBarBase.prototype.stacked = false;
ColumnBarBase.prototype.stack = "stack";
ColumnBarBase.prototype.legendShape = "rect";
ColumnBarBase.prototype.styled = true;

var Column = (function(_ColumnBarBase) {
	inherits(Column, _ColumnBarBase);

	function Column() {
		classCallCheck(this, Column);
		return possibleConstructorReturn(this, _ColumnBarBase.apply(this, arguments));
	}

	Column.prototype.init = function init() {
		if (isDefined(this.width)) this.size = this.width;

		_ColumnBarBase.prototype.init.call(this);
	};

	Column.prototype.declareData = function declareData() {
		var _ColumnBarBase$protot;

		return (_ColumnBarBase$protot = _ColumnBarBase.prototype.declareData).call.apply(
			_ColumnBarBase$protot,
			[this].concat(Array.prototype.slice.call(arguments), [
				{
					y0: undefined,
					size: undefined,
					autoSize: undefined
				}
			])
		);
	};

	Column.prototype.checkValid = function checkValid(data) {
		return data.x != null && data.y != null && data.y0 != null;
	};

	Column.prototype.explore = function explore(context, instance) {
		var data = instance.data,
			xAxis = instance.xAxis,
			yAxis = instance.yAxis;

		instance.colorMap = data.colorMap && context.getColorMap && context.getColorMap(data.colorMap);
		if (instance.colorMap && data.colorName) instance.colorMap.acknowledge(data.colorName);

		if (!data.valid) return;

		if (data.active) {
			xAxis.acknowledge(data.x, data.size, data.offset);

			if (data.autoSize) xAxis.book(data.x, data.stacked ? data.stack : data.name);

			if (data.stacked) {
				yAxis.stacknowledge(data.stack, data.x, data.y0);
				yAxis.stacknowledge(data.stack, data.x, data.y);
			} else {
				if (!this.hiddenBase) yAxis.acknowledge(data.y0);
				yAxis.acknowledge(data.y);
			}
			_ColumnBarBase.prototype.explore.call(this, context, instance);
		}
	};

	Column.prototype.calculateRect = function calculateRect(instance) {
		var data = instance.data;
		var offset = data.offset,
			size = data.size;

		if (data.autoSize) {
			var _instance$xAxis$locat = instance.xAxis.locate(data.x, data.stacked ? data.stack : data.name),
				index = _instance$xAxis$locat[0],
				count = _instance$xAxis$locat[1];

			offset = size / count * (index - count / 2 + 0.5);
			size = size / count;
		}

		var x1 = instance.xAxis.map(data.x, offset - size / 2);
		var x2 = instance.xAxis.map(data.x, offset + size / 2);
		var y1 = data.stacked ? instance.yAxis.stack(data.stack, data.x, data.y0) : instance.yAxis.map(data.y0);
		var y2 = data.stacked ? instance.yAxis.stack(data.stack, data.x, data.y) : instance.yAxis.map(data.y);

		var bounds = new Rect({
			l: Math.min(x1, x2),
			r: Math.max(x1, x2),
			t: Math.min(y1, y2),
			b: Math.max(y1, y2)
		});

		return bounds;
	};

	return Column;
})(ColumnBarBase);

Column.prototype.baseClass = "column";
Column.prototype.y0 = 0;
Column.prototype.size = 1;
Column.prototype.autoSize = false;
Column.prototype.legendShape = "column";
Column.prototype.hiddenBase = false;

Widget.alias("column", Column);

var Bar = (function(_ColumnBarBase) {
	inherits(Bar, _ColumnBarBase);

	function Bar() {
		classCallCheck(this, Bar);
		return possibleConstructorReturn(this, _ColumnBarBase.apply(this, arguments));
	}

	Bar.prototype.init = function init() {
		if (isDefined(this.height)) this.size = this.height;

		_ColumnBarBase.prototype.init.call(this);
	};

	Bar.prototype.declareData = function declareData() {
		var _ColumnBarBase$protot;

		return (_ColumnBarBase$protot = _ColumnBarBase.prototype.declareData).call.apply(
			_ColumnBarBase$protot,
			[this].concat(Array.prototype.slice.call(arguments), [
				{
					x0: undefined,
					size: undefined,
					autoSize: undefined
				}
			])
		);
	};

	Bar.prototype.checkValid = function checkValid(data) {
		return data.y != null && data.x != null && data.x0 != null;
	};

	Bar.prototype.explore = function explore(context, instance) {
		var data = instance.data,
			xAxis = instance.xAxis,
			yAxis = instance.yAxis;

		instance.colorMap = data.colorMap && context.getColorMap && context.getColorMap(data.colorMap);
		if (instance.colorMap && data.colorName) instance.colorMap.acknowledge(data.colorName);

		if (!data.valid) return;

		if (data.active) {
			yAxis.acknowledge(data.y, data.size, data.offset);

			if (data.autoSize) yAxis.book(data.y, data.stacked ? data.stack : data.name);

			if (data.stacked) {
				xAxis.stacknowledge(data.stack, data.y, data.x0);
				xAxis.stacknowledge(data.stack, data.y, data.x);
			} else {
				if (!this.hiddenBase) xAxis.acknowledge(data.x0);
				xAxis.acknowledge(data.x);
			}
			_ColumnBarBase.prototype.explore.call(this, context, instance);
		}
	};

	Bar.prototype.calculateRect = function calculateRect(instance) {
		var data = instance.data;
		var offset = data.offset,
			size = data.size;

		if (data.autoSize) {
			var _instance$yAxis$locat = instance.yAxis.locate(data.y, data.stacked ? data.stack : data.name),
				index = _instance$yAxis$locat[0],
				count = _instance$yAxis$locat[1];

			offset = size / count * (index - count / 2 + 0.5);
			size = size / count;
		}

		var x1 = data.stacked ? instance.xAxis.stack(data.stack, data.y, data.x0) : instance.xAxis.map(data.x0);
		var x2 = data.stacked ? instance.xAxis.stack(data.stack, data.y, data.x) : instance.xAxis.map(data.x);
		var y1 = instance.yAxis.map(data.y, offset - size / 2);
		var y2 = instance.yAxis.map(data.y, offset + size / 2);

		var bounds = new Rect({
			l: Math.min(x1, x2),
			r: Math.max(x1, x2),
			t: Math.min(y1, y2),
			b: Math.max(y1, y2)
		});

		return bounds;
	};

	return Bar;
})(ColumnBarBase);

Bar.prototype.baseClass = "bar";
Bar.prototype.x0 = 0;
Bar.prototype.size = 1;
Bar.prototype.autoSize = false;
Bar.prototype.legendShape = "bar";
Bar.prototype.hiddenBase = false;

Widget.alias("bar", Bar);

var shapes = {};
var warnings = {};

function registerShape(name, callback) {
	shapes[name] = callback;
}

function getShape(shapeName) {
	if (shapes[shapeName]) return shapes[shapeName];

	if (!warnings[shapeName]) {
		warnings[shapeName] = true;
		debug("Unknown shape '" + shapeName + "'. Using square instead.");
	}

	return shapes["square"];
}

function getAvailableShapes() {
	return Object.keys(shapes);
}

function circle(cx, cy, size, props, options) {
	return VDOM.createElement("circle", _extends({}, props, { cx: cx, cy: cy, r: size / 2 }));
}
registerShape("circle", circle);

function square(cx, cy, size, props, options) {
	size *= 0.9;
	return VDOM.createElement(
		"rect",
		_extends({}, props, { x: cx - size / 2, y: cy - size / 2, width: size, height: size })
	);
}
registerShape("square", square);
registerShape("rect", square);

function bar(cx, cy, size, props, options) {
	size *= 0.9;
	return VDOM.createElement(
		"rect",
		_extends({}, props, { x: cx - size / 2, y: cy - size / 4, width: size, height: size / 2 })
	);
}
registerShape("bar", bar);

function column(cx, cy, size, props, options) {
	size *= 0.9;
	return VDOM.createElement(
		"rect",
		_extends({}, props, { x: cx - size / 4, y: cy - size / 2, width: size / 2, height: size })
	);
}
registerShape("column", column);

function line(cx, cy, size, props, options) {
	size *= 0.9;
	return VDOM.createElement("line", _extends({}, props, { x1: cx - size / 2, y1: cy, x2: cx + size / 2, y2: cy }));
}
registerShape("line", line);
registerShape("hline", line);

function vline(cx, cy, size, props, options) {
	size *= 0.9;
	return VDOM.createElement("line", _extends({}, props, { x1: cx, y1: cy - size / 2, x2: cx, y2: cy + size / 2 }));
}
registerShape("vline", vline);

function triangle(cx, cy, size, props, options) {
	size *= 1.29;
	var d = "";
	var cos = Math.cos(Math.PI / 6);
	var sin = Math.sin(Math.PI / 6);
	d += "M " + cx + " " + (cy - size / 2) + " ";
	d += "L " + (cx + cos * size / 2) + " " + (cy + sin * size / 2) + " ";
	d += "L " + (cx - cos * size / 2) + " " + (cy + sin * size / 2) + " ";
	d += "Z";
	return VDOM.createElement("path", _extends({}, props, { d: d }));
}

registerShape("triangle", triangle);

var Legend = (function(_HtmlElement) {
	inherits(Legend, _HtmlElement);

	function Legend() {
		classCallCheck(this, Legend);
		return possibleConstructorReturn(this, _HtmlElement.apply(this, arguments));
	}

	Legend.prototype.prepareData = function prepareData(context, instance) {
		var data = instance.data;

		data.stateMods = Object.assign(data.stateMods || {}, {
			vertical: this.vertical
		});
		_HtmlElement.prototype.prepareData.call(this, context, instance);
	};

	Legend.prototype.explore = function explore(context, instance) {
		if (!context.legends) context.legends = {};

		instance.legends = context.legends;

		context.addLegendEntry = function(legendName, entry) {
			//case when all legends are scoped and new entry is added outside the scope
			if (!context.legends) return;

			var legend = context.legends[legendName];
			if (!legend)
				legend = context.legends[legendName] = {
					entries: [],
					names: {}
				};

			if (!legend.names[entry.name]) {
				legend.entries.push(entry);
				legend.names[entry.name] = entry;
			}
		};

		_HtmlElement.prototype.explore.call(this, context, instance);
	};

	Legend.prototype.renderChildren = function renderChildren(context, instance) {
		var _this2 = this;

		var CSS$$1 = this.CSS;

		var entries = instance.legends[this.name] && instance.legends[this.name].entries,
			list;

		if (isArray(entries) && entries.length > 0) {
			list = VDOM.createElement(
				"div",
				{ key: "wrap", className: CSS$$1.element(this.baseClass, "wrap") },
				entries.map(function(e, i) {
					return VDOM.createElement(
						"div",
						{
							key: i,
							className: CSS$$1.element(_this2.baseClass, "entry"),
							onClick: e.onClick
						},
						_this2.renderShape(e),
						e.name
					);
				})
			);
		}

		return [list, _HtmlElement.prototype.renderChildren.call(this, context, instance)];
	};

	Legend.prototype.renderShape = function renderShape(entry) {
		var _CSS$element;

		var className = this.CSS.element(
			this.baseClass,
			"shape",
			((_CSS$element = {
				disabled: entry.disabled,
				selected: entry.selected
			}),
			(_CSS$element["color-" + entry.colorIndex] =
				entry.colorIndex != null && (isUndefined(entry.active) || entry.active)),
			_CSS$element)
		);
		var shape = getShape(entry.shape || "square");

		return VDOM.createElement(
			"svg",
			{ className: this.CSS.element(this.baseClass, "svg") },
			shape(10, 10, 18, {
				style: entry.style,
				className: className
			})
		);
	};

	return Legend;
})(HtmlElement);

Legend.prototype.name = "legend";
Legend.prototype.baseClass = "legend";
Legend.prototype.vertical = false;
Legend.prototype.memoize = false;

Widget.alias("legend", Legend);

Legend.Scope = (function(_PureContainer) {
	inherits(_class, _PureContainer);

	function _class() {
		classCallCheck(this, _class);
		return possibleConstructorReturn(this, _PureContainer.apply(this, arguments));
	}

	_class.prototype.explore = function explore(context, instance) {
		context.push("legends", (instance.legends = {}));
		_PureContainer.prototype.explore.call(this, context, instance);
	};

	_class.prototype.exploreCleanup = function exploreCleanup(context, instance) {
		context.pop("legends");
	};

	_class.prototype.prepare = function prepare(context, instance) {
		context.push("legends", instance.legends);
	};

	_class.prototype.prepareCleanup = function prepareCleanup(context, instance) {
		context.pop("legends");
	};

	return _class;
})(PureContainer);

var LegendEntry = (function(_HtmlElement) {
	inherits(LegendEntry, _HtmlElement);

	function LegendEntry() {
		classCallCheck(this, LegendEntry);
		return possibleConstructorReturn(this, _HtmlElement.apply(this, arguments));
	}

	LegendEntry.prototype.init = function init() {
		this.selection = Selection.create(this.selection);
		_HtmlElement.prototype.init.call(this);
	};

	LegendEntry.prototype.declareData = function declareData() {
		var _HtmlElement$prototyp;

		var selection = this.selection.configureWidget(this);

		(_HtmlElement$prototyp = _HtmlElement.prototype.declareData).call.apply(
			_HtmlElement$prototyp,
			[this].concat(Array.prototype.slice.call(arguments), [
				selection,
				{
					selected: undefined,
					shape: undefined,
					colorIndex: undefined,
					colorMap: undefined,
					colorName: undefined,
					name: undefined,
					active: true,
					size: undefined
				}
			])
		);
	};

	LegendEntry.prototype.prepareData = function prepareData(context, instance) {
		var data = instance.data;

		if (data.name && !data.colorName) data.colorName = data.name;

		_HtmlElement.prototype.prepareData.call(this, context, instance);
	};

	LegendEntry.prototype.explore = function explore(context, instance) {
		var data = instance.data;

		instance.colorMap = data.colorMap && context.getColorMap && context.getColorMap(data.colorMap);
		if (instance.colorMap && data.colorName) instance.colorMap.acknowledge(data.colorName);
		_HtmlElement.prototype.explore.call(this, context, instance);
	};

	LegendEntry.prototype.prepare = function prepare(context, instance) {
		var data = instance.data,
			colorMap = instance.colorMap;

		if (colorMap && data.colorName) {
			data.colorIndex = colorMap.map(data.colorName);
			if (instance.cache("colorIndex", data.colorIndex)) instance.markShouldUpdate(context);
		}
	};

	LegendEntry.prototype.attachProps = function attachProps(context, instance, props) {
		var _this2 = this;

		var shape = this.renderShape(instance);
		props.children = [shape, props.children];
		props.onMouseDown = stopPropagation;
		props.onClick = function(e) {
			_this2.handleClick(e, instance);
		};

		delete props.active;
		delete props.selection;
		delete props.colorMap;
		delete props.colorIndex;
		delete props.shape;
		delete props.name;
		delete props.selected;
	};

	LegendEntry.prototype.handleClick = function handleClick(e, instance) {
		if (this.onClick && instance.invoke("onClick", e, instance) === false) return;

		e.stopPropagation();

		var any = this.legendAction == "auto";

		if (any || this.legendAction == "toggle") if (instance.set("active", !instance.data.active)) return;

		if ((any || this.legendAction == "select") && !this.selection.isDummy) this.selection.selectInstance(instance);
	};

	LegendEntry.prototype.renderShape = function renderShape(instance) {
		var _CSS$element;

		var entry = instance.data;
		var className = this.CSS.element(
			this.baseClass,
			"shape",
			((_CSS$element = {
				disabled: entry.disabled,
				selected: entry.selected || this.selection.isInstanceSelected(instance)
			}),
			(_CSS$element["color-" + entry.colorIndex] =
				entry.colorIndex != null && (isUndefined(entry.active) || entry.active)),
			_CSS$element)
		);
		var shape = getShape(entry.shape || "square");

		return VDOM.createElement(
			"svg",
			{ key: "svg", className: this.CSS.element(this.baseClass, "svg") },
			shape(10, 10, entry.size, {
				style: entry.style,
				className: className
			})
		);
	};

	return LegendEntry;
})(HtmlElement);

LegendEntry.prototype.baseClass = "legendentry";
LegendEntry.prototype.shape = "square";
LegendEntry.prototype.legendAction = "auto";
LegendEntry.prototype.size = 18;

Widget.alias("legend-entry", LegendEntry);

var ColorMap = (function(_Widget) {
	inherits(ColorMap, _Widget);

	function ColorMap() {
		classCallCheck(this, ColorMap);
		return possibleConstructorReturn(this, _Widget.apply(this, arguments));
	}

	ColorMap.prototype.declareData = function declareData() {
		var _Widget$prototype$dec;

		(_Widget$prototype$dec = _Widget.prototype.declareData).call.apply(
			_Widget$prototype$dec,
			[this].concat(Array.prototype.slice.call(arguments), [
				{
					names: undefined
				}
			])
		);
	};

	ColorMap.prototype.explore = function explore(context, instance) {
		var _this2 = this;

		if (!context.colorMaps) context.colorMaps = {};

		context.getColorMap = function(colorMap) {
			var map = context.colorMaps[colorMap];
			if (!map) {
				var cache = _this2.onGetCache ? instance.invoke("onGetCache") : {};
				map = cache[colorMap];
				if (!map) map = context.colorMaps[colorMap] = cache[colorMap] = new ColorIndex();
				if (Array.isArray(instance.data.names))
					instance.data.names.forEach(function(name) {
						return map.acknowledge(name);
					});
			}
			return map;
		};
	};

	ColorMap.prototype.render = function render() {
		return null;
	};

	return ColorMap;
})(Widget);

var ColorMapScope = (function(_PureContainer) {
	inherits(ColorMapScope, _PureContainer);

	function ColorMapScope() {
		classCallCheck(this, ColorMapScope);
		return possibleConstructorReturn(this, _PureContainer.apply(this, arguments));
	}

	ColorMapScope.prototype.explore = function explore(context, instance) {
		context.push("colorMaps", (instance.colorMaps = {}));
		_PureContainer.prototype.explore.call(this, context, instance);
	};

	ColorMapScope.prototype.exploreCleanup = function exploreCleanup(context, instance) {
		context.pop("colorMaps");
	};

	ColorMapScope.prototype.prepare = function prepare(context, instance) {
		context.push("colorMaps", instance.colorMaps);
	};

	ColorMapScope.prototype.prepareCleanup = function prepareCleanup(context, instance) {
		context.pop("colorMaps");
	};

	return ColorMapScope;
})(PureContainer);

ColorMap.Scope = ColorMapScope;
Widget.alias("color-map", ColorMap);

var ColorIndex = (function() {
	function ColorIndex() {
		classCallCheck(this, ColorIndex);

		this.colorMap = {};
		this.dirty = true;
	}

	ColorIndex.prototype.acknowledge = function acknowledge(name) {
		if (!(name in this.colorMap)) {
			this.colorMap[name] = Object.keys(this.colorMap).length;
			this.dirty = true;
		}
	};

	ColorIndex.prototype.map = function map(name) {
		if (this.dirty) {
			this.dirty = false;

			var n = Object.keys(this.colorMap).length;
			this.dist = n > 0 ? 16 / n : 1;
			this.offset = 0;
		}

		var index = this.colorMap[name];

		return Math.round(this.offset + this.dist * index) % 16;
	};

	return ColorIndex;
})();

var Marker = (function(_BoundedObject) {
	inherits(Marker, _BoundedObject);

	function Marker() {
		classCallCheck(this, Marker);
		return possibleConstructorReturn(this, _BoundedObject.apply(this, arguments));
	}

	Marker.prototype.init = function init() {
		this.selection = Selection.create(this.selection);

		if (this.draggable) {
			this.draggableX = true;
			this.draggableY = true;
		}

		if (this.constrain) {
			this.constrainX = true;
			this.constrainY = true;
		}

		_BoundedObject.prototype.init.call(this);
	};

	Marker.prototype.declareData = function declareData() {
		var _BoundedObject$protot;

		var selection = this.selection.configureWidget(this);

		return (_BoundedObject$protot = _BoundedObject.prototype.declareData).call.apply(
			_BoundedObject$protot,
			[this].concat(Array.prototype.slice.call(arguments), [
				selection,
				{
					x: undefined,
					y: undefined,
					size: undefined,
					shape: undefined,
					disabled: undefined,
					colorMap: undefined,
					colorIndex: undefined,
					colorName: undefined,
					legendColorIndex: undefined,
					name: undefined,
					active: true
				}
			])
		);
	};

	Marker.prototype.prepareData = function prepareData(context, instance) {
		instance.axes = context.axes;
		instance.xAxis = context.axes[this.xAxis];
		instance.yAxis = context.axes[this.yAxis];
		var data = instance.data;

		data.selected = this.selection.isInstanceSelected(instance);
		data.stateMods = {
			selected: data.selected,
			disabled: data.disabled,
			selectable: !this.selection.isDummy,
			"draggable-x": this.draggableX && !this.draggableY,
			"draggable-y": this.draggableY && !this.draggableX,
			"draggable-xy": this.draggableY && this.draggableX
		};
		if (data.name && !data.colorName) data.colorName = data.name;
		_BoundedObject.prototype.prepareData.call(this, context, instance);
	};

	Marker.prototype.calculateBounds = function calculateBounds(context, instance) {
		var data = instance.data,
			xAxis = instance.xAxis,
			yAxis = instance.yAxis;

		var x = void 0,
			y = void 0;

		if (data.x == null || data.y == null) {
			var bounds = _BoundedObject.prototype.calculateBounds.call(this, context, instance);
			x = (bounds.l + bounds.r) / 2;
			y = (bounds.t + bounds.b) / 2;
		}

		if (data.x != null) x = xAxis.map(data.x);

		if (data.y != null) y = yAxis.map(data.y);

		return new Rect({
			l: x - data.size / 2,
			r: x + data.size / 2,
			t: y - data.size / 2,
			b: y + data.size / 2
		});
	};

	Marker.prototype.explore = function explore(context, instance) {
		var data = instance.data,
			xAxis = instance.xAxis,
			yAxis = instance.yAxis;

		instance.colorMap = data.colorMap && context.getColorMap && context.getColorMap(data.colorMap);
		if (instance.colorMap && data.colorName) instance.colorMap.acknowledge(data.colorName);

		if (data.active) {
			if (xAxis && data.x != null) xAxis.acknowledge(data.x, 0, this.xOffset);

			if (yAxis && data.y != null) yAxis.acknowledge(data.y, 0, this.yOffset);

			if (context.pointReducer) context.pointReducer(data.x, data.y, data.name, data);

			_BoundedObject.prototype.explore.call(this, context, instance);
		}
	};

	Marker.prototype.prepare = function prepare(context, instance) {
		var _this2 = this;

		var data = instance.data,
			xAxis = instance.xAxis,
			yAxis = instance.yAxis,
			colorMap = instance.colorMap;

		if (colorMap && data.colorName) {
			data.colorIndex = colorMap.map(data.colorName);
			if (instance.cache("colorIndex", data.colorIndex)) instance.markShouldUpdate(context);
		}

		if (data.active) {
			if (xAxis && xAxis.shouldUpdate) instance.markShouldUpdate(context);

			if (yAxis && yAxis.shouldUpdate) instance.markShouldUpdate(context);

			_BoundedObject.prototype.prepare.call(this, context, instance);
		}

		if (data.name && context.addLegendEntry)
			context.addLegendEntry(this.legend, {
				name: data.name,
				active: data.active,
				colorIndex: data.legendColorIndex || data.colorIndex,
				disabled: data.disabled,
				selected: data.selected,
				style: data.style,
				shape: data.shape,
				onClick: function onClick(e) {
					_this2.onLegendClick(e, instance);
				}
			});
	};

	Marker.prototype.onLegendClick = function onLegendClick(e, instance) {
		var allActions = this.legendAction == "auto";
		var data = instance.data;

		if (allActions || this.legendAction == "toggle") if (instance.set("active", !data.active)) return;

		if (allActions || this.legendAction == "select") this.handleClick(e, instance);
	};

	Marker.prototype.render = function render(context, instance, key) {
		var data = instance.data;

		if (!data.active || data.x === null || data.y === null) return null;

		return VDOM.createElement(
			MarkerComponent,
			{
				key: key,
				instance: instance,
				data: instance.data,
				shouldUpdate: instance.shouldUpdate
			},
			this.renderChildren(context, instance)
		);
	};

	Marker.prototype.handleMouseDown = function handleMouseDown(e, instance) {
		var _this3 = this;

		if (this.draggableX || this.draggableY) {
			var svgEl = closest(e.target, function(el) {
				return el.tagName == "svg";
			});
			if (svgEl)
				captureMouseOrTouch(
					e,
					function(e, captureData) {
						_this3.handleDragMove(e, instance, captureData);
					},
					null,
					{ svgEl: svgEl, el: e.target },
					e.target.style.cursor
				);
		} else {
			if (!this.selection.isDummy) this.selection.selectInstance(instance);
		}
	};

	Marker.prototype.handleClick = function handleClick(e, instance) {
		if (this.onClick) instance.invoke("onClick", e, instance);
	};

	Marker.prototype.handleDragMove = function handleDragMove(e, instance, captureData) {
		var cursor = getCursorPos(e);
		var svgBounds = captureData.svgEl.getBoundingClientRect();
		var xAxis = instance.xAxis,
			yAxis = instance.yAxis;

		if (this.draggableX && xAxis) {
			var x = xAxis.trackValue(cursor.clientX - svgBounds.left, this.xOffset);
			if (this.constrainX) x = xAxis.constrainValue(x);
			instance.set("x", xAxis.encodeValue(x));
		}
		if (this.draggableY && yAxis) {
			var y = yAxis.trackValue(cursor.clientY - svgBounds.top, this.yOffset);
			if (this.constrainY) y = yAxis.constrainValue(y);
			instance.set("y", yAxis.encodeValue(y));
		}
		tooltipMouseMove(e, instance, this.tooltip, { target: captureData.el });
	};

	return Marker;
})(BoundedObject);

Marker.prototype.xOffset = 0;
Marker.prototype.yOffset = 0;
Marker.prototype.size = 5;
Marker.prototype.anchors = "0.5 0.5 0.5 0.5";

Marker.prototype.xAxis = "x";
Marker.prototype.yAxis = "y";

Marker.prototype.baseClass = "marker";
Marker.prototype.draggableX = false;
Marker.prototype.draggableY = false;
Marker.prototype.draggable = false;
Marker.prototype.constrainX = false;
Marker.prototype.constrainY = false;
Marker.prototype.constrain = false;
Marker.prototype.legend = "legend";
Marker.prototype.legendAction = "auto";
Marker.prototype.shape = "circle";
Marker.prototype.styled = true;

BoundedObject.alias("marker", Marker);

var MarkerComponent = (function(_VDOM$Component) {
	inherits(MarkerComponent, _VDOM$Component);

	function MarkerComponent() {
		classCallCheck(this, MarkerComponent);
		return possibleConstructorReturn(this, _VDOM$Component.apply(this, arguments));
	}

	MarkerComponent.prototype.shouldComponentUpdate = function shouldComponentUpdate(props) {
		return props.shouldUpdate;
	};

	MarkerComponent.prototype.render = function render() {
		var _CSS$element,
			_this5 = this;

		var _props = this.props,
			instance = _props.instance,
			children = _props.children,
			data = _props.data;
		var widget = instance.widget;
		var CSS$$1 = widget.CSS,
			baseClass = widget.baseClass;
		var bounds = data.bounds,
			shape = data.shape;

		var shapeRenderer = getShape(shape);
		var shapeProps = {
			className: CSS$$1.element(
				baseClass,
				"shape",
				((_CSS$element = {}),
				(_CSS$element["color-" + data.colorIndex] = data.colorIndex != null),
				(_CSS$element.selected = data.selected),
				_CSS$element)
			),
			style: data.style,
			cx: (bounds.l + bounds.r) / 2,
			cy: (bounds.t + bounds.b) / 2,
			r: data.size / 2,
			onMouseMove: function onMouseMove(e) {
				tooltipMouseMove(e, instance, widget.tooltip);
			},
			onMouseLeave: function onMouseLeave(e) {
				tooltipMouseLeave(e, instance, widget.tooltip);
			},
			onMouseDown: function onMouseDown(e) {
				widget.handleMouseDown(e, instance);
			},
			onTouchStart: function onTouchStart(e) {
				widget.handleMouseDown(e, instance);
			},
			onClick: function onClick(e) {
				widget.handleClick(e, instance);
			}
		};
		if (widget.tooltip) {
			shapeProps.ref = function(c) {
				_this5.el = c;
			};
		}

		return VDOM.createElement(
			"g",
			{ className: data.classNames },
			shapeRenderer((bounds.l + bounds.r) / 2, (bounds.t + bounds.b) / 2, data.size, shapeProps),
			children
		);
	};

	MarkerComponent.prototype.componentWillUnmount = function componentWillUnmount() {
		tooltipParentWillUnmount(this.props.instance);
	};

	MarkerComponent.prototype.componentWillReceiveProps = function componentWillReceiveProps(props) {
		tooltipParentWillReceiveProps(this.el, props.instance, props.instance.widget.tooltip);
	};

	MarkerComponent.prototype.componentDidMount = function componentDidMount() {
		tooltipParentDidMount(this.el, this.props.instance, this.props.instance.widget.tooltip);
	};

	return MarkerComponent;
})(VDOM.Component);

var MarkerLine = (function(_BoundedObject) {
	inherits(MarkerLine, _BoundedObject);

	function MarkerLine() {
		classCallCheck(this, MarkerLine);
		return possibleConstructorReturn(this, _BoundedObject.apply(this, arguments));
	}

	MarkerLine.prototype.init = function init() {
		if (isDefined(this.x)) this.x1 = this.x2 = this.x;

		if (isDefined(this.y)) this.y1 = this.y2 = this.y;

		_BoundedObject.prototype.init.call(this);
	};

	MarkerLine.prototype.declareData = function declareData() {
		var _BoundedObject$protot;

		(_BoundedObject$protot = _BoundedObject.prototype.declareData).call.apply(
			_BoundedObject$protot,
			[this].concat(Array.prototype.slice.call(arguments), [
				{
					x1: undefined,
					y1: undefined,
					x2: undefined,
					y2: undefined,
					colorIndex: undefined,
					active: true,
					name: undefined,
					legend: undefined
				}
			])
		);
	};

	MarkerLine.prototype.explore = function explore(context, instance) {
		var data = instance.data;

		var xAxis = (instance.xAxis = context.axes[this.xAxis]);
		var yAxis = (instance.yAxis = context.axes[this.yAxis]);

		if (data.active) {
			if (data.x1 != null) xAxis.acknowledge(data.x1);

			if (data.x2 != null) xAxis.acknowledge(data.x2);

			if (data.y1 != null) yAxis.acknowledge(data.y1);

			if (data.y2 != null) yAxis.acknowledge(data.y2);

			_BoundedObject.prototype.explore.call(this, context, instance);
		}
	};

	MarkerLine.prototype.prepare = function prepare(context, instance) {
		var _this2 = this;

		var data = instance.data,
			xAxis = instance.xAxis,
			yAxis = instance.yAxis;

		if ((xAxis && xAxis.shouldUpdate) || (yAxis && yAxis.shouldUpdate)) instance.markShouldUpdate(context);

		_BoundedObject.prototype.prepare.call(this, context, instance);

		if (data.name && data.legend && context.addLegendEntry)
			context.addLegendEntry(data.legend, {
				name: data.name,
				active: data.active,
				colorIndex: data.colorIndex,
				style: data.style,
				shape: "line",
				onClick: function onClick(e) {
					_this2.onLegendClick(e, instance);
				}
			});
	};

	MarkerLine.prototype.calculateBounds = function calculateBounds(context, instance) {
		var data = instance.data,
			xAxis = instance.xAxis,
			yAxis = instance.yAxis;

		var bounds = _BoundedObject.prototype.calculateBounds.call(this, context, instance);

		var x1 = bounds.l,
			x2 = bounds.r,
			y1 = bounds.t,
			y2 = bounds.b;

		if (data.x1 != null) x1 = xAxis.map(data.x1);

		if (data.x2 != null) x2 = xAxis.map(data.x2);

		if (data.y1 != null) y1 = yAxis.map(data.y1);

		if (data.y2 != null) y2 = yAxis.map(data.y2);

		bounds.l = Math.min(x1, x2);
		bounds.t = Math.min(y1, y2);
		bounds.r = Math.max(x1, x2);
		bounds.b = Math.max(y1, y2);

		instance.x1 = x1;
		instance.x2 = x2;
		instance.y1 = y1;
		instance.y2 = y2;

		return bounds;
	};

	MarkerLine.prototype.render = function render(context, instance, key) {
		var _stateMods;

		var data = instance.data,
			x1 = instance.x1,
			x2 = instance.x2,
			y1 = instance.y1,
			y2 = instance.y2;

		if (!data.active || data.x1 === null || data.x2 === null || data.y1 === null || data.y2 === null) return null;

		var stateMods = ((_stateMods = {}), (_stateMods["color-" + data.colorIndex] = data.colorIndex != null), _stateMods);

		return VDOM.createElement(
			"g",
			{ key: key, className: data.classNames },
			VDOM.createElement("line", {
				className: this.CSS.element(this.baseClass, "line", stateMods),
				style: data.style,
				x1: x1,
				y1: y1,
				x2: x2,
				y2: y2
			}),
			this.renderChildren(context, instance)
		);
	};

	return MarkerLine;
})(BoundedObject);

MarkerLine.prototype.xAxis = "x";
MarkerLine.prototype.yAxis = "y";
MarkerLine.prototype.anchors = "0 1 1 0";
MarkerLine.prototype.baseClass = "markerline";
MarkerLine.prototype.legend = "legend";
MarkerLine.prototype.legendAction = "auto";

BoundedObject.alias("marker-line", MarkerLine);

var Range = (function(_BoundedObject) {
	inherits(Range, _BoundedObject);

	function Range() {
		classCallCheck(this, Range);
		return possibleConstructorReturn(this, _BoundedObject.apply(this, arguments));
	}

	Range.prototype.declareData = function declareData() {
		var _BoundedObject$protot;

		(_BoundedObject$protot = _BoundedObject.prototype.declareData).call.apply(
			_BoundedObject$protot,
			[this].concat(Array.prototype.slice.call(arguments), [
				{
					x1: undefined,
					y1: undefined,
					x2: undefined,
					y2: undefined,
					colorIndex: undefined,
					active: true,
					name: undefined,
					legend: undefined
				}
			])
		);
	};

	Range.prototype.explore = function explore(context, instance) {
		var data = instance.data;

		var xAxis = (instance.xAxis = context.axes[this.xAxis]);
		var yAxis = (instance.yAxis = context.axes[this.yAxis]);

		if (data.active) {
			if (xAxis) {
				if (data.x1 != null) instance.xAxis.acknowledge(data.x1, this.xSize, this.xOffset);

				if (data.x2 != null) instance.xAxis.acknowledge(data.x2, this.xSize, this.xOffset);
			}

			if (yAxis) {
				if (data.y1 != null) instance.yAxis.acknowledge(data.y1, this.ySize, this.yOffset);

				if (data.y2 != null) instance.yAxis.acknowledge(data.y2, this.ySize, this.yOffset);
			}

			_BoundedObject.prototype.explore.call(this, context, instance);
		}
	};

	Range.prototype.prepare = function prepare(context, instance) {
		var _this2 = this;

		_BoundedObject.prototype.prepare.call(this, context, instance);

		var data = instance.data,
			xAxis = instance.xAxis,
			yAxis = instance.yAxis;

		if (xAxis && xAxis.shouldUpdate) instance.markShouldUpdate(context);

		if (yAxis && yAxis.shouldUpdate) instance.markShouldUpdate(context);

		if (data.name && data.legend && context.addLegendEntry)
			context.addLegendEntry(data.legend, {
				name: data.name,
				active: data.active,
				colorIndex: data.colorIndex,
				style: data.style,
				shape: "rect",
				onClick: function onClick(e) {
					_this2.onLegendClick(e, instance);
				}
			});
	};

	Range.prototype.onLegendClick = function onLegendClick(e, instance) {
		var allActions = this.legendAction == "auto";
		var data = instance.data;

		if (allActions || this.legendAction == "toggle") instance.set("active", !data.active);
	};

	Range.prototype.calculateBounds = function calculateBounds(context, instance) {
		var bounds = _BoundedObject.prototype.calculateBounds.call(this, context, instance);
		var data = instance.data,
			xAxis = instance.xAxis,
			yAxis = instance.yAxis;

		if (data.x1 != null) bounds.l = xAxis.map(data.x1, this.xOffset - this.xSize / 2);

		if (data.x2 != null) bounds.r = xAxis.map(data.x2, this.xOffset + this.xSize / 2);

		if (data.y1 != null) bounds.t = yAxis.map(data.y1, this.yOffset - this.ySize / 2);

		if (data.y2 != null) bounds.b = yAxis.map(data.y2, this.yOffset + this.ySize / 2);

		return bounds;
	};

	Range.prototype.render = function render(context, instance, key) {
		var _stateMods,
			_this3 = this;

		var data = instance.data;

		if (!data.active) return null;

		var bounds = data.bounds;

		var x1 = Math.min(bounds.l, bounds.r),
			y1 = Math.min(bounds.t, bounds.b),
			x2 = Math.max(bounds.l, bounds.r),
			y2 = Math.max(bounds.t, bounds.b);

		var stateMods = ((_stateMods = {}), (_stateMods["color-" + data.colorIndex] = data.colorIndex != null), _stateMods);

		return VDOM.createElement(
			"g",
			{ key: key, className: data.classNames },
			!this.hidden &&
				VDOM.createElement("rect", {
					className: this.CSS.element(this.baseClass, "rect", stateMods),
					style: data.style,
					x: x1,
					y: y1,
					width: x2 - x1,
					height: y2 - y1,
					onMouseDown: function onMouseDown(e) {
						return _this3.handleMouseDown(e, instance);
					},
					onTouchStart: function onTouchStart(e) {
						return _this3.handleMouseDown(e, instance);
					}
				}),
			this.renderChildren(context, instance)
		);
	};

	Range.prototype.handleClick = function handleClick(e, instance) {
		if (this.onClick) instance.invoke("onClick", e, instance);
	};

	Range.prototype.handleMouseDown = function handleMouseDown(e, instance) {
		var _this4 = this;

		if (this.draggableX || this.draggableY) {
			var svgEl = closest(e.target, function(el) {
				return el.tagName == "svg";
			});
			var svgBounds = svgEl.getBoundingClientRect();
			var cursor = getCursorPos(e);
			var data = instance.data,
				xAxis = instance.xAxis,
				yAxis = instance.yAxis;

			var captureData = {
				svgBounds: svgBounds,
				start: {
					x1: data.x1,
					x2: data.x2,
					y1: data.y1,
					y2: data.y2
				}
			};

			if (this.draggableX && xAxis)
				captureData.start.x = xAxis.trackValue(cursor.clientX - svgBounds.left, this.xOffset, this.constrainX);

			if (this.draggableY && yAxis)
				captureData.start.y = yAxis.trackValue(cursor.clientY - svgBounds.top, this.yOffset, this.constrainY);

			if (svgEl)
				captureMouseOrTouch(
					e,
					function(e, captureData) {
						_this4.handleDragMove(e, instance, captureData);
					},
					null,
					captureData,
					e.target.style.cursor
				);
		}
	};

	Range.prototype.handleDragMove = function handleDragMove(e, instance, captureData) {
		var cursor = getCursorPos(e);
		var xAxis = instance.xAxis,
			yAxis = instance.yAxis;
		var svgBounds = captureData.svgBounds,
			start = captureData.start;

		if (this.draggableX && xAxis) {
			var dist = xAxis.trackValue(cursor.clientX - svgBounds.left, this.xOffset, this.constrainX) - captureData.start.x;
			var x1v = xAxis.decodeValue(captureData.start.x1);
			var x2v = xAxis.decodeValue(captureData.start.x2);
			if (this.constrainX) {
				if (dist > 0) dist = Math.min(xAxis.constrainValue(x2v + dist) - x2v, dist);
				else dist = Math.max(xAxis.constrainValue(x1v + dist) - x1v, dist);
			}
			instance.set("x1", xAxis.encodeValue(x1v + dist));
			instance.set("x2", xAxis.encodeValue(x2v + dist));
		}

		if (this.draggableY && yAxis) {
			var dist = yAxis.trackValue(cursor.clientY - svgBounds.left, this.yOffset, this.constrainY) - captureData.start.y;
			var y1v = yAxis.decodeValue(captureData.start.y1);
			var y2v = yAxis.decodeValue(captureData.start.y2);
			if (this.constrainY)
				dist = Math.max(yAxis.constrainValue(y1v + dist) - y1v, Math.min(yAxis.constrainValue(y2v + dist) - y2v, dist));
			instance.set("y1", yAxis.encodeValue(y1v + dist));
			instance.set("y2", yAxis.encodeValue(y2v + dist));
		}
	};

	return Range;
})(BoundedObject);

Range.prototype.invisible = false;
Range.prototype.xAxis = "x";
Range.prototype.yAxis = "y";
Range.prototype.xSize = 0;
Range.prototype.ySize = 0;
Range.prototype.xOffset = 0;
Range.prototype.yOffset = 0;
Range.prototype.anchors = "0 1 1 0";
Range.prototype.baseClass = "range";
Range.prototype.legend = "legend";
Range.prototype.legendAction = "auto";

BoundedObject.alias("range", Range);

var Gridlines = (function(_BoundedObject) {
	inherits(Gridlines, _BoundedObject);

	function Gridlines() {
		classCallCheck(this, Gridlines);
		return possibleConstructorReturn(this, _BoundedObject.apply(this, arguments));
	}

	Gridlines.prototype.explore = function explore(context, instance) {
		_BoundedObject.prototype.explore.call(this, context, instance);
		instance.xAxis = context.axes[this.xAxis];
		instance.yAxis = context.axes[this.yAxis];
	};

	Gridlines.prototype.prepare = function prepare(context, instance) {
		_BoundedObject.prototype.prepare.call(this, context, instance);
		var xAxis = instance.xAxis,
			yAxis = instance.yAxis;

		if ((xAxis && xAxis.shouldUpdate) || (yAxis && yAxis.shouldUpdate)) instance.markShouldUpdate(context);
	};

	Gridlines.prototype.render = function render(context, instance, key) {
		var data = instance.data,
			xAxis = instance.xAxis,
			yAxis = instance.yAxis;
		var bounds = data.bounds;

		var path = "",
			xTicks = void 0,
			yTicks = void 0;

		if (xAxis) {
			xTicks = xAxis.mapGridlines();
			xTicks.forEach(function(x) {
				path += "M " + x + " " + bounds.t + " L " + x + " " + bounds.b;
			});
		}

		if (yAxis) {
			yTicks = yAxis.mapGridlines();
			yTicks.forEach(function(y) {
				path += "M " + bounds.l + " " + y + " L " + bounds.r + " " + y;
			});
		}

		return VDOM.createElement(
			"g",
			{ key: key, className: data.classNames },
			VDOM.createElement("path", { style: data.style, d: path })
		);
	};

	return Gridlines;
})(BoundedObject);

Gridlines.prototype.xAxis = "x";
Gridlines.prototype.yAxis = "y";
Gridlines.prototype.anchors = "0 1 1 0";
Gridlines.prototype.baseClass = "gridlines";

BoundedObject.alias("gridlines", Gridlines);

var LineGraph = (function(_Widget) {
	inherits(LineGraph, _Widget);

	function LineGraph() {
		classCallCheck(this, LineGraph);
		return possibleConstructorReturn(this, _Widget.apply(this, arguments));
	}

	LineGraph.prototype.declareData = function declareData() {
		var _Widget$prototype$dec;

		(_Widget$prototype$dec = _Widget.prototype.declareData).call.apply(
			_Widget$prototype$dec,
			[this].concat(Array.prototype.slice.call(arguments), [
				{
					data: undefined,
					colorIndex: undefined,
					colorMap: undefined,
					class: {
						structured: true
					},
					className: {
						structured: true
					},
					lineStyle: {
						structured: true
					},
					areaStyle: {
						structured: true
					},
					area: undefined,
					line: undefined,
					y0: undefined,
					name: undefined,
					active: true,
					stack: undefined,
					stacked: undefined
				}
			])
		);
	};

	LineGraph.prototype.prepareData = function prepareData(context, instance) {
		var data = instance.data;

		if (data.name && !data.colorName) data.colorName = data.name;

		_Widget.prototype.prepareData.call(this, context, instance);
	};

	LineGraph.prototype.explore = function explore(context, instance) {
		var _this2 = this;

		var data = instance.data;

		instance.colorMap = data.colorMap && context.getColorMap && context.getColorMap(data.colorMap);

		if (instance.colorMap && data.colorName) instance.colorMap.acknowledge(data.colorName);

		if (data.active) {
			instance.axes = context.axes;
			instance.xAxis = instance.axes[this.xAxis];
			instance.yAxis = instance.axes[this.yAxis];
			_Widget.prototype.explore.call(this, context, instance);
			if (isArray(data.data)) {
				data.data.forEach(function(p, index) {
					var x = p[_this2.xField];
					instance.xAxis.acknowledge(x);
					if (data.stacked) {
						instance.yAxis.stacknowledge(data.stack, x, _this2.y0Field ? p[_this2.y0Field] : data.y0);
						instance.yAxis.stacknowledge(data.stack, x, p[_this2.yField]);
					} else {
						instance.yAxis.acknowledge(p[_this2.yField]);
						if (data.area) {
							if (!_this2.hiddenBase) instance.yAxis.acknowledge(_this2.y0Field ? p[_this2.y0Field] : data.y0);
							if (context.pointReducer && _this2.y0Field)
								context.pointReducer(x, p[_this2.y0Field], data.name, p, data, index);
						}
					}
					if (context.pointReducer) context.pointReducer(x, p[_this2.yField], data.name, p, data, index);
				});
			}
		}
	};

	LineGraph.prototype.prepare = function prepare(context, instance) {
		var _this3 = this;

		var data = instance.data,
			colorMap = instance.colorMap;

		if (colorMap && data.colorName) {
			data.colorIndex = colorMap.map(data.colorName);
			if (instance.cache("colorIndex", data.colorIndex)) instance.markShouldUpdate(context);
		}

		if (data.active) {
			if (instance.axes[this.xAxis].shouldUpdate || instance.axes[this.yAxis].shouldUpdate)
				instance.markShouldUpdate(context);
		}

		if (data.name && context.addLegendEntry)
			context.addLegendEntry(this.legend, {
				name: data.name,
				active: data.active,
				colorIndex: data.colorIndex,
				disabled: data.disabled,
				//selected: this.selection.isInstanceSelected(instance),
				style: data.style,
				shape: "rect",
				onClick: function onClick(e) {
					_this3.onLegendClick(e, instance);
				}
			});
	};

	LineGraph.prototype.onLegendClick = function onLegendClick(e, instance) {
		var allActions = this.legendAction == "auto";
		var data = instance.data;

		if (allActions || this.legendAction == "toggle") instance.set("active", !data.active);
	};

	LineGraph.prototype.render = function render(context, instance, key) {
		var _this4 = this,
			_stateMods;

		var data = instance.data,
			xAxis = instance.xAxis,
			yAxis = instance.yAxis;

		if (!data.active) return null;

		var spans = [];
		var span = [];

		isArray(data.data) &&
			data.data.forEach(function(p) {
				var ax = p[_this4.xField],
					ay = p[_this4.yField],
					ay0 = _this4.y0Field ? p[_this4.y0Field] : data.y0,
					x,
					y,
					y0;

				if (ax != null && ay != null && ay0 != null) {
					x = xAxis.map(ax);
					y0 = data.stacked ? yAxis.stack(data.stack, ax, ay0) : yAxis.map(ay0);
					y = data.stacked ? yAxis.stack(data.stack, ax, ay) : yAxis.map(ay);
				}

				if (x != null && y != null && y0 != null) span.push({ x: x, y: y, y0: y0 });
				else if (span.length > 0) {
					spans.push(span);
					span = [];
				}
			});

		if (span.length > 0) spans.push(span);

		var stateMods = ((_stateMods = {}), (_stateMods["color-" + data.colorIndex] = data.colorIndex != null), _stateMods);

		var line, area;

		if (data.line) {
			var linePath = "";
			spans.forEach(function(span) {
				span.forEach(function(p, i) {
					linePath += i == 0 ? " M " : " L ";
					linePath += p.x + " " + p.y;
				});
			});

			line = VDOM.createElement("path", {
				className: this.CSS.element(this.baseClass, "line", stateMods),
				style: this.CSS.parseStyle(data.lineStyle),
				d: linePath
			});
		}

		if (data.area) {
			var areaPath = "";
			spans.forEach(function(span) {
				var closePath = "";
				span.forEach(function(p, i) {
					areaPath += i == 0 ? " M " : " L ";
					areaPath += p.x + " " + p.y;
					if (data.area) closePath = "L " + p.x + " " + p.y0 + " " + closePath;
				});
				areaPath += closePath;
				areaPath += "L " + span[0].x + " " + span[0].y;
			});
			area = VDOM.createElement("path", {
				className: this.CSS.element(this.baseClass, "area", stateMods),
				style: this.CSS.parseStyle(data.areaStyle),
				d: areaPath
			});
		}

		return VDOM.createElement("g", { key: key, className: data.classNames }, line, area);
	};

	return LineGraph;
})(Widget);

LineGraph.prototype.xAxis = "x";
LineGraph.prototype.yAxis = "y";
LineGraph.prototype.area = false;
LineGraph.prototype.line = true;

LineGraph.prototype.xField = "x";
LineGraph.prototype.yField = "y";
LineGraph.prototype.baseClass = "linegraph";
LineGraph.prototype.y0 = 0;
LineGraph.prototype.y0Field = false;
LineGraph.prototype.active = true;
LineGraph.prototype.legend = "legend";
LineGraph.prototype.legendAction = "auto";
LineGraph.prototype.stack = "stack";
LineGraph.prototype.hiddenBase = false;

Widget.alias("line-graph", LineGraph);

var ColumnBarGraphBase = (function(_Widget) {
	inherits(ColumnBarGraphBase, _Widget);

	function ColumnBarGraphBase() {
		classCallCheck(this, ColumnBarGraphBase);
		return possibleConstructorReturn(this, _Widget.apply(this, arguments));
	}

	ColumnBarGraphBase.prototype.init = function init() {
		this.selection = Selection.create(this.selection, {
			records: this.data
		});
		_Widget.prototype.init.call(this);
	};

	ColumnBarGraphBase.prototype.declareData = function declareData() {
		var _Widget$prototype$dec;

		var selection = this.selection.configureWidget(this);

		(_Widget$prototype$dec = _Widget.prototype.declareData).call.apply(
			_Widget$prototype$dec,
			[this, selection].concat(Array.prototype.slice.call(arguments), [
				{
					data: undefined,
					colorIndex: undefined,
					colorMap: undefined,
					colorName: undefined,
					name: undefined,
					size: undefined,
					offset: undefined,
					y0: undefined,
					x0: undefined,
					autoSize: undefined,
					active: true,
					stacked: undefined,
					stack: undefined
				}
			])
		);
	};

	ColumnBarGraphBase.prototype.prepareData = function prepareData(context, instance) {
		var data = instance.data;

		if (data.name && !data.colorName) data.colorName = data.name;

		_Widget.prototype.prepareData.call(this, context, instance);
	};

	ColumnBarGraphBase.prototype.explore = function explore(context, instance) {
		instance.xAxis = context.axes[this.xAxis];
		instance.yAxis = context.axes[this.yAxis];

		var data = instance.data;

		instance.colorMap = data.colorMap && context.getColorMap && context.getColorMap(data.colorMap);
		if (instance.colorMap && data.colorName) instance.colorMap.acknowledge(data.colorName);

		_Widget.prototype.explore.call(this, context, instance);
	};

	ColumnBarGraphBase.prototype.prepare = function prepare(context, instance) {
		var _this2 = this;

		var data = instance.data,
			colorMap = instance.colorMap,
			xAxis = instance.xAxis,
			yAxis = instance.yAxis;

		if (colorMap && data.name) {
			data.colorIndex = colorMap.map(data.colorName);
			if (instance.cache("colorIndex", data.colorIndex)) instance.markShouldUpdate(context);
		}

		if (xAxis.shouldUpdate || yAxis.shouldUpdate) instance.markShouldUpdate(context);

		if (data.name && context.addLegendEntry)
			context.addLegendEntry(this.legend, {
				name: data.name,
				active: data.active,
				colorIndex: data.colorIndex,
				disabled: data.disabled,
				selected: this.selection.isInstanceSelected(instance),
				style: data.style,
				shape: this.legendShape,
				onClick: function onClick(e) {
					_this2.onLegendClick(e, instance);
				}
			});
	};

	ColumnBarGraphBase.prototype.onLegendClick = function onLegendClick(e, instance) {
		var allActions = this.legendAction == "auto";
		var data = instance.data;

		if (allActions || this.legendAction == "toggle") instance.set("active", !data.active);
	};

	ColumnBarGraphBase.prototype.render = function render(context, instance, key) {
		var data = instance.data;

		return VDOM.createElement(
			"g",
			{ key: key, className: data.classNames },
			data.active && this.renderGraph(context, instance)
		);
	};

	ColumnBarGraphBase.prototype.handleClick = function handleClick(e, instance, point, index) {
		if (this.onClick && instance.invoke("onClick", e, instance, point, index) === false) return;

		if (!this.selection.isDummy) this.selection.select(instance.store, point, index, e.ctrlKey);
	};

	return ColumnBarGraphBase;
})(Widget);

ColumnBarGraphBase.prototype.xAxis = "x";
ColumnBarGraphBase.prototype.yAxis = "y";
ColumnBarGraphBase.prototype.xField = "x";
ColumnBarGraphBase.prototype.yField = "y";
ColumnBarGraphBase.prototype.colorIndexField = false;
ColumnBarGraphBase.prototype.size = 1;
ColumnBarGraphBase.prototype.legend = "legend";
ColumnBarGraphBase.prototype.legendAction = "auto";
ColumnBarGraphBase.prototype.legendShape = "rect";
ColumnBarGraphBase.prototype.stack = "stack";
ColumnBarGraphBase.prototype.stacked = false;
ColumnBarGraphBase.prototype.autoSize = 0;
ColumnBarGraphBase.prototype.offset = 0;
ColumnBarGraphBase.prototype.styled = true;

var ColumnGraph = (function(_ColumnBarGraphBase) {
	inherits(ColumnGraph, _ColumnBarGraphBase);

	function ColumnGraph() {
		classCallCheck(this, ColumnGraph);
		return possibleConstructorReturn(this, _ColumnBarGraphBase.apply(this, arguments));
	}

	ColumnGraph.prototype.explore = function explore(context, instance) {
		var _this2 = this;

		_ColumnBarGraphBase.prototype.explore.call(this, context, instance);

		var data = instance.data,
			xAxis = instance.xAxis,
			yAxis = instance.yAxis;

		if (isArray(data.data)) {
			data.data.forEach(function(p) {
				var y0 = _this2.y0Field ? p[_this2.y0Field] : data.y0;
				var x = p[_this2.xField];
				var y = p[_this2.yField];

				xAxis.acknowledge(x, data.size, data.offset);

				if (data.autoSize) xAxis.book(x, data.stacked ? data.stack : data.name);

				if (data.stacked) {
					yAxis.stacknowledge(data.stack, x, y0);
					yAxis.stacknowledge(data.stack, x, y);
				} else {
					if (!_this2.hiddenBase) yAxis.acknowledge(y0);
					yAxis.acknowledge(y);
				}
			});
		}
	};

	ColumnGraph.prototype.renderGraph = function renderGraph(context, instance) {
		var _this3 = this;

		var data = instance.data,
			xAxis = instance.xAxis,
			yAxis = instance.yAxis,
			store = instance.store;

		if (!isArray(data.data)) return false;

		var isSelected = this.selection.getIsSelectedDelegate(store);

		return data.data.map(function(p, i) {
			var _state;

			var offset = data.offset,
				size = data.size;

			var y0 = _this3.y0Field ? p[_this3.y0Field] : data.y0;
			var x = p[_this3.xField];
			var y = p[_this3.yField];

			if (data.autoSize) {
				var _instance$xAxis$locat = instance.xAxis.locate(x, data.stacked ? data.stack : data.name),
					index = _instance$xAxis$locat[0],
					count = _instance$xAxis$locat[1];

				offset = size / count * (index - count / 2 + 0.5);
				size = size / count;
			}

			var x1 = xAxis.map(x, offset - size / 2);
			var x2 = xAxis.map(x, offset + size / 2);
			var y1 = data.stacked ? yAxis.stack(data.stack, x, y0) : yAxis.map(y0);
			var y2 = data.stacked ? yAxis.stack(data.stack, x, y) : yAxis.map(y);

			var color = _this3.colorIndexField ? p[_this3.colorIndexField] : data.colorIndex;
			var state = ((_state = {
				selected: isSelected(p, i),
				selectable: !_this3.selection.isDummy
			}),
			(_state["color-" + color] = color != null),
			_state);

			var mmove = void 0,
				mleave = void 0;

			if (_this3.tooltip) {
				mmove = function mmove(e) {
					return tooltipMouseMove(e, instance, _this3.tooltip, {
						target: e.target.parent,
						data: {
							$record: p
						}
					});
				};
				mleave = function mleave(e) {
					return tooltipMouseLeave(e, instance, _this3.tooltip, {
						target: e.target.parent,
						data: {
							$record: p
						}
					});
				};
			}

			return VDOM.createElement("rect", {
				key: i,
				className: _this3.CSS.element(_this3.baseClass, "column", state),
				onClick: function onClick(e) {
					_this3.handleClick(e, instance, p, i);
				},
				x: Math.min(x1, x2),
				y: Math.min(y1, y2),
				width: Math.abs(x2 - x1),
				height: Math.abs(y2 - y1),
				style: data.style,
				onMouseMove: mmove,
				onMouseLeave: mleave
			});
		});
	};

	return ColumnGraph;
})(ColumnBarGraphBase);

ColumnGraph.prototype.baseClass = "columngraph";
ColumnGraph.prototype.y0Field = false;
ColumnGraph.prototype.y0 = 0;
ColumnGraph.prototype.legendShape = "column";
ColumnGraph.prototype.hiddenBase = false;

Widget.alias("columngraph", ColumnGraph);

var BarGraph = (function(_ColumnBarGraphBase) {
	inherits(BarGraph, _ColumnBarGraphBase);

	function BarGraph() {
		classCallCheck(this, BarGraph);
		return possibleConstructorReturn(this, _ColumnBarGraphBase.apply(this, arguments));
	}

	BarGraph.prototype.explore = function explore(context, instance) {
		var _this2 = this;

		_ColumnBarGraphBase.prototype.explore.call(this, context, instance);

		var data = instance.data,
			yAxis = instance.yAxis,
			xAxis = instance.xAxis;

		if (isArray(data.data)) {
			data.data.forEach(function(p) {
				var x0 = _this2.x0Field ? p[_this2.x0Field] : data.x0;
				var y = p[_this2.yField];
				var x = p[_this2.xField];

				yAxis.acknowledge(y, data.size, data.offset);

				if (data.autoSize) yAxis.book(y, data.stacked ? data.stack : data.name);

				if (data.stacked) {
					xAxis.stacknowledge(data.stack, y, x0);
					xAxis.stacknowledge(data.stack, y, x);
				} else {
					if (!_this2.hiddenBase) xAxis.acknowledge(x0);
					xAxis.acknowledge(x);
				}
			});
		}
	};

	BarGraph.prototype.renderGraph = function renderGraph(context, instance) {
		var _this3 = this;

		var data = instance.data,
			yAxis = instance.yAxis,
			xAxis = instance.xAxis,
			store = instance.store;

		if (!isArray(data.data)) return false;

		var isSelected = this.selection.getIsSelectedDelegate(store);

		return data.data.map(function(p, i) {
			var _state;

			var offset = data.offset,
				size = data.size;

			var x0 = _this3.x0Field ? p[_this3.x0Field] : data.x0;
			var y = p[_this3.yField];
			var x = p[_this3.xField];

			if (data.autoSize) {
				var _instance$yAxis$locat = instance.yAxis.locate(y, data.stacked ? data.stack : data.name),
					index = _instance$yAxis$locat[0],
					count = _instance$yAxis$locat[1];

				offset = size / count * (index - count / 2 + 0.5);
				size = size / count;
			}

			var y1 = yAxis.map(y, offset - size / 2);
			var y2 = yAxis.map(y, offset + size / 2);
			var x1 = data.stacked ? xAxis.stack(data.stack, y, x0) : xAxis.map(x0);
			var x2 = data.stacked ? xAxis.stack(data.stack, y, x) : xAxis.map(x);

			var color = _this3.colorIndexField ? p[_this3.colorIndexField] : data.colorIndex;
			var state = ((_state = {
				selected: isSelected(p, i),
				selectable: !_this3.selection.isDummy
			}),
			(_state["color-" + color] = color != null),
			_state);

			var mmove = void 0,
				mleave = void 0;

			if (_this3.tooltip) {
				mmove = function mmove(e) {
					return tooltipMouseMove(e, instance, _this3.tooltip, {
						target: e.target.parent,
						data: {
							$record: p
						}
					});
				};
				mleave = function mleave(e) {
					return tooltipMouseLeave(e, instance, _this3.tooltip, {
						target: e.target.parent,
						data: {
							$record: p
						}
					});
				};
			}

			return VDOM.createElement("rect", {
				key: i,
				className: _this3.CSS.element(_this3.baseClass, "bar", state),
				onClick: function onClick(e) {
					_this3.handleClick(e, instance, p, i);
				},
				x: Math.min(x1, x2),
				y: Math.min(y1, y2),
				width: Math.abs(x2 - x1),
				height: Math.abs(y2 - y1),
				style: data.style,
				onMouseMove: mmove,
				onMouseLeave: mleave
			});
		});
	};

	return BarGraph;
})(ColumnBarGraphBase);

BarGraph.prototype.baseClass = "bargraph";
BarGraph.prototype.x0Field = false;
BarGraph.prototype.x0 = 0;
BarGraph.prototype.legendShape = "bar";
BarGraph.prototype.hiddenBase = false;

Widget.alias("bargraph", BarGraph);

var ScatterGraph = (function(_Widget) {
	inherits(ScatterGraph, _Widget);

	function ScatterGraph() {
		classCallCheck(this, ScatterGraph);
		return possibleConstructorReturn(this, _Widget.apply(this, arguments));
	}

	ScatterGraph.prototype.init = function init() {
		this.selection = Selection.create(this.selection, {
			records: this.data
		});
		_Widget.prototype.init.call(this);
	};

	ScatterGraph.prototype.declareData = function declareData() {
		var _Widget$prototype$dec;

		var selection = this.selection.configureWidget(this);

		(_Widget$prototype$dec = _Widget.prototype.declareData).call.apply(
			_Widget$prototype$dec,
			[this].concat(Array.prototype.slice.call(arguments), [
				{
					data: undefined,
					size: undefined,
					shape: undefined,
					colorIndex: undefined,
					colorMap: undefined,
					colorName: undefined,
					name: undefined,
					active: true
				},
				selection
			])
		);
	};

	ScatterGraph.prototype.prepareData = function prepareData(context, instance) {
		var data = instance.data;

		if (data.name && !data.colorName) data.colorName = data.name;

		_Widget.prototype.prepareData.call(this, context, instance);
	};

	ScatterGraph.prototype.explore = function explore(context, instance) {
		var _this2 = this;

		_Widget.prototype.explore.call(this, context, instance);

		var xAxis = (instance.xAxis = context.axes[this.xAxis]);
		var yAxis = (instance.yAxis = context.axes[this.yAxis]);

		var data = instance.data;

		instance.colorMap = data.colorMap && context.getColorMap && context.getColorMap(data.colorMap);
		if (instance.colorMap && data.colorName) instance.colorMap.acknowledge(data.colorName);

		if (data.active && isArray(data.data)) {
			data.data.forEach(function(p) {
				xAxis.acknowledge(p[_this2.xField]);
				yAxis.acknowledge(p[_this2.yField]);
			});
		}
	};

	ScatterGraph.prototype.prepare = function prepare(context, instance) {
		var _this3 = this;

		var data = instance.data,
			xAxis = instance.xAxis,
			yAxis = instance.yAxis,
			colorMap = instance.colorMap;

		if (xAxis.shouldUpdate || yAxis.shouldUpdate) instance.markShouldUpdate(context);

		if (colorMap && data.name) {
			data.colorIndex = colorMap.map(data.colorName);
			if (instance.cache("colorIndex", data.colorIndex)) instance.markShouldUpdate(context);
		}

		if (data.name && context.addLegendEntry)
			context.addLegendEntry(this.legend, {
				name: data.name,
				active: data.active,
				colorIndex: data.colorIndex,
				disabled: data.disabled,
				style: data.style,
				shape: data.shape,
				onClick: function onClick(e) {
					_this3.onLegendClick(e, instance);
				}
			});
	};

	ScatterGraph.prototype.onLegendClick = function onLegendClick(e, instance) {
		var allActions = this.legendAction == "auto";
		var data = instance.data;

		if (allActions || this.legendAction == "toggle") instance.set("active", !data.active);
	};

	ScatterGraph.prototype.render = function render(context, instance, key) {
		var data = instance.data;

		return VDOM.createElement("g", { key: key, className: data.classNames }, this.renderData(context, instance));
	};

	ScatterGraph.prototype.renderData = function renderData(context, instance) {
		var _this4 = this;

		var data = instance.data,
			xAxis = instance.xAxis,
			yAxis = instance.yAxis,
			store = instance.store;

		if (!data.active) return null;

		var shape = getShape(data.shape);

		var isSelected = this.selection.getIsSelectedDelegate(store);

		return (
			isArray(data.data) &&
			data.data.map(function(p, i) {
				var _CSS$element;

				var classes = CSS.element(
					_this4.baseClass,
					"shape",
					((_CSS$element = {
						selected: isSelected(p, i),
						selectable: !_this4.selection.isDummy
					}),
					(_CSS$element["color-" + data.colorIndex] = data.colorIndex != null),
					_CSS$element)
				);

				var cx = xAxis.map(p[_this4.xField]),
					cy = yAxis.map(p[_this4.yField]),
					size = _this4.sizeField ? p[_this4.sizeField] : data.size;

				return shape(cx, cy, size, {
					key: i,
					className: classes,
					style: p.style || data.style,
					onClick: function onClick(e) {
						_this4.handleItemClick(e, instance, i);
					}
				});
			})
		);
	};

	ScatterGraph.prototype.handleItemClick = function handleItemClick(e, _ref, index) {
		var data = _ref.data,
			store = _ref.store;

		var bubble = data.data[index];
		this.selection.select(store, bubble, index, {
			toggle: e.ctrlKey
		});
	};

	return ScatterGraph;
})(Widget);

ScatterGraph.prototype.baseClass = "scattergraph";
ScatterGraph.prototype.xAxis = "x";
ScatterGraph.prototype.yAxis = "y";

ScatterGraph.prototype.xField = "x";
ScatterGraph.prototype.yField = "y";
ScatterGraph.prototype.sizeField = false;
ScatterGraph.prototype.shape = "circle";

ScatterGraph.prototype.size = 10;
ScatterGraph.prototype.legend = "legend";
ScatterGraph.prototype.legendAction = "auto";
ScatterGraph.prototype.styled = true;

Widget.alias("scatter-graph", ScatterGraph);

var BubbleGraph = (function(_Widget) {
	inherits(BubbleGraph, _Widget);

	function BubbleGraph() {
		classCallCheck(this, BubbleGraph);
		return possibleConstructorReturn(this, _Widget.apply(this, arguments));
	}

	BubbleGraph.prototype.declareData = function declareData() {
		var _Widget$prototype$dec;

		var selection = this.selection.configureWidget(this);

		(_Widget$prototype$dec = _Widget.prototype.declareData).call.apply(
			_Widget$prototype$dec,
			[this].concat(Array.prototype.slice.call(arguments), [
				{
					data: undefined,
					bubbleRadius: undefined,
					bubbleStyle: {
						structured: true
					}
				},
				selection
			])
		);
	};

	BubbleGraph.prototype.init = function init() {
		this.selection = Selection.create(this.selection, {
			records: this.data
		});
		_Widget.prototype.init.call(this);
	};

	BubbleGraph.prototype.explore = function explore(context, instance) {
		var _this2 = this;

		instance.axes = context.axes;
		_Widget.prototype.explore.call(this, context, instance);
		var data = instance.data;

		if (isArray(data.data)) {
			data.data.forEach(function(p) {
				instance.axes[_this2.xAxis].acknowledge(p[_this2.xField]);
				instance.axes[_this2.yAxis].acknowledge(p[_this2.yField]);
			});
		}
	};

	BubbleGraph.prototype.prepare = function prepare(context, instance) {
		_Widget.prototype.prepare.call(this, context, instance);
		if (instance.axes[this.xAxis].shouldUpdate || instance.axes[this.yAxis].shouldUpdate)
			instance.markShouldUpdate(context);
	};

	BubbleGraph.prototype.render = function render(context, instance, key) {
		var data = instance.data;

		return VDOM.createElement("g", { key: key, className: data.classNames }, this.renderData(context, instance));
	};

	BubbleGraph.prototype.renderData = function renderData(context, instance) {
		var _this3 = this;

		var data = instance.data,
			axes = instance.axes,
			store = instance.store;

		var xAxis = axes[this.xAxis];
		var yAxis = axes[this.yAxis];

		return (
			isArray(data.data) &&
			data.data.map(function(p, i) {
				var selected = _this3.selection && _this3.selection.isSelected(store, p, i);
				var classes = CSS.element(_this3.baseClass, "bubble", {
					selected: selected
				});
				return VDOM.createElement("circle", {
					key: i,
					className: classes,
					cx: xAxis.map(p[_this3.xField]),
					cy: yAxis.map(p[_this3.yField]),
					r: p[_this3.rField] || data.bubbleRadius,
					style: p.style || data.bubbleStyle,
					onClick: function onClick(e) {
						_this3.onBubbleClick(e, instance, i);
					}
				});
			})
		);
	};

	BubbleGraph.prototype.onBubbleClick = function onBubbleClick(e, _ref, index) {
		var data = _ref.data,
			store = _ref.store;

		var bubble = data.data[index];
		this.selection.select(store, bubble, index, {
			toggle: e.ctrlKey
		});
	};

	return BubbleGraph;
})(Widget);

BubbleGraph.prototype.baseClass = "bubblegraph";
BubbleGraph.prototype.xAxis = "x";
BubbleGraph.prototype.yAxis = "y";

BubbleGraph.prototype.xField = "x";
BubbleGraph.prototype.yField = "y";
BubbleGraph.prototype.rField = "r";

BubbleGraph.prototype.bubbleRadius = 10;

Widget.alias("bubble-graph", BubbleGraph);

var MouseTracker = (function(_BoundedObject) {
	inherits(MouseTracker, _BoundedObject);

	function MouseTracker() {
		classCallCheck(this, MouseTracker);
		return possibleConstructorReturn(this, _BoundedObject.apply(this, arguments));
	}

	MouseTracker.prototype.declareData = function declareData() {
		var _BoundedObject$protot;

		return (_BoundedObject$protot = _BoundedObject.prototype.declareData).call.apply(
			_BoundedObject$protot,
			[this].concat(Array.prototype.slice.call(arguments), [
				{
					x: undefined,
					y: undefined
				}
			])
		);
	};

	MouseTracker.prototype.explore = function explore(context, instance) {
		instance.xAxis = context.axes[this.xAxis];
		instance.yAxis = context.axes[this.yAxis];
		_BoundedObject.prototype.explore.call(this, context, instance);
	};

	MouseTracker.prototype.render = function render(context, instance, key) {
		var _this2 = this;

		var data = instance.data;
		var bounds = data.bounds;

		if (!bounds.valid()) return null;

		return VDOM.createElement(
			"g",
			{
				key: key,
				className: data.classNames,
				onMouseMove: function onMouseMove(e) {
					_this2.handleMouseMove(e, instance);
				},
				onMouseLeave: function onMouseLeave(e) {
					_this2.handleMouseLeave(e, instance);
				}
			},
			VDOM.createElement("rect", {
				x: bounds.l,
				y: bounds.t,
				width: bounds.width(),
				height: bounds.height(),
				fill: "transparent",
				strokeWidth: "0"
			}),
			this.renderChildren(context, instance)
		);
	};

	MouseTracker.prototype.handleMouseMove = function handleMouseMove(e, instance) {
		var xAxis = instance.xAxis,
			yAxis = instance.yAxis;

		var svgEl = closest(e.target, function(el) {
			return el.tagName == "svg";
		});
		var bounds = svgEl.getBoundingClientRect();

		if (xAxis) instance.set("x", xAxis.trackValue(e.clientX - bounds.left));

		if (yAxis) instance.set("y", yAxis.trackValue(e.clientY - bounds.top));

		tooltipMouseMove(e, instance, instance.widget.tooltip);
	};

	MouseTracker.prototype.handleMouseLeave = function handleMouseLeave(e, instance) {
		var xAxis = instance.xAxis,
			yAxis = instance.yAxis;

		tooltipMouseLeave(e, instance, instance.widget.tooltip);

		if (xAxis) instance.set("x", null);

		if (yAxis) instance.set("y", null);
	};

	return MouseTracker;
})(BoundedObject);

MouseTracker.prototype.xAxis = "x";
MouseTracker.prototype.yAxis = "y";
MouseTracker.prototype.anchors = "0 1 1 0";
MouseTracker.prototype.baseClass = "mousetracker";

var Stack = (function() {
	function Stack() {
		classCallCheck(this, Stack);

		this.reset();
	}

	Stack.prototype.reset = function reset() {
		this.totals = {};
		this.values = {};
		this.normalized = false;
		this.invalid = {};
	};

	Stack.prototype.acknowledge = function acknowledge(ordinal, value) {
		if (value != null) {
			var v = this.totals[ordinal] || 0;
			this.totals[ordinal] = v + value;
		} else {
			this.invalid[ordinal] = true;
		}
	};

	Stack.prototype.measure = function measure(normalized) {
		if (normalized) {
			this.normalized = true;
			return [0, 1];
		}

		var max = 0,
			min = 0;
		for (var key in this.totals) {
			if (this.totals[key] > max) max = this.totals[key];
			if (this.totals[key] < min) min = this.totals[key];
		}
		return [min, max];
	};

	Stack.prototype.stack = function stack(ordinal, value) {
		if (value == null || this.invalid[ordinal]) return null;

		var base = this.values[ordinal] || 0;

		var result = (this.values[ordinal] = base + value);

		if (!this.normalized) return result;

		var total = this.totals[ordinal];

		if (total > 0) return result / total;

		return null;
	};

	return Stack;
})();

var NumericAxis = (function(_Axis) {
	inherits(NumericAxis, _Axis);

	function NumericAxis() {
		classCallCheck(this, NumericAxis);
		return possibleConstructorReturn(this, _Axis.apply(this, arguments));
	}

	NumericAxis.prototype.init = function init() {
		if (this.deadZone) {
			this.lowerDeadZone = this.deadZone;
			this.upperDeadZone = this.deadZone;
		}
		_Axis.prototype.init.call(this);
	};

	NumericAxis.prototype.declareData = function declareData() {
		var _Axis$prototype$decla;

		(_Axis$prototype$decla = _Axis.prototype.declareData).call.apply(
			_Axis$prototype$decla,
			[this].concat(Array.prototype.slice.call(arguments), [
				{
					min: undefined,
					max: undefined,
					normalized: undefined,
					inverted: undefined,
					labelDivisor: undefined,
					format: undefined,
					lowerDeadZone: undefined,
					upperDeadZone: undefined
				}
			])
		);
	};

	NumericAxis.prototype.initInstance = function initInstance(context, instance) {
		instance.calculator = new NumericScale();
	};

	NumericAxis.prototype.explore = function explore(context, instance) {
		_Axis.prototype.explore.call(this, context, instance);
		var _instance$data = instance.data,
			min = _instance$data.min,
			max = _instance$data.max,
			normalized = _instance$data.normalized,
			inverted = _instance$data.inverted,
			lowerDeadZone = _instance$data.lowerDeadZone,
			upperDeadZone = _instance$data.upperDeadZone;

		instance.calculator.reset(
			min,
			max,
			this.snapToTicks,
			this.tickDivisions,
			this.minTickDistance,
			this.minLabelDistance,
			normalized,
			inverted,
			lowerDeadZone,
			upperDeadZone
		);
	};

	NumericAxis.prototype.render = function render(context, instance, key) {
		var data = instance.data;

		if (!data.bounds.valid()) return null;

		var baseFormatter = Format$1.parse(data.format);
		var formatter =
			data.labelDivisor != 1
				? function(v) {
						return baseFormatter(v / data.labelDivisor);
					}
				: baseFormatter;

		return VDOM.createElement(
			"g",
			{ key: key, className: data.classNames, style: data.style },
			this.renderTicksAndLabels(context, instance, formatter)
		);
	};

	NumericAxis.XY = function XY() {
		return {
			x: { type: NumericAxis },
			y: { type: NumericAxis, vertical: true }
		};
	};

	return NumericAxis;
})(Axis);

NumericAxis.prototype.baseClass = "numericaxis";
NumericAxis.prototype.tickDivisions = [
	[1, 2, 10],
	[1, 5, 10],
	[2.5, 5, 10],
	//[2, 4, 10],
	[5, 10]
];

NumericAxis.prototype.snapToTicks = 1;
NumericAxis.prototype.normalized = false;
NumericAxis.prototype.format = "n";
NumericAxis.prototype.labelDivisor = 1;

Axis.alias("numeric", NumericAxis);

var NumericScale = (function() {
	function NumericScale() {
		classCallCheck(this, NumericScale);
	}

	NumericScale.prototype.reset = function reset(
		min,
		max,
		snapToTicks,
		tickDivisions,
		minTickDistance,
		minLabelDistance,
		normalized,
		inverted,
		lowerDeadZone,
		upperDeadZone
	) {
		this.padding = 0;
		this.min = min;
		this.max = max;
		this.snapToTicks = snapToTicks;
		this.tickDivisions = tickDivisions;
		this.minLabelDistance = minLabelDistance;
		this.minTickDistance = minTickDistance;
		this.tickSizes = [];
		this.normalized = normalized;
		this.inverted = inverted;
		delete this.minValue;
		delete this.maxValue;
		this.stacks = {};
		this.lowerDeadZone = lowerDeadZone || 0;
		this.upperDeadZone = upperDeadZone || 0;
	};

	NumericScale.prototype.map = function map(v) {
		var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

		return this.origin + (v + offset - this.scale.min + this.padding) * this.scale.factor;
	};

	NumericScale.prototype.decodeValue = function decodeValue(n) {
		return n;
	};

	NumericScale.prototype.encodeValue = function encodeValue(v) {
		return v;
	};

	NumericScale.prototype.constrainValue = function constrainValue(v) {
		return Math.max(this.scale.min, Math.min(this.scale.max, v));
	};

	NumericScale.prototype.trackValue = function trackValue(v) {
		var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
		var constrain = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

		var value = (v - this.origin) / this.scale.factor - offset + this.scale.min - this.padding;
		if (constrain) value = this.constrainValue(v);
		return value;
	};

	NumericScale.prototype.hash = function hash() {
		var _this2 = this;

		var r = {
			origin: this.origin,
			factor: this.scale.factor,
			min: this.scale.min,
			max: this.scale.max,
			padding: this.padding
		};
		r.stacks = Object.keys(this.stacks)
			.map(function(s) {
				return _this2.stacks[s].info.join(",");
			})
			.join(":");
		return r;
	};

	NumericScale.prototype.isSame = function isSame(x) {
		var hash = this.hash();
		var same =
			x &&
			!Object.keys(hash).some(function(k) {
				return x[k] !== hash[k];
			});
		this.shouldUpdate = !same;
		return same;
	};

	NumericScale.prototype.measure = function measure(a, b) {
		this.a = a;
		this.b = b;

		for (var s in this.stacks) {
			var info = this.stacks[s].measure(this.normalized);
			var min = info[0],
				max = info[1],
				invalid = info[2];

			if (this.min == null || min < this.min) this.min = min;
			if (this.max == null || max > this.max) this.max = max;
			this.stacks[s].info = info;
		}

		if (this.minValue != null && this.min == null)
			// || this.minValue < this.min))
			this.min = this.minValue;

		if (this.min == null) this.min = 0;

		if (this.maxValue != null && this.max == null)
			// || this.maxValue > this.max))
			this.max = this.maxValue;

		if (this.max == null) this.max = this.normalized ? 1 : 100;

		this.origin = this.inverted ? this.b : this.a;

		this.scale = this.getScale();

		this.calculateTicks();
	};

	NumericScale.prototype.getScale = function getScale(tickSizes) {
		var min = this.min,
			max = this.max;

		var smin = min;
		var smax = max;
		var tickSize = void 0;
		if (tickSizes && 0 <= this.snapToTicks && tickSizes.length > 0) {
			tickSize = tickSizes[Math.min(tickSizes.length - 1, this.snapToTicks)];
			smin = Math.floor(smin / tickSize) * tickSize;
			smax = Math.ceil(smax / tickSize) * tickSize;
		}

		var sign = this.b > this.a ? 1 : -1;

		var factor =
			smin < smax
				? (Math.abs(this.b - this.a) - this.lowerDeadZone - this.upperDeadZone) / (smax - smin + 2 * this.padding)
				: 0;

		if (factor < 0) factor = 0;

		if (factor > 0 && (this.lowerDeadZone > 0 || this.upperDeadZone > 0)) {
			while (factor * (min - smin) < this.lowerDeadZone) {
				smin -= this.lowerDeadZone / factor;
			}
			while (factor * (smax - max) < this.upperDeadZone) {
				smax += this.upperDeadZone / factor;
			}
			if (tickSize > 0) {
				smin = Math.floor(smin / tickSize) * tickSize;
				smax = Math.ceil(smax / tickSize) * tickSize;
			}

			factor = smin < smax ? Math.abs(this.b - this.a) / (smax - smin + 2 * this.padding) : 0;
		}

		return {
			factor: sign * (this.inverted ? -factor : factor),
			min: smin,
			max: smax
		};
	};

	NumericScale.prototype.acknowledge = function acknowledge(value) {
		var width = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
		var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

		if (value == null) return;

		if (this.minValue == null || value < this.minValue) {
			this.minValue = value;
			this.padding = Math.max(this.padding, Math.abs(offset - width / 2));
		}
		if (this.maxValue == null || value > this.maxValue) {
			this.maxValue = value;
			this.padding = Math.max(this.padding, Math.abs(offset + width / 2));
		}
	};

	NumericScale.prototype.getStack = function getStack(name) {
		var s = this.stacks[name];
		if (!s) s = this.stacks[name] = new Stack();
		return s;
	};

	NumericScale.prototype.stacknowledge = function stacknowledge(name, ordinal, value) {
		return this.getStack(name).acknowledge(ordinal, value);
	};

	NumericScale.prototype.stack = function stack(name, ordinal, value) {
		var v = this.getStack(name).stack(ordinal, value);
		return v != null ? this.map(v) : null;
	};

	NumericScale.prototype.findTickSize = function findTickSize(minPxDist) {
		var _this3 = this;

		return this.tickSizes.find(function(a) {
			return a * Math.abs(_this3.scale.factor) >= minPxDist;
		});
	};

	NumericScale.prototype.getTickSizes = function getTickSizes() {
		return this.tickSizes;
	};

	NumericScale.prototype.calculateTicks = function calculateTicks() {
		var _this4 = this;

		var dist = this.minLabelDistance / Math.abs(this.scale.factor);
		var unit = Math.pow(10, Math.floor(Math.log10(dist)));

		var bestLevel = 100;
		var bestTicks = [];
		var bestScale = this.scale;

		var _loop = function _loop(i) {
			var divs = _this4.tickDivisions[i];
			var tickSizes = divs.map(function(s) {
				return s * unit;
			});
			var scale = _this4.getScale(tickSizes);
			tickSizes.forEach(function(size, level) {
				if (size * Math.abs(scale.factor) >= _this4.minTickDistance && level < bestLevel) {
					bestScale = scale;
					bestTicks = tickSizes;
					bestLevel = level;
				}
			});
		};

		for (var i = 0; i < this.tickDivisions.length && bestLevel > 0; i++) {
			_loop(i);
		}
		this.scale = bestScale;
		this.tickSizes = bestTicks.filter(function(ts) {
			return ts * Math.abs(bestScale.factor) >= _this4.minTickDistance;
		});
		if (this.tickSizes.length > 0) {
			var max = this.tickSizes[this.tickSizes.length - 1];
			this.tickSizes.push(2 * max);
			this.tickSizes.push(5 * max);
			this.tickSizes.push(10 * max);
		}
	};

	NumericScale.prototype.getTicks = function getTicks(tickSizes) {
		var _this5 = this;

		return tickSizes.map(function(size) {
			var start = Math.ceil(_this5.scale.min / size);
			var end = Math.floor(_this5.scale.max / size);
			var result = [];
			for (var i = start; i <= end; i++) {
				result.push(i * size);
			}
			return result;
		});
	};

	NumericScale.prototype.mapGridlines = function mapGridlines() {
		var size = this.tickSizes[0];
		var start = Math.ceil(this.scale.min / size);
		var end = Math.floor(this.scale.max / size);
		var result = [];
		for (var i = start; i <= end; i++) {
			result.push(this.map(i * size));
		}
		return result;
	};

	return NumericScale;
})();

var CategoryAxis = (function(_Axis) {
	inherits(CategoryAxis, _Axis);

	function CategoryAxis() {
		classCallCheck(this, CategoryAxis);
		return possibleConstructorReturn(this, _Axis.apply(this, arguments));
	}

	CategoryAxis.prototype.declareData = function declareData() {
		var _Axis$prototype$decla;

		(_Axis$prototype$decla = _Axis.prototype.declareData).call.apply(
			_Axis$prototype$decla,
			[this].concat(Array.prototype.slice.call(arguments), [
				{
					inverted: undefined,
					uniform: undefined,
					names: undefined,
					values: undefined,
					minSize: undefined
				}
			])
		);
	};

	CategoryAxis.prototype.initInstance = function initInstance(context, instance) {
		instance.calculator = new CategoryScale();
	};

	CategoryAxis.prototype.explore = function explore(context, instance) {
		_Axis.prototype.explore.call(this, context, instance);
		var _instance$data = instance.data,
			values = _instance$data.values,
			names = _instance$data.names,
			inverted = _instance$data.inverted,
			uniform = _instance$data.uniform,
			minSize = _instance$data.minSize;

		instance.calculator.reset(inverted, uniform, values, names, minSize);
	};

	CategoryAxis.prototype.render = function render(context, instance, key) {
		var data = instance.data,
			calculator = instance.calculator;

		if (!data.bounds.valid()) return null;

		var formatter = function formatter(v) {
			return calculator.names[v] || v;
		};

		return VDOM.createElement(
			"g",
			{ key: key, className: data.classNames, style: data.style },
			this.renderTicksAndLabels(context, instance, formatter)
		);
	};

	return CategoryAxis;
})(Axis);

CategoryAxis.prototype.baseClass = "categoryaxis";
CategoryAxis.prototype.anchors = "0 1 1 0";
CategoryAxis.prototype.vertical = false;
CategoryAxis.prototype.inverted = false;
CategoryAxis.prototype.uniform = false;
CategoryAxis.prototype.labelOffset = 10;
CategoryAxis.prototype.labelRotation = 0;
CategoryAxis.prototype.labelAnchor = "auto";
CategoryAxis.prototype.labelDx = "auto";
CategoryAxis.prototype.labelDy = "auto";
CategoryAxis.prototype.minSize = 1;

Axis.alias("category", CategoryAxis);

var CategoryScale = (function() {
	function CategoryScale() {
		classCallCheck(this, CategoryScale);
	}

	CategoryScale.prototype.reset = function reset(inverted, uniform, values, names, minSize) {
		var _this2 = this;

		this.padding = 0.5;
		delete this.min;
		delete this.max;
		delete this.minValue;
		delete this.maxValue;
		this.minSize = minSize;
		this.valuesMap = {};
		this.valueList = [];
		this.inverted = inverted;
		this.uniform = uniform;
		this.valueStacks = {};
		this.names = {};

		if (values) {
			if (isArray(values))
				values.forEach(function(v) {
					return _this2.acknowledge(v);
				});
			else if ((typeof values === "undefined" ? "undefined" : _typeof(values)) == "object")
				for (var k in values) {
					this.acknowledge(k);
					this.names[k] = values[k];
				}
		}

		if (names) {
			if (isArray(names)) {
				values = values || [];
				names.forEach(function(name, index) {
					var value = values[index];
					_this2.names[value != null ? value : index] = name;
				});
			} else this.names = names;
		}
	};

	CategoryScale.prototype.decodeValue = function decodeValue(n) {
		return n;
	};

	CategoryScale.prototype.encodeValue = function encodeValue(v) {
		return v;
	};

	CategoryScale.prototype.map = function map(v) {
		var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

		var index = this.valuesMap[v] || 0;

		return this.origin + (index + offset - this.min + this.padding) * this.factor;
	};

	CategoryScale.prototype.measure = function measure(a, b) {
		this.a = a;
		this.b = b;

		if (this.min == null) this.min = this.minValue || 0;

		if (this.max == null) this.max = !isNaN(this.maxValue) ? this.maxValue : 100;

		var sign = this.inverted ? -1 : 1;

		if (this.max - this.min + 1 < this.minSize) {
			this.factor = sign * (this.b - this.a) / this.minSize;
			this.origin = (this.b + this.a) * 0.5 - this.factor * (this.max - this.min + 1) / 2;
		} else {
			this.factor = sign * (this.b - this.a) / (this.max - this.min + 2 * this.padding);
			this.origin = this.a * (1 + sign) / 2 + this.b * (1 - sign) / 2; //a || b
		}
	};

	CategoryScale.prototype.hash = function hash() {
		return {
			origin: this.origin,
			factor: this.factor,
			min: this.min,
			minSize: this.minSize,
			padding: this.padding,
			values: this.valueList.join(":"),
			names: JSON.stringify(this.names)
		};
	};

	CategoryScale.prototype.isSame = function isSame(x) {
		var h = this.hash();
		var same =
			x &&
			!Object.keys(h).some(function(k) {
				return x[k] !== h[k];
			});
		this.shouldUpdate = !same;
		return same;
	};

	CategoryScale.prototype.acknowledge = function acknowledge(value) {
		var width = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
		var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

		var index = this.valuesMap[value];
		if (isUndefined(index)) {
			index = this.valueList.length;
			this.valueList.push(value);
			this.valuesMap[value] = index;
		}

		if (this.minValue == null || index < this.minValue) {
			this.minValue = index;
			this.padding = Math.max(this.padding, Math.abs(offset - width / 2));
		}

		if (this.maxValue == null || index > this.maxValue) {
			this.maxValue = index;
			this.padding = Math.max(this.padding, Math.abs(offset + width / 2));
		}
	};

	CategoryScale.prototype.book = function book(value, name) {
		if (this.uniform) value = 0;

		var stack = this.valueStacks[value];
		if (!stack)
			stack = this.valueStacks[value] = {
				index: {},
				count: 0
			};
		if (!stack.index.hasOwnProperty(name)) stack.index[name] = stack.count++;
	};

	CategoryScale.prototype.locate = function locate(value, name) {
		if (this.uniform) value = 0;

		var stack = this.valueStacks[value];
		if (!stack) return [0, 1];

		return [stack.index[name], stack.count];
	};

	CategoryScale.prototype.findTickSize = function findTickSize(minPxDist) {
		return 1;
	};

	CategoryScale.prototype.getTickSizes = function getTickSizes() {
		return [1];
	};

	CategoryScale.prototype.getTicks = function getTicks(tickSizes) {
		var _this3 = this;

		return tickSizes.map(function(size) {
			return _this3.valueList;
		});
	};

	CategoryScale.prototype.mapGridlines = function mapGridlines() {
		var _this4 = this;

		return Array.from({ length: this.valueList.length + 1 }).map(function(_, index) {
			return _this4.origin + (index - 0.5 - _this4.min + _this4.padding) * _this4.factor;
		});
	};

	return CategoryScale;
})();

Format.registerFactory("yearOrMonth", function(format) {
	var year = Format.parse("datetime;yyyy");
	var month = Format.parse("datetime;MMM");
	return function(date) {
		var d = new Date(date);
		if (d.getMonth() == 0) return year(d);
		else return month(d);
	};
});

Format.registerFactory("monthOrDay", function(format) {
	var month = Format.parse("datetime;MMM");
	var day = Format.parse("datetime;dd");
	return function(date) {
		var d = new Date(date);
		if (d.getDate() == 1) return month(d);
		else return day(d);
	};
});

var TimeAxis = (function(_Axis) {
	inherits(TimeAxis, _Axis);

	function TimeAxis() {
		classCallCheck(this, TimeAxis);
		return possibleConstructorReturn(this, _Axis.apply(this, arguments));
	}

	TimeAxis.prototype.init = function init() {
		if (this.labelAnchor == "auto") this.labelAnchor = this.vertical ? (this.secondary ? "start" : "end") : "start";

		if (this.labelDx == "auto") this.labelDx = this.vertical ? 0 : "5px";

		_Axis.prototype.init.call(this);
	};

	TimeAxis.prototype.declareData = function declareData() {
		var _Axis$prototype$decla;

		(_Axis$prototype$decla = _Axis.prototype.declareData).call.apply(
			_Axis$prototype$decla,
			[this].concat(Array.prototype.slice.call(arguments), [
				{
					anchors: undefined,
					min: undefined,
					max: undefined,
					inverted: undefined
				}
			])
		);
	};

	TimeAxis.prototype.initInstance = function initInstance(context, instance) {
		instance.calculator = new TimeScale();
	};

	TimeAxis.prototype.explore = function explore(context, instance) {
		_Axis.prototype.explore.call(this, context, instance);
		var _instance$data = instance.data,
			min = _instance$data.min,
			max = _instance$data.max,
			normalized = _instance$data.normalized,
			inverted = _instance$data.inverted;

		instance.calculator.reset(
			min,
			max,
			this.snapToTicks,
			this.tickDivisions,
			this.minTickDistance,
			this.minLabelDistance,
			normalized,
			inverted,
			this.minTickUnit
		);
	};

	TimeAxis.prototype.render = function render(context, instance, key) {
		var data = instance.data,
			cached = instance.cached,
			calculator = instance.calculator;

		cached.axis = calculator.hash();

		if (!data.bounds.valid()) return null;

		var format = this.format || calculator.getFormat();
		var formatter = Format.parse(format);

		return VDOM.createElement(
			"g",
			{ key: key, className: data.classNames, style: data.style },
			this.renderTicksAndLabels(context, instance, formatter)
		);
	};

	return TimeAxis;
})(Axis);

Axis.alias("time", TimeAxis);

TimeAxis.prototype.baseClass = "timeaxis";
TimeAxis.prototype.tickDivisions = {
	second: [[1, 5, 15, 30]],
	minute: [[1, 5, 15, 30]],
	hour: [[1, 2, 4, 8], [1, 3, 6, 12]],
	day: [[1]],
	week: [[1]],
	month: [[1, 3, 6]],
	year: [[1, 2, 10], [1, 5, 10], [5, 10, 50], [10, 50, 100]]
};

TimeAxis.prototype.snapToTicks = 0;
TimeAxis.prototype.tickSize = 15;
TimeAxis.prototype.minLabelDistance = 60;
TimeAxis.prototype.minTickDistance = 60;
TimeAxis.prototype.minTickUnit = "second";

function monthNumber(date) {
	return date.getFullYear() * 12 + date.getMonth() + (date.getDate() - 1) / 31;
}

function yearNumber(date) {
	return monthNumber(date) / 12;
}

var miliSeconds = {
	second: 1000,
	minute: 60 * 1000,
	hour: 3600 * 1000,
	day: 3600 * 24 * 1000,
	week: 3600 * 24 * 7 * 1000,
	month: 3600 * 24 * 30 * 1000,
	year: 3600 * 24 * 365 * 1000
};

var TimeScale = (function() {
	function TimeScale() {
		classCallCheck(this, TimeScale);
	}

	TimeScale.prototype.reset = function reset(
		min,
		max,
		snapToTicks,
		tickDivisions,
		minTickDistance,
		minLabelDistance,
		normalized,
		inverted,
		minTickUnit
	) {
		this.dateCache = {};
		this.min = min != null ? this.decodeValue(min) : null;
		this.max = max != null ? this.decodeValue(max) : null;
		this.snapToTicks = snapToTicks;
		this.tickDivisions = tickDivisions;
		this.minLabelDistance = minLabelDistance;
		this.minTickDistance = minTickDistance;
		this.tickSizes = [];
		this.normalized = normalized;
		this.minTickUnit = minTickUnit;
		this.inverted = inverted;
		delete this.minValue;
		delete this.maxValue;
		delete this.minValuePad;
		delete this.maxValuePad;
		this.stacks = {};
	};

	TimeScale.prototype.decodeValue = function decodeValue(date) {
		if (date instanceof Date) return date.getTime();

		switch (typeof date === "undefined" ? "undefined" : _typeof(date)) {
			case "string":
				var v = this.dateCache[date];
				if (!v) v = this.dateCache[date] = Date.parse(date);
				return v;

			case "number":
				return date;
		}
	};

	TimeScale.prototype.encodeValue = function encodeValue(v) {
		return new Date(v).toISOString();
	};

	TimeScale.prototype.getFormat = function getFormat() {
		switch (this.tickMeasure) {
			case "year":
				return "datetime;yyyy";

			case "month":
				if (new Date(this.scale.min).getFullYear() != new Date(this.scale.max).getFullYear()) return "yearOrMonth";
				return "datetime;yyyy MMM";

			case "week":
				return "datetime;MMMdd";

			case "day":
				if (
					new Date(this.scale.min).getFullYear() != new Date(this.scale.max).getFullYear() ||
					new Date(this.scale.min).getMonth() != new Date(this.scale.max).getMonth()
				)
					return "monthOrDay";

				return "datetime;yyyy MMM dd";

			case "hour":
				return "datetime;HH mm n";

			case "minute":
				return "datetime;HH mm n";

			case "second":
				return "datetime;mm ss";

			default:
				return "datetime;yyyy MMM dd HH mm ss n";
		}
	};

	TimeScale.prototype.map = function map(v) {
		var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

		return this.origin + (this.decodeValue(v) + offset - this.scale.minPad) * this.scale.factor;
	};

	TimeScale.prototype.constrainValue = function constrainValue(v) {
		return Math.max(this.scale.min, Math.min(this.scale.max, v));
	};

	TimeScale.prototype.trackValue = function trackValue(v) {
		var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
		var constrain = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

		var value = (this.decodeValue(v) - this.origin) / this.scale.factor - offset + this.scale.minPad;
		if (constrain) value = this.constrainValue(value);
		return value;
	};

	TimeScale.prototype.hash = function hash() {
		var _this2 = this;

		var r = {
			origin: this.origin,
			factor: this.scale.factor,
			min: this.scale.min,
			max: this.scale.max,
			minPad: this.scale.minPad,
			maxPad: this.scale.maxPad
		};
		r.stacks = Object.keys(this.stacks)
			.map(function(s) {
				return _this2.stacks[s].info.join(",");
			})
			.join(":");
		return r;
	};

	TimeScale.prototype.isSame = function isSame(x) {
		var hash = this.hash();
		var same =
			x &&
			!Object.keys(hash).some(function(k) {
				return x[k] !== hash[k];
			});
		this.shouldUpdate = !same;
		return same;
	};

	TimeScale.prototype.measure = function measure(a, b) {
		this.a = a;
		this.b = b;

		for (var s in this.stacks) {
			var info = this.stacks[s].measure(this.normalized);
			var min = info[0],
				max = info[1],
				invalid = info[2];

			if (this.minValue == null || min < this.minValue) this.minValue = min;
			if (this.max == null || max > this.maxValue) this.maxValue = max;
			this.stacks[s].info = info;
		}

		if (this.min == null) {
			if (this.minValue != null) this.min = this.minValue;
			else this.min = 0;
		} else this.minValuePad = this.min;

		if (this.max == null) {
			if (this.maxValue != null) this.max = this.maxValue;
			else this.max = this.normalized ? 1 : 100;
		} else this.maxValuePad = this.max;

		this.origin = this.inverted ? this.b : this.a;

		this.scale = this.getScale();

		this.calculateTicks();
	};

	TimeScale.prototype.getTimezoneOffset = function getTimezoneOffset(date) {
		return date.getTimezoneOffset() * 60 * 1000;
	};

	TimeScale.prototype.getScale = function getScale(tickSizes, measure) {
		var min = this.min,
			max = this.max;

		if (isNumber(this.snapToTicks) && measure && tickSizes && 0 <= this.snapToTicks && tickSizes.length > 0) {
			var size = tickSizes[Math.min(tickSizes.length - 1, this.snapToTicks)];

			var minDate = new Date(min);
			var maxDate = new Date(max);

			switch (measure) {
				case "second":
				case "minute":
				case "hours":
				case "day":
				default:
					var minOffset = this.getTimezoneOffset(minDate);
					var maxOffset = this.getTimezoneOffset(maxDate);
					min = Math.floor((min + minOffset) / size) * size - minOffset;
					max = Math.ceil((max + maxOffset) / size) * size - maxOffset;
					break;

				case "month":
					size /= miliSeconds.month;
					var minMonth = monthNumber(minDate);
					var maxMonth = monthNumber(maxDate);
					minMonth = Math.floor(minMonth / size) * size;
					maxMonth = Math.ceil(maxMonth / size) * size;
					min = new Date(Math.floor(minMonth / 12), minMonth % 12, 1).getTime();
					max = new Date(Math.floor(maxMonth / 12), maxMonth % 12 + 1, 1).getTime();
					break;

				case "year":
					size /= miliSeconds.year;
					var minYear = yearNumber(minDate);
					var maxYear = yearNumber(maxDate);
					minYear = Math.floor(minYear / size) * size;
					maxYear = Math.ceil(maxYear / size) * size;
					min = new Date(minYear, 0, 1).getTime();
					max = new Date(maxYear, 0, 1).getTime();
					break;
			}
		}

		var minPad = this.minValuePad != null ? Math.min(min, this.minValuePad) : min;
		var maxPad = this.maxValuePad != null ? Math.max(max, this.maxValuePad) : max;
		var factor = minPad < maxPad ? (this.b - this.a) / (maxPad - minPad) : 0;

		return {
			factor: this.inverted ? -factor : factor,
			min: min,
			max: max,
			minPad: minPad,
			maxPad: maxPad
		};
	};

	TimeScale.prototype.acknowledge = function acknowledge(value) {
		var width = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
		var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

		value = this.decodeValue(value);
		if (this.minValue == null || value < this.minValue) {
			this.minValue = value;
			this.minValuePad = value + offset - width / 2;
		}
		if (this.maxValue == null || value > this.maxValue) {
			this.maxValue = value;
			this.maxValuePad = value + offset + width / 2;
		}
	};

	TimeScale.prototype.getStack = function getStack(name) {
		var s = this.stacks[name];
		if (!s) s = this.stacks[name] = new Stack();
		return s;
	};

	TimeScale.prototype.stacknowledge = function stacknowledge(name, ordinal, value) {
		return this.getStack(name).acknowledge(ordinal, value);
	};

	TimeScale.prototype.stack = function stack(name, ordinal, value) {
		var v = this.getStack(name).stack(ordinal, value);
		return v != null ? this.map(v) : null;
	};

	TimeScale.prototype.findTickSize = function findTickSize(minPxDist) {
		var _this3 = this;

		return this.tickSizes.find(function(a) {
			return a * Math.abs(_this3.scale.factor) >= minPxDist;
		});
	};

	TimeScale.prototype.getTickSizes = function getTickSizes() {
		return this.tickSizes;
	};

	TimeScale.prototype.calculateTicks = function calculateTicks() {
		var _this4 = this;

		var minReached = false;

		var _loop = function _loop(unit) {
			if (!minReached) {
				if (unit == _this4.minTickUnit) minReached = true;
				else return "continue";
			}

			var unitSize = miliSeconds[unit];
			var divisions = _this4.tickDivisions[unit];

			if (_this4.tickSizes.length > 0) {
				var _tickSizes;

				//add ticks from higher levels
				(_tickSizes = _this4.tickSizes).push.apply(
					_tickSizes,
					divisions[0].map(function(s) {
						return s * unitSize;
					})
				);
				return "continue";
			}

			var bestLevel = 100;
			var bestTicks = [];
			var bestScale = _this4.scale;

			_this4.tickMeasure = unit;

			var _loop2 = function _loop2(i) {
				var divs = divisions[i];
				var tickSizes = divs.map(function(s) {
					return s * unitSize;
				});
				var scale = _this4.getScale(tickSizes, unit);
				tickSizes.forEach(function(size, level) {
					var tickDistance = size * Math.abs(scale.factor);
					if (tickDistance >= _this4.minTickDistance && level < bestLevel) {
						bestScale = scale;
						bestTicks = tickSizes;
						bestLevel = level;
					}
				});
			};

			for (var i = 0; i < divisions.length && bestLevel > 0; i++) {
				_loop2(i);
			}
			_this4.scale = bestScale;
			_this4.tickSizes = bestTicks.filter(function(ts) {
				return ts * Math.abs(bestScale.factor) >= _this4.minTickDistance;
			});
		};

		for (var unit in miliSeconds) {
			var _ret = _loop(unit);

			if (_ret === "continue") continue;
		}
	};

	TimeScale.prototype.getTicks = function getTicks(tickSizes) {
		var _this5 = this;

		return tickSizes.map(function(size) {
			var result = [],
				start = void 0,
				end = void 0,
				minDate = void 0,
				maxDate = void 0;
			if (_this5.tickMeasure == "year") {
				size /= miliSeconds.year;
				minDate = new Date(_this5.scale.min);
				maxDate = new Date(_this5.scale.max);
				start = Math.ceil(yearNumber(minDate) / size) * size;
				end = Math.floor(yearNumber(maxDate) / size) * size;
				for (var i = start; i <= end; i += size) {
					result.push(new Date(i, 0, 1).getTime());
				}
			} else if (_this5.tickMeasure == "month") {
				size /= miliSeconds.month;
				minDate = new Date(_this5.scale.min);
				maxDate = new Date(_this5.scale.max);
				start = Math.ceil(monthNumber(minDate) / size) * size;
				end = Math.floor(monthNumber(maxDate) / size) * size;
				for (var _i = start; _i <= end; _i += size) {
					result.push(new Date(Math.floor(_i / 12), _i % 12, 1).getTime());
				}
			} else {
				var minOffset = _this5.getTimezoneOffset(new Date(_this5.scale.min));
				var date = Math.ceil((_this5.scale.min - minOffset) / size) * size + minOffset;
				while (date <= _this5.scale.max) {
					result.push(date);
					date += size;
				}
			}
			return result;
		});
	};

	TimeScale.prototype.mapGridlines = function mapGridlines() {
		var _this6 = this;

		if (this.tickSizes.length == 0) return [];

		return this.getTicks([this.tickSizes[0]])[0].map(function(x) {
			return _this6.map(x);
		});
	};

	return TimeScale;
})();

var PointReducer = (function(_PureContainer) {
	inherits(PointReducer, _PureContainer);

	function PointReducer() {
		classCallCheck(this, PointReducer);
		return possibleConstructorReturn(this, _PureContainer.apply(this, arguments));
	}

	PointReducer.prototype.explore = function explore(context, instance) {
		var _this2 = this;

		var pointReducer = context.pointReducer;
		instance.parentPointTracker = pointReducer;

		if (!instance.pointReducer) {
			var onMap = this.onMap && instance.getCallback("onMap");
			var accumulator = {};
			instance.resetAccumulator = function() {
				accumulator = {};
				if (_this2.onInitAccumulator) instance.invoke("onInitAccumulator", accumulator, instance);
			};

			instance.pointReducer = function(x, y, name, data, array, index) {
				onMap(accumulator, x, y, name, data, array, index);
				if (pointReducer) pointReducer(x, y, name, data, array, index);
			};

			instance.write = function() {
				if (_this2.onReduce) instance.invoke("onReduce", accumulator, instance);
			};
		}

		instance.resetAccumulator();
		context.push("pointReducer", instance.pointReducer);

		_PureContainer.prototype.explore.call(this, context, instance);
	};

	PointReducer.prototype.exploreCleanup = function exploreCleanup(context, instance) {
		instance.write();
		context.pop("pointReducer");
	};

	return PointReducer;
})(PureContainer);

var MinMaxFinder = (function(_PointReducer) {
	inherits(MinMaxFinder, _PointReducer);

	function MinMaxFinder() {
		classCallCheck(this, MinMaxFinder);
		return possibleConstructorReturn(this, _PointReducer.apply(this, arguments));
	}

	MinMaxFinder.prototype.declareData = function declareData() {
		var _PointReducer$prototy;

		return (_PointReducer$prototy = _PointReducer.prototype.declareData).call.apply(
			_PointReducer$prototy,
			[this].concat(Array.prototype.slice.call(arguments), [
				{
					minX: undefined,
					minY: undefined,
					maxX: undefined,
					maxY: undefined,
					params: {
						structured: true
					}
				}
			])
		);
	};

	MinMaxFinder.prototype.onInitAccumulator = function onInitAccumulator(acc, _ref) {
		var data = _ref.data;

		acc.params = data.params;
		acc.min = { x: null, y: null };
		acc.max = { x: null, y: null };
	};

	MinMaxFinder.prototype.onMap = function onMap(acc, x, y, name, p) {
		if (y != null && (acc.max.y == null || acc.max.y < y)) acc.max = { x: x, y: y, p: p };

		if (y != null && (acc.min.y == null || acc.min.y > y)) acc.min = { x: x, y: y, p: p };
	};

	MinMaxFinder.prototype.onReduce = function onReduce(acc, instance) {
		instance.set("minX", acc.min.x);
		instance.set("minY", acc.min.y);
		instance.set("minRecord", acc.min.p);
		instance.set("maxX", acc.max.x);
		instance.set("maxY", acc.max.y);
		instance.set("maxRecord", acc.max.p);
	};

	return MinMaxFinder;
})(PointReducer);

var SnapPointFinder = (function(_PointReducer) {
	inherits(SnapPointFinder, _PointReducer);

	function SnapPointFinder() {
		classCallCheck(this, SnapPointFinder);
		return possibleConstructorReturn(this, _PointReducer.apply(this, arguments));
	}

	SnapPointFinder.prototype.declareData = function declareData() {
		var _PointReducer$prototy;

		return (_PointReducer$prototy = _PointReducer.prototype.declareData).call.apply(
			_PointReducer$prototy,
			[this].concat(Array.prototype.slice.call(arguments), [
				{
					cursorX: undefined,
					cursorY: undefined,
					snapX: undefined,
					snapY: undefined,
					snapRecord: undefined,
					maxDistance: undefined
				}
			])
		);
	};

	SnapPointFinder.prototype.onInitAccumulator = function onInitAccumulator(acc, _ref) {
		var data = _ref.data;

		acc.cursorX = data.cursorX;
		acc.cursorY = data.cursorY;
		acc.dist = data.maxDistance > 0 ? Math.pow(data.maxDistance, 2) : Number.POSITIVE_INFINITY;
		acc.snapX = null;
		acc.snapY = null;
	};

	SnapPointFinder.prototype.onMap = function onMap(acc, x, y, name, p) {
		var d = null;

		if (acc.cursorX != null && x != null) d = (d || 0) + Math.pow(Math.abs(x - acc.cursorX), 2);

		if (acc.cursorY != null && y != null) d = (d || 0) + Math.pow(Math.abs(y - acc.cursorY), 2);

		if (d != null && d < acc.dist) {
			acc.dist = d;
			acc.snapX = x;
			acc.snapY = y;
			acc.snapRecord = p;
		}
	};

	SnapPointFinder.prototype.onReduce = function onReduce(acc, instance) {
		instance.set("snapX", acc.snapX);
		instance.set("snapY", acc.snapY);
		instance.set("snapRecord", acc.snapRecord);
	};

	return SnapPointFinder;
})(PointReducer);

SnapPointFinder.prototype.maxDistance = 50;

var ValueAtFinder = (function(_PointReducer) {
	inherits(ValueAtFinder, _PointReducer);

	function ValueAtFinder() {
		classCallCheck(this, ValueAtFinder);
		return possibleConstructorReturn(this, _PointReducer.apply(this, arguments));
	}

	ValueAtFinder.prototype.declareData = function declareData() {
		var _PointReducer$prototy;

		return (_PointReducer$prototy = _PointReducer.prototype.declareData).call.apply(
			_PointReducer$prototy,
			[this].concat(Array.prototype.slice.call(arguments), [
				{
					at: undefined,
					value: undefined
				}
			])
		);
	};

	ValueAtFinder.prototype.onInitAccumulator = function onInitAccumulator(acc, _ref) {
		var data = _ref.data;

		acc.at = this.convert(data.at);
	};

	ValueAtFinder.prototype.onMap = function onMap(acc, x, y, name) {
		var d = this.convert(x) - acc.at;
		if (d <= 0 && (!acc.left || acc.left.d < d)) {
			acc.left = {
				x: x,
				y: y,
				d: d
			};
		}
		if (d >= 0 && (!acc.right || acc.right.d > d)) {
			acc.right = {
				x: x,
				y: y,
				d: d
			};
		}
	};

	ValueAtFinder.prototype.onReduce = function onReduce(acc, instance) {
		var y = null;
		if (acc.left && acc.right) {
			if (acc.left.x == acc.right.x) y = acc.left.y;
			else if (acc.left.y != null && acc.right.y != null) {
				y = acc.left.y + (acc.right.y - acc.left.y) * (acc.at - acc.left.x) / (acc.right.x - acc.left.x);
			}
		}
		instance.set("value", y);
	};

	return ValueAtFinder;
})(PointReducer);

ValueAtFinder.prototype.convert = function(x) {
	return x;
};

export {
	Chart,
	PieChart,
	PieSlice,
	Pie,
	Column,
	Bar,
	Legend,
	LegendEntry,
	ColorMap,
	ColorMapScope,
	ColorIndex,
	Marker,
	MarkerLine,
	Range,
	Gridlines,
	LineGraph,
	ColumnGraph,
	BarGraph,
	ScatterGraph,
	BubbleGraph,
	MouseTracker,
	registerShape,
	getShape,
	getAvailableShapes,
	circle,
	square,
	bar,
	column,
	line,
	vline,
	triangle,
	Axis,
	NumericAxis,
	CategoryAxis,
	TimeAxis,
	PointReducer,
	MinMaxFinder,
	SnapPointFinder,
	ValueAtFinder
};
