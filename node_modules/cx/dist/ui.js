import {
	Format,
	GlobalCacheIdentifier,
	SubscriberList,
	Timing,
	appDataFlag,
	appLoopFlag,
	closestParent,
	debounce,
	debug,
	destroyFlag,
	findFirst,
	findFirstChild,
	innerTextTrim,
	isArray,
	isDefined,
	isFocusable,
	isFunction,
	isPromise,
	isSelfOrDescendant,
	isString,
	isTouchEvent,
	now,
	parseStyle,
	processDataFlag,
	renderFlag,
	resolveMinMaxFractionDigits,
	reverseSlice,
	shallowEquals,
	throttle,
	vdomRenderFlag
} from "./util";
import {
	Binding,
	ExposedRecordView,
	Grouper,
	ReadOnlyDataView,
	Store,
	StructuredSelector,
	SubscribableView,
	ZoomIntoPropertyView,
	computable,
	getSelector,
	sorter
} from "./data";
import { VDOM } from "cx-react";
import { DateTimeCulture, NumberCulture } from "intl-io";

var _typeof =
	typeof Symbol === "function" && typeof Symbol.iterator === "symbol"
		? function(obj) {
				return typeof obj;
			}
		: function(obj) {
				return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype
					? "symbol"
					: typeof obj;
			};

var classCallCheck = function(instance, Constructor) {
	if (!(instance instanceof Constructor)) {
		throw new TypeError("Cannot call a class as a function");
	}
};

var createClass = (function() {
	function defineProperties(target, props) {
		for (var i = 0; i < props.length; i++) {
			var descriptor = props[i];
			descriptor.enumerable = descriptor.enumerable || false;
			descriptor.configurable = true;
			if ("value" in descriptor) descriptor.writable = true;
			Object.defineProperty(target, descriptor.key, descriptor);
		}
	}

	return function(Constructor, protoProps, staticProps) {
		if (protoProps) defineProperties(Constructor.prototype, protoProps);
		if (staticProps) defineProperties(Constructor, staticProps);
		return Constructor;
	};
})();

var _extends =
	Object.assign ||
	function(target) {
		for (var i = 1; i < arguments.length; i++) {
			var source = arguments[i];

			for (var key in source) {
				if (Object.prototype.hasOwnProperty.call(source, key)) {
					target[key] = source[key];
				}
			}
		}

		return target;
	};

var inherits = function(subClass, superClass) {
	if (typeof superClass !== "function" && superClass !== null) {
		throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
	}

	subClass.prototype = Object.create(superClass && superClass.prototype, {
		constructor: {
			value: subClass,
			enumerable: false,
			writable: true,
			configurable: true
		}
	});
	if (superClass)
		Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : (subClass.__proto__ = superClass);
};

var possibleConstructorReturn = function(self, call) {
	if (!self) {
		throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	}

	return call && (typeof call === "object" || typeof call === "function") ? call : self;
};

var componentAlias = {};

var Component = (function() {
	function Component(config) {
		classCallCheck(this, Component);

		if (config && config.$props) {
			Object.assign(config, config.$props);
			delete config.$props;
		}
		Object.assign(this, config);
	}

	Component.prototype.init = function init() {};

	Component.alias = function alias(_alias, type) {
		var _this = this;

		if (type) {
			type.prototype.componentAlias = _alias;
			componentAlias[this.namespace + _alias] = type;
		} else //decorator usage
			return function(t) {
				_this.alias(_alias, t);
				return t;
			};
	};

	Component.create = function create(typeAlias, config, more) {
		var _this2 = this;

		if (!typeAlias) return this.factory(typeAlias, config, more);

		if (typeAlias.isComponent) return typeAlias;

		if (isComponentFactory(typeAlias)) return this.create(typeAlias(config, more));

		if (isArray(typeAlias))
			return typeAlias.map(function(c) {
				return _this2.create(c, config, more);
			});

		if (typeAlias.$type) return this.create(typeAlias.$type, typeAlias, config);

		if (typeAlias.type) return this.create(typeAlias.type, typeAlias, config);

		var cmpType = void 0,
			alias = void 0;

		if (typeAlias.isComponentType) cmpType = typeAlias;
		else if (isFunction(typeAlias)) {
			if (this.factory) return this.factory(typeAlias, config, more);
			throw new Error("Unsupported component type " + typeAlias + ".");
		} else if (isString(typeAlias)) {
			alias = this.namespace + typeAlias;
			cmpType = componentAlias[alias];
			if (!cmpType) {
				if (typeAlias && this.factory) return this.factory(typeAlias, config, more);
				throw new Error("Unknown component alias " + alias + ".");
			}
		} else if ((typeof typeAlias === "undefined" ? "undefined" : _typeof(typeAlias)) == "object") {
			cmpType = typeAlias.type || typeAlias.$type;
			if (!cmpType) {
				cmpType = this;
				more = more ? Object.assign({}, config, more) : config;
				config = typeAlias;
			}
		}

		if (isArray(config))
			return config.map(function(cfg) {
				return _this2.create(cmpType, cfg, more);
			});

		var cfg = config;

		if (more) cfg = Object.assign({}, config, more);

		var cmp = new cmpType(cfg);
		if (!this.lazyInit) cmp.init();
		return cmp;
	};

	return Component;
})();

Component.prototype.isComponent = true;

Component.isComponentType = true;
Component.namespace = "";
Component.lazyInit = false;

Component.factory = function(alias, config, more) {
	throw new Error("Unknown component alias " + alias + ".");
};

function createComponentFactory(factory, meta) {
	factory.$isComponentFactory = true;
	factory.$meta = meta;
	return factory;
}

function isComponentFactory(factory) {
	return factory && factory.$isComponentFactory;
}

var computablePrefix = "computable-";
var triggerPrefix = "trigger-";

var Controller = (function(_Component) {
	inherits(Controller, _Component);

	function Controller() {
		classCallCheck(this, Controller);
		return possibleConstructorReturn(this, _Component.apply(this, arguments));
	}

	Controller.prototype.init = function init() {
		_Component.prototype.init.call(this);
		if (this.onInit) this.onInit();
	};

	Controller.prototype.explore = function explore(context) {
		var store = this.instance.store;

		this.store = store; //in rare cases instance may change its store

		if (!this.initialized) {
			this.init();
			this.initialized = true;
		}

		if (this.computables) {
			for (var key in this.computables) {
				var x = this.computables[key];
				var v = x.selector(store.getData());
				if (x.type == "computable") store.set(x.name, v);
			}
		}

		if (this.onExplore) {
			this.onExplore(context);
		}
	};

	Controller.prototype.prepare = function prepare(context) {
		if (this.onPrepare) {
			this.onPrepare(context);
		}
	};

	Controller.prototype.cleanup = function cleanup(context) {
		if (this.onCleanup) {
			this.onCleanup(context);
		}
	};

	Controller.prototype.addComputable = function addComputable(name, args, callback) {
		if (!isArray(args)) throw new Error("Second argument to the addComputable method should be an array.");
		var selector = computable.apply(undefined, args.concat([callback])).memoize();
		if (!this.computables) this.computables = {};
		this.computables[computablePrefix + name] = { name: name, selector: selector, type: "computable" };
	};

	Controller.prototype.addTrigger = function addTrigger(name, args, callback, autoRun) {
		if (!isArray(args)) throw new Error("Second argument to the addTrigger method should be an array.");
		var selector = computable
			.apply(undefined, args.concat([callback]))
			.memoize(false, !autoRun && this.store.getData());
		if (!this.computables) this.computables = {};
		this.computables[triggerPrefix + name] = { name: name, selector: selector, type: "trigger" };
	};

	Controller.prototype.removeTrigger = function removeTrigger(name) {
		if (this.computables) delete this.computables[triggerPrefix + name];
	};

	Controller.prototype.removeComputable = function removeComputable(name) {
		if (this.computables) delete this.computables[computablePrefix + name];
	};

	return Controller;
})(Component);

Controller.namespace = "ui.controller.";
Controller.lazyInit = true;

var cssHelperCache = {};

var CSSHelper = (function() {
	function CSSHelper() {
		classCallCheck(this, CSSHelper);
	}

	CSSHelper.get = function get$$1(code) {
		var helper = cssHelperCache[code];
		if (!helper) throw new Error("Unknown CSS helper '" + code + "'.");
		return helper;
	};

	CSSHelper.register = function register(code, helper) {
		cssHelperCache[code] = helper;
	};

	CSSHelper.alias = function alias(code, helper) {
		cssHelperCache[code] = helper;
	};

	return CSSHelper;
})();

function push(list, item) {
	if (!item) return list;
	if (!list) list = [];
	list.push(item);
	return list;
}

function pushMore(list, itemArray) {
	if (!itemArray || itemArray.length == 0) return list;
	if (!list) list = [];
	list.push.apply(list, itemArray);
	return list;
}

function pushMap(list, itemArray, mapF) {
	return itemArray ? pushMore(list, itemArray.map(mapF)) : list;
}

function join(list) {
	return list ? list.join(" ") : null;
}

var CSS = (function() {
	function CSS() {
		classCallCheck(this, CSS);
	}

	CSS.resolve = function resolve() {
		var list = void 0,
			type = void 0,
			arg = void 0,
			i = void 0,
			key = void 0;

		for (i = 0; i < arguments.length; i++) {
			arg = arguments[i];
			if (arg) {
				type = typeof arg === "undefined" ? "undefined" : _typeof(arg);
				if (type == "string") list = push(list, arg);
				else if (type == "object") {
					if (isArray(arg)) list = pushMore(list, this.resolve.apply(this, arg));
					else
						for (key in arg) {
							if (arg[key]) list = push(list, key);
						}
				}
			}
		}
		return list;
	};

	CSS.block = function block(baseClass, styleModifiers, stateModifiers) {
		var _this = this;

		var list = void 0;
		if (baseClass) list = push(list, this.classPrefix + "b-" + baseClass);
		list = pushMap(list, this.resolve(styleModifiers), function(m) {
			return _this.classPrefix + "m-" + m;
		});
		list = pushMap(list, this.resolve(stateModifiers), function(m) {
			return _this.classPrefix + "s-" + m;
		});
		return join(list);
	};

	CSS.element = function element(baseClass, elementClass, stateModifiers) {
		var _this2 = this;

		var list = void 0;
		if (baseClass && elementClass) list = push(list, this.classPrefix + "e-" + baseClass + "-" + elementClass);
		list = pushMap(list, this.resolve(stateModifiers), function(m) {
			return _this2.classPrefix + "s-" + m;
		});
		return join(list);
	};

	CSS.state = function state(stateModifiers) {
		var _this3 = this;

		return join(
			pushMap(null, this.resolve(stateModifiers), function(m) {
				return _this3.classPrefix + "s-" + m;
			})
		);
	};

	CSS.expand = function expand() {
		return join(this.resolve.apply(this, arguments));
	};

	CSS.parseStyle = function parseStyle$$1(str) {
		return parseStyle(str);
	};

	return CSS;
})();

CSS.classPrefix = "cx";

CSSHelper.alias("cx", CSS);

var RenderingContext = (function() {
	function RenderingContext(options) {
		classCallCheck(this, RenderingContext);

		this.options = options || {};
		this.exploreStack = [];
		this.prepareList = [];
		this.cleanupList = [];
		this.stacks = {};

		this.renderLists = {
			0: []
		};
		this.renderListIndex = 0;
		this.minRenderListIndex = 0;
		this.maxRenderListIndex = 0;
	}

	RenderingContext.prototype.getStack = function getStack(key) {
		var stack = this.stacks[key];
		if (!stack) stack = this.stacks[key] = [];
		return stack;
	};

	RenderingContext.prototype.push = function push(key, value) {
		var stack = this.getStack(key);
		stack.push(this[key]);
		return (this[key] = value);
	};

	RenderingContext.prototype.pop = function pop(key) {
		var stack = this.getStack(key);
		return (this[key] = stack.pop());
	};

	RenderingContext.prototype.pushNamedValue = function pushNamedValue(key, name, value) {
		var stack = this.getStack(key + ":" + name);
		if (!this[key]) this[key] = {};
		stack.push(this[key][name]);
		return (this[key][name] = value);
	};

	RenderingContext.prototype.popNamedValue = function popNamedValue(key, name) {
		var stack = this.getStack(key + ":" + name);
		return (this[key][name] = stack.pop());
	};

	RenderingContext.prototype.get = function get$$1(key) {
		return this[key];
	};

	RenderingContext.prototype.getCurrentRenderList = function getCurrentRenderList() {
		return this.renderLists[this.renderListIndex];
	};

	RenderingContext.prototype.insertRenderList = function insertRenderList() {
		this.maxRenderListIndex++;
		for (var i = this.maxRenderListIndex; i > this.renderListIndex; i--) {
			this.renderLists[i] = this.renderLists[i - 1];
		}
		return (this.renderLists[this.renderListIndex] = []);
	};

	RenderingContext.prototype.getPrevRenderList = function getPrevRenderList() {
		this.renderListIndex--;
		if (this.renderListIndex < this.minRenderListIndex) {
			this.minRenderListIndex = this.renderListIndex;
			this.renderLists[this.renderListIndex] = [];
		}
		return this.renderLists[this.renderListIndex];
	};

	RenderingContext.prototype.getNextRenderList = function getNextRenderList() {
		this.renderListIndex++;
		if (this.renderListIndex > this.maxRenderListIndex) {
			this.maxRenderListIndex = this.renderListIndex;
			this.renderLists[this.renderListIndex] = [];
		}
		return this.renderLists[this.renderListIndex];
	};

	RenderingContext.prototype.getRenderLists = function getRenderLists() {
		var result = [];
		for (var i = this.minRenderListIndex; i <= this.maxRenderListIndex; i++) {
			result.push(this.renderLists[i]);
		}
		return result;
	};

	return RenderingContext;
})();

var VDOM$2 = VDOM;

var VDOM$1 = VDOM$2;

var widgetId = 100;

var Widget = (function(_Component) {
	inherits(Widget, _Component);

	function Widget(config) {
		classCallCheck(this, Widget);

		var _this = possibleConstructorReturn(this, _Component.call(this, config));

		_this.widgetId = widgetId++;

		if (isArray(_this.jsxSpread)) {
			if (!_this.jsxAttributes) _this.jsxAttributes = [];

			_this.jsxSpread.forEach(function(spread) {
				for (var key in spread) {
					_this[key] = spread[key];
					_this.jsxAttributes.push(key);
				}
			});
		}
		return _this;
	}

	Widget.prototype.init = function init() {
		if (this.styles) this.style = this.styles;

		if (this.styled) this.style = parseStyle(this.style);

		if (typeof this.if !== "undefined") this.visible = this.if;

		this.declareData();

		if (this.outerLayout) {
			if (isArray(this.outerLayout)) throw new Error("Only single element outer layout is supported.");
			//TODO: better handle the case when outer layout is an array. How to get around circular dependency to PureContainer
			this.outerLayout = Widget.create(this.outerLayout);
		}

		if (this.contentFor) this.putInto = this.contentFor;

		if (this.putInto) this.isContent = true;

		if (isString(this.CSS)) this.CSS = CSSHelper.get(this.CSS);

		this.initHelpers();
		this.initComponents();

		this.initialized = true;
	};

	Widget.prototype.initComponents = function initComponents() {
		if (arguments.length > 0) {
			this.components = Object.assign.apply(Object, arguments);
			for (var k in this.components) {
				if (!this.components[k]) delete this.components[k];
			}
		}
	};

	Widget.prototype.initHelpers = function initHelpers() {
		if (arguments.length > 0) {
			this.helpers = Object.assign.apply(Object, arguments);
		}
	};

	Widget.prototype.declareData = function declareData() {
		var options = {};

		if (this.styled) options.class = options.className = options.style = { structured: true };

		var props = _extends(
			{
				visible: undefined,
				mod: {
					structured: true
				}
			},
			options
		);
		Object.assign.apply(Object, [props].concat(Array.prototype.slice.call(arguments)));
		this.selector = new StructuredSelector({ props: props, values: this });
		this.nameMap = this.selector.nameMap;
	};

	Widget.prototype.prepareCSS = function prepareCSS(context, _ref) {
		var data = _ref.data;

		data.classNames = this.CSS.expand(
			this.CSS.block(this.baseClass, data.mod, data.stateMods),
			data.class,
			data.className
		);
		data.style = parseStyle(data.style);
	};

	Widget.prototype.prepareData = function prepareData(context, instance) {
		if (this.styled) this.prepareCSS(context, instance);
	};

	Widget.prototype.initInstance = function initInstance(context, instance) {
		if (this.onInit) this.onInit(context, instance);
	};

	Widget.prototype.initState = function initState(context, instance) {};

	Widget.prototype.checkVisible = function checkVisible(context, instance, data) {
		return data.visible;
	};

	Widget.prototype.explore = function explore(context, instance) {
		if (this.components) instance.components = {};
		for (var cmp in this.components) {
			var ins = instance.getChild(context, this.components[cmp], "cmp-" + cmp, instance.store);
			if (ins.scheduleExploreIfVisible(context)) instance.components[cmp] = ins;
		}
	};

	Widget.prototype.render = function render(context, instance, key) {
		throw new Error("render method should be overridden.");
	};

	Widget.prototype.update = function update() {
		this.version = (this.version || 0) + 1;
	};

	Widget.resetCounter = function resetCounter() {
		widgetId = 100;
	};

	return Widget;
})(Component);

Widget.prototype.visible = true;
Widget.prototype.memoize = true; //cache rendered content and use it if possible
Widget.prototype.CSS = "cx";
Widget.prototype.styled = false;

Widget.namespace = "ui.";
Widget.lazyInit = true;
Widget.optimizePrepare = true;

Widget.factory = function(type, config, more) {
	throw new Error("Invalid widget type: " + type + ".");
};

function contentAppend(result, w, prependSpace) {
	if (w == null || w === false) return false;
	if (isArray(w))
		w.forEach(function(c) {
			return contentAppend(result, c);
		});
	else if (isDefined(w.content) && !w.atomic) return contentAppend(result, w.content);
	else {
		if (prependSpace) result.push(" ");
		result.push(w);
	}
	return true;
}

function getContentArray(x) {
	var result = [];
	contentAppend(result, x);
	return result;
}

function getContent(x) {
	var result = getContentArray(x);
	if (result.length == 0) return null;
	if (result.length == 1) return result[0];
	return result;
}

var StaticText = (function(_Widget) {
	inherits(StaticText, _Widget);

	function StaticText() {
		classCallCheck(this, StaticText);
		return possibleConstructorReturn(this, _Widget.apply(this, arguments));
	}

	StaticText.prototype.render = function render() {
		return this.text;
	};

	return StaticText;
})(Widget);

Widget.alias("static-text", StaticText);

function exploreChildren(context, instance, children, previousResult, key, store, beforeCallback, afterCallback) {
	var newChildren = previousResult || [];
	var oldChildren = previousResult || newChildren;
	var identical = previousResult ? 0 : -1;
	var start = context.exploreStack.length;

	for (var c = 0; c < children.length; c++) {
		var cell = instance.getChild(context, children[c], key, store);

		// if (beforeCallback)
		//    beforeCallback(cell);

		if (cell.checkVisible(context)) {
			if (identical >= 0) {
				if (cell == oldChildren[identical]) identical++;
				else {
					newChildren = newChildren.slice(0, identical);
					identical = -1;
					newChildren.push(cell);
				}
			} else newChildren.push(cell);

			context.exploreStack.push(cell);
		}
	}

	if (identical >= 0 && identical != newChildren.length) newChildren = newChildren.slice(0, identical);

	reverseSlice(context.exploreStack, start);

	return newChildren;
}

var Layout = (function(_Component) {
	inherits(Layout, _Component);

	function Layout() {
		classCallCheck(this, Layout);
		return possibleConstructorReturn(this, _Component.apply(this, arguments));
	}

	Layout.prototype.init = function init() {
		_Component.prototype.init.call(this);
		if (isString(this.CSS)) this.CSS = CSSHelper.get(this.CSS);
	};

	Layout.prototype.explore = function explore(context, instance, items, key) {
		instance.children = exploreChildren(context, instance, items, instance.cached.children, key);
		if (instance.cache("children", instance.children)) instance.markShouldUpdate(context);
	};

	Layout.prototype.append = function append(result, r) {
		if (r != null) {
			if ((typeof r === "undefined" ? "undefined" : _typeof(r)) == "object") {
				if (r.atomic) result.push(r);
				else {
					var first = true;
					for (var k in r) {
						if (contentAppend(result, r[k], !first)) first = false;
					}
				}
			} else contentAppend(result, r);
		}
	};

	Layout.prototype.render = function render(context, instance, keyPrefix) {
		var _this2 = this;

		var result = [],
			child,
			r;
		for (var i = 0; i < instance.children.length; i++) {
			child = instance.children[i];
			r = child.vdom; //child.render(context, keyPrefix);
			if (child.widget.layout && child.widget.layout.useParentLayout && isArray(r.content)) {
				r.content.forEach(function(r) {
					return _this2.append(result, r);
				});
			} else this.append(result, r);
		}
		return result;
	};

	return Layout;
})(Component);

Layout.prototype.CSS = "cx";

Layout.namespace = "ui.layout.";

Layout.alias("default", Layout);

var Text = (function(_Widget) {
	inherits(Text, _Widget);

	function Text() {
		classCallCheck(this, Text);
		return possibleConstructorReturn(this, _Widget.apply(this, arguments));
	}

	Text.prototype.init = function init() {
		if (!this.value && (this.tpl || this.expr || this.bind))
			this.value = {
				tpl: this.tpl,
				expr: this.expr,
				bind: this.bind
			};
		_Widget.prototype.init.call(this);
	};

	Text.prototype.declareData = function declareData() {
		var _Widget$prototype$dec;

		(_Widget$prototype$dec = _Widget.prototype.declareData).call.apply(
			_Widget$prototype$dec,
			[
				this,
				{
					value: undefined
				}
			].concat(Array.prototype.slice.call(arguments))
		);
	};

	Text.prototype.render = function render(context, _ref, key) {
		var data = _ref.data;

		return data.value != null ? data.value : "";
	};

	return Text;
})(Widget);

Widget.alias("text", Text);

var Container = (function(_Widget) {
	inherits(Container, _Widget);

	function Container() {
		classCallCheck(this, Container);
		return possibleConstructorReturn(this, _Widget.apply(this, arguments));
	}

	Container.prototype.init = function init() {
		if (typeof this.ws !== "undefined") this.preserveWhitespace = this.ws;

		if (this.preserveWhitespace) this.trimWhitespace = false;

		var items = this.items || this.children || [];
		this.items = [];
		this.add(items);

		_Widget.prototype.init.call(this);

		this.layout = Layout.create(this.layout || {});
	};

	Container.prototype.explore = function explore(context, instance) {
		this.layout.explore(context, instance, this.items);
		_Widget.prototype.explore.call(this, context, instance);
	};

	Container.prototype.render = function render(context, instance, key) {
		return this.renderChildren(context, instance, key);
	};

	Container.prototype.renderChildren = function renderChildren(context, instance, keyPrefix) {
		return this.layout.render(context, instance, keyPrefix);
	};

	Container.prototype.clear = function clear() {
		this.items = [];
	};

	Container.prototype.add = function add() {
		var _this2 = this;

		for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
			args[_key] = arguments[_key];
		}

		args.forEach(function(a) {
			if (!a) return;
			if (isArray(a))
				a.forEach(function(c) {
					return _this2.add(c);
				});
			else if (isString(a)) {
				if (_this2.trimWhitespace) a = innerTextTrim(a);
				if (a) _this2.addText(a);
			} else if (a.isComponent) _this2.items.push(a);
			else _this2.add(Widget.create(a, _this2.itemDefaults));
		});
	};

	Container.prototype.addText = function addText(text) {
		if (this.plainText || text.indexOf("{") == -1 || text.indexOf("}") == -1)
			this.items.push(Widget.create(StaticText, { text: text }));
		else this.items.push(Widget.create(Text, { text: { tpl: text } }));
	};

	Container.prototype.find = function find(filter, options) {
		if (!options) options = {};

		if (!filter || !this.items) return [];

		var alias = filter;

		if (isString(filter))
			filter = function filter(w) {
				return w.componentAlias == alias;
			};

		if (filter.isComponentType)
			filter = function filter(w) {
				return w instanceof alias;
			};

		var results = [];

		for (var i = 0; i < this.items.length; i++) {
			var w = this.items[i];

			if (!w.initialized) w.init();

			if (filter(w)) {
				results.push(w);
				if (options.first) break;
			}

			if (w.find) results.push.apply(results, w.find(filter, options));
		}

		return results;
	};

	Container.prototype.findFirst = function findFirst$$1(filter, options) {
		return this.find(filter, _extends({}, options, { first: true }))[0];
	};

	return Container;
})(Widget);

Container.prototype.trimWhitespace = true;
Container.prototype.plainText = true;
Container.prototype.styled = false;

var PureContainer = (function(_Container) {
	inherits(PureContainer, _Container);

	function PureContainer() {
		classCallCheck(this, PureContainer);
		return possibleConstructorReturn(this, _Container.apply(this, arguments));
	}

	return PureContainer;
})(Container);

PureContainer.prototype.isPureContainer = true;

PureContainer.alias("pure-container", PureContainer);

var DataAdapter = (function(_Component) {
	inherits(DataAdapter, _Component);

	function DataAdapter() {
		classCallCheck(this, DataAdapter);
		return possibleConstructorReturn(this, _Component.apply(this, arguments));
	}

	DataAdapter.prototype.getRecords = function getRecords() {
		throw new Error("Abstract method");
	};

	DataAdapter.prototype.setFilter = function setFilter() {};

	DataAdapter.prototype.sort = function sort() {};

	return DataAdapter;
})(Component);

DataAdapter.prototype.recordName = "$record";
DataAdapter.prototype.indexName = "$index";
DataAdapter.prototype.immutable = false;

var ArrayAdapter = (function(_DataAdapter) {
	inherits(ArrayAdapter, _DataAdapter);

	function ArrayAdapter() {
		classCallCheck(this, ArrayAdapter);
		return possibleConstructorReturn(this, _DataAdapter.apply(this, arguments));
	}

	ArrayAdapter.prototype.init = function init() {
		this.map = new WeakMap();
	};

	ArrayAdapter.prototype.getRecords = function getRecords(context, instance, records, parentStore) {
		return this.mapRecords(context, instance, records, parentStore, this.recordsBinding);
	};

	ArrayAdapter.prototype.mapRecords = function mapRecords(context, instance, records, parentStore, recordsBinding) {
		var _this2 = this;

		var result = [];

		if (isArray(records))
			records.forEach(function(data, index) {
				if (_this2.filterFn && !_this2.filterFn(data)) return;

				var record = _this2.mapRecord(context, instance, data, parentStore, recordsBinding, index);

				result.push(record);
			});

		if (this.sorter) result = this.sorter(result);

		return result;
	};

	ArrayAdapter.prototype.mapRecord = function mapRecord(context, instance, data, parentStore, recordsBinding, index) {
		var recordStore = this.map.get(data);
		var writable = parentStore && recordsBinding;
		if (writable) {
			if (!recordStore)
				recordStore = new ExposedRecordView({
					store: parentStore,
					collectionBinding: recordsBinding,
					itemIndex: index,
					recordName: this.recordName,
					indexName: this.indexName,
					immutable: this.immutable
				});
			else {
				recordStore.setStore(parentStore);
				recordStore.setIndex(index);
			}
		} else {
			var _data;

			if (!recordStore)
				recordStore = new ReadOnlyDataView({
					store: parentStore,
					data: ((_data = {}), (_data[this.recordName] = data), (_data[this.indexName] = index), _data),
					immutable: this.immutable
				});
			else {
				recordStore.setStore(parentStore);
			}
		}

		if ((typeof data === "undefined" ? "undefined" : _typeof(data)) == "object") this.map.set(data, recordStore);

		return {
			store: recordStore,
			index: index,
			data: data,
			type: "data",
			key: this.keyField ? data[this.keyField] : index
		};
	};

	ArrayAdapter.prototype.setFilter = function setFilter(filterFn) {
		this.filterFn = filterFn;
	};

	ArrayAdapter.prototype.buildSorter = function buildSorter(sorters) {
		var _this3 = this;

		if (isArray(sorters) && sorters.length > 0) {
			if (
				sorters.every(function(x) {
					return x.field && x.value == null;
				})
			) {
				//if all sorters are based on record fields access data directly (faster)
				this.sorter = sorter(
					sorters.map(function(x) {
						if (x.field)
							return {
								value: { bind: x.field },
								direction: x.direction
							};
						return x;
					}),
					function(x) {
						return x.data;
					}
				);
			} else {
				//if some sorters use computed values, use store data object
				this.sorter = sorter(
					sorters.map(function(x) {
						if (x.field && x.value == null)
							return {
								value: { bind: _this3.recordName + "." + x.field },
								direction: x.direction
							};
						return x;
					}),
					function(x) {
						return x.store.getData();
					}
				);
			}
		} else {
			this.sorter = null;
		}
	};

	ArrayAdapter.prototype.sort = function sort(sorters) {
		this.buildSorter(sorters);
	};

	return ArrayAdapter;
})(DataAdapter);

var Repeater = (function(_Container) {
	inherits(Repeater, _Container);

	function Repeater() {
		classCallCheck(this, Repeater);
		return possibleConstructorReturn(this, _Container.apply(this, arguments));
	}

	Repeater.prototype.declareData = function declareData() {
		var _Container$prototype$;

		(_Container$prototype$ = _Container.prototype.declareData).call.apply(
			_Container$prototype$,
			[
				this,
				{
					records: undefined,
					sorters: undefined,
					sortField: undefined,
					sortDirection: undefined,
					filterParams: {
						structured: true
					}
				}
			].concat(Array.prototype.slice.call(arguments))
		);
	};

	Repeater.prototype.init = function init() {
		if (this.records && this.records.bind) this.recordsBinding = Binding.get(this.records.bind);

		if (this.recordAlias) this.recordName = this.recordAlias;

		if (this.indexAlias) this.indexName = this.indexAlias;

		this.dataAdapter = ArrayAdapter.create(
			_extends({}, this.dataAdapter, {
				recordName: this.recordName,
				indexName: this.indexName,
				keyField: this.keyField,
				immutable: this.immutable
			})
		);

		this.item = PureContainer.create({
			children: this.items || this.children
		});

		delete this.children;
		delete this.items;

		_Container.prototype.init.call(this);
	};

	Repeater.prototype.prepareData = function prepareData(context, instance) {
		var _this2 = this;

		var data = instance.data;

		if (data.sortField)
			data.sorters = [
				{
					field: data.sortField,
					direction: data.sortDirection || "ASC"
				}
			];
		this.dataAdapter.sort(data.sorters);
		var filter = null;
		if (this.onCreateFilter) filter = instance.invoke("onCreateFilter", data.filterParams, instance);
		else if (this.filter)
			filter = function filter(item) {
				return _this2.filter(item, data.filterParams);
			};
		this.dataAdapter.setFilter(filter);
		instance.mappedRecords = this.dataAdapter.mapRecords(
			context,
			instance,
			data.records,
			instance.store,
			this.recordsBinding
		);
		_Container.prototype.prepareData.call(this, context, instance);
	};

	Repeater.prototype.explore = function explore(context, instance, data) {
		var _this3 = this;

		var instances = [];
		instance.mappedRecords.forEach(function(record) {
			var subInstance = instance.getChild(context, _this3.item, record.key, record.store);
			var changed = subInstance.cache("data", record.data) || subInstance.cache("key", record.key);
			subInstance.record = record;
			if (_this3.cached && !changed && subInstance.visible && !subInstance.childStateDirty) {
				instances.push(subInstance);
				subInstance.shouldUpdate = false;
			} else if (subInstance.scheduleExploreIfVisible(context)) instances.push(subInstance);
		});
		instance.instances = instances;
	};

	Repeater.prototype.render = function render(context, instance, key) {
		return instance.instances.map(function(ins) {
			return ins.render(context, key + ":" + ins.record.key);
		});
	};

	return Repeater;
})(Container);

Repeater.prototype.recordName = "$record";
Repeater.prototype.indexName = "$index";
Repeater.prototype.cached = false;
Repeater.prototype.immutable = false;

Widget.alias("repeater", Repeater);

var Rescope = (function(_PureContainer) {
	inherits(Rescope, _PureContainer);

	function Rescope() {
		classCallCheck(this, Rescope);
		return possibleConstructorReturn(this, _PureContainer.apply(this, arguments));
	}

	Rescope.prototype.init = function init() {
		this.binding = Binding.get(this.bind);

		if (this.rootAlias) this.rootName = this.rootAlias;

		_PureContainer.prototype.init.call(this);
	};

	Rescope.prototype.initInstance = function initInstance(context, instance) {
		instance.store = new ZoomIntoPropertyView({
			store: instance.store,
			binding: this.binding,
			rootName: this.rootName
		});
		instance.setStore = function(store) {
			instance.store.setStore(store);
		};
	};

	return Rescope;
})(PureContainer);

Rescope.prototype.bind = "$page";
Rescope.prototype.rootName = "$root";

Widget.alias("rescope", Rescope);

var isBatching = 0;
var promiseSubscribers = new SubscriberList();

function batchUpdates(callback) {
	if (VDOM$1.DOM.unstable_batchedUpdates)
		VDOM$1.DOM.unstable_batchedUpdates(function() {
			isBatching++;
			try {
				callback();
			} finally {
				isBatching--;
			}
		});
	else callback();
}

function isBatchingUpdates() {
	return isBatching > 0;
}

function notifyBatchedUpdateStarting() {
	promiseSubscribers.execute(function(x) {
		x.pending++;
	});
}

function notifyBatchedUpdateCompleted() {
	promiseSubscribers.execute(function(x) {
		x.finished++;
		if (x.finished >= x.pending) x.complete(true);
	});
}

var updateId = 0;

function batchUpdatesAndNotify(callback, notifyCallback) {
	var timeout = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1000;

	var update = {
		id: ++updateId,
		pending: 0,
		finished: 0,
		done: false
	};

	update.unsubscribe = promiseSubscribers.subscribe(update);
	update.complete = function(success) {
		if (!update.done) {
			update.done = true;
			if (update.timer) clearInterval(update.timer);
			update.unsubscribe();
			notifyCallback(!!success);
		}
	};

	batchUpdates(callback);

	if (update.pending <= update.finished) update.complete(true);
	else update.timer = setTimeout(update.complete, timeout);
}

/*
*  Purpose of FocusManager is to provide focusout notifications.
*  IE and Firefox do not provide relatedTarget info in blur events which makes it impossible
*  to determine if focus went outside or stayed inside the component.
*/

var subscribers = new SubscriberList();
var intervalId = void 0;

var lastActiveElement = null;
var pending = false;

var FocusManager = (function() {
	function FocusManager() {
		classCallCheck(this, FocusManager);
	}

	FocusManager.subscribe = function subscribe(callback) {
		return subscribers.subscribe(callback);
	};

	FocusManager.onFocusOut = function onFocusOut(el, callback) {
		var active = isSelfOrDescendant(el, document.activeElement);
		return this.subscribe(function(focusedEl) {
			if (!active) active = isSelfOrDescendant(el, document.activeElement);
			else if (!isSelfOrDescendant(el, focusedEl)) {
				active = false;
				callback(focusedEl);
			}
		});
	};

	FocusManager.oneFocusOut = function oneFocusOut(el, callback) {
		this.nudge();
		var off = this.subscribe(function(focusedEl) {
			if (!isSelfOrDescendant(el, focusedEl)) {
				callback(focusedEl);
				off();
			}
		});
		return off;
	};

	FocusManager.nudge = function nudge() {
		if (typeof document !== "undefined" && document.activeElement !== lastActiveElement) {
			if (!pending) {
				pending = true;
				setTimeout(function() {
					pending = false;
					if (document.activeElement !== lastActiveElement) {
						lastActiveElement = document.activeElement;
						batchUpdates(function() {
							subscribers.notify(lastActiveElement);
						});
					}
				}, 0);
			}
		}
	};

	FocusManager.focus = function focus(el) {
		el.focus();
		this.nudge();
	};

	FocusManager.focusFirst = function focusFirst(el) {
		var focusable = findFirst(el, isFocusable);
		if (focusable) this.focus(focusable);
		return focusable;
	};

	FocusManager.focusFirstChild = function focusFirstChild(el) {
		var focusable = findFirstChild(el, isFocusable);
		if (focusable) this.focus(focusable);
		return focusable;
	};

	FocusManager.focusNext = function focusNext(el) {
		var next = el,
			skip = true;
		do {
			if (!skip) {
				var focusable = this.focusFirst(next);
				if (focusable) return focusable;
			}

			if (next.nextSibling) {
				next = next.nextSibling;
				skip = false;
			} else {
				next = next.parentNode;
				skip = true;
			}
		} while (next);
	};

	FocusManager.setInterval = (function(_setInterval) {
		function setInterval(_x) {
			return _setInterval.apply(this, arguments);
		}

		setInterval.toString = function() {
			return _setInterval.toString();
		};

		return setInterval;
	})(function(interval) {
		clearInterval(intervalId);
		intervalId = setInterval(this.nudge.bind(this), interval);
	});

	return FocusManager;
})();

FocusManager.setInterval(300);

function oneFocusOut(component, el, callback) {
	if (!component.oneFocusOut)
		component.oneFocusOut = FocusManager.oneFocusOut(el, function(focus) {
			delete component.oneFocusOut;
			callback(focus);
		});
}

function offFocusOut(component) {
	if (component.oneFocusOut) {
		component.oneFocusOut();
		delete component.oneFocusOut;
	}
}

function preventFocus(e) {
	//Focus can be prevented only on mousedown event. On touchstart should not call
	//preventDefault as it prevents scrolling
	if (e.type !== "mousedown") return;

	e.preventDefault();

	//unfocus activeElement
	if (e.currentTarget !== document.activeElement && !document.activeElement.contains(e.currentTarget)) {
		//force field validation on outside click, however, preserve active window or dropdown menu
		var focusableParent = closestParent(document.activeElement, isFocusable) || document.body;
		if (focusableParent === document.body) document.activeElement.blur();
		else focusableParent.focus();

		FocusManager.nudge();
	}
}

function preventFocusOnTouch(e) {
	var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

	if (force || isTouchEvent()) preventFocus(e);
}

if (module.hot) {
	module.hot.accept();
	module.hot.dispose(function() {
		clearInterval(intervalId);
	});
}

var subscribers$1 = new SubscriberList();

var ResizeManager = (function() {
	function ResizeManager() {
		classCallCheck(this, ResizeManager);
	}

	ResizeManager.subscribe = function subscribe(callback) {
		return subscribers$1.subscribe(callback);
	};

	ResizeManager.notify = function notify() {
		batchUpdates(function() {
			subscribers$1.notify();
		});
	};

	return ResizeManager;
})();

if (typeof window != "undefined")
	window.addEventListener("resize", function() {
		return ResizeManager.notify();
	});

var lastZIndex = 10000;

var ZIndexManager = (function() {
	function ZIndexManager() {
		classCallCheck(this, ZIndexManager);
	}

	ZIndexManager.next = function next() {
		return ++lastZIndex;
	};

	return ZIndexManager;
})();

var contents = {};
var localizations = {};
var overrides = {};
var defaults$1 = {};
var _trackDefaults = false;

var Localization = (function() {
	function Localization() {
		classCallCheck(this, Localization);
	}

	Localization.register = function register(key) {
		var _this = this;

		return function(type) {
			_this.registerPrototype(key, type);
			return type;
		};
	};

	Localization.registerPrototype = function registerPrototype(key, type) {
		contents[key] = type.prototype;
		if (overrides[key]) this.override(key, overrides[key]);
	};

	Localization.trackDefaults = function trackDefaults() {
		_trackDefaults = true;
	};

	Localization.restoreDefaults = function restoreDefaults() {
		for (var type in defaults$1) {
			var proto = contents[type];
			if (!proto) continue;
			var d = defaults$1[type];
			for (var key in d) {
				proto[key] = d[key];
			}
		}
		defaults$1 = {};
	};

	Localization.override = function override(key, values) {
		overrides[key] = values;
		var p = contents[key];
		if (p) {
			if (_trackDefaults && !defaults$1[key]) {
				var d = (defaults$1[key] = {});
				for (var _key in values) {
					d[_key] = p[_key];
				}
			}
			Object.assign(p, values);
		}
	};

	Localization.localize = function localize(culture, key, values) {
		var l = localizations[culture];
		if (!l) l = localizations[culture] = {};
		l[key] = _extends({}, l[key], values);
	};

	Localization.setCulture = function setCulture(culture) {
		var l = localizations[culture];
		if (l) {
			for (var key in l) {
				var content = contents[key];
				if (content) Object.assign(content, l[key]);
			}
		}
	};

	return Localization;
})();

var culture = "en";
var cultureCache = {};
var defaultCurrency = "USD";

var Culture = (function() {
	function Culture() {
		classCallCheck(this, Culture);
	}

	Culture.setCulture = function setCulture(cultureCode) {
		culture = cultureCode;
		cultureCache = {};
		Localization.setCulture(cultureCode);
		GlobalCacheIdentifier.change();
	};

	Culture.setDefaultCurrency = function setDefaultCurrency(currencyCode) {
		defaultCurrency = currencyCode;
		GlobalCacheIdentifier.change();
	};

	Culture.getNumberCulture = function getNumberCulture() {
		if (!cultureCache.numberCulture) cultureCache.numberCulture = new NumberCulture(culture);
		return cultureCache.numberCulture;
	};

	Culture.getDateTimeCulture = function getDateTimeCulture() {
		if (!cultureCache.dateCulture) cultureCache.dateCulture = new DateTimeCulture(culture);
		return cultureCache.dateCulture;
	};

	createClass(Culture, null, [
		{
			key: "defaultCurrency",
			get: function get$$1() {
				return defaultCurrency;
			}
		},
		{
			key: "culture",
			get: function get$$1() {
				return culture;
			}
		}
	]);
	return Culture;
})();

var Format$1 = Format;

var cultureSensitiveFormatsRegistered = false;

function enableCultureSensitiveFormatting() {
	if (cultureSensitiveFormatsRegistered) return;

	cultureSensitiveFormatsRegistered = true;

	Format.registerFactory(["number", "n"], function(format, minimumFractionDigits, maximumFractionDigits) {
		var culture = Culture.getNumberCulture();

		var formatter = culture.getFormatter(resolveMinMaxFractionDigits(minimumFractionDigits, maximumFractionDigits));

		return function(value) {
			return formatter.format(value);
		};
	});

	Format.registerFactory("currency", function(format, currency, minimumFractionDigits, maximumFractionDigits) {
		var culture = Culture.getNumberCulture();
		currency = currency || Culture.defaultCurrency;

		var formatter = culture.getFormatter(
			_extends(
				{
					style: "currency",
					currency: currency
				},
				resolveMinMaxFractionDigits(minimumFractionDigits, maximumFractionDigits)
			)
		);

		return function(value) {
			return formatter.format(value);
		};
	});

	Format.registerFactory(["percentage", "p", "%"], function(format, minimumFractionDigits, maximumFractionDigits) {
		var culture = Culture.getNumberCulture();
		var formatter = culture.getFormatter(
			_extends(
				{
					style: "percent"
				},
				resolveMinMaxFractionDigits(minimumFractionDigits, maximumFractionDigits)
			)
		);
		return function(value) {
			return formatter.format(value);
		};
	});

	Format.registerFactory(["percentSign", "ps"], function(format, minimumFractionDigits, maximumFractionDigits) {
		var culture = Culture.getNumberCulture();
		var formatter = culture.getFormatter(
			_extends(
				{
					style: "percent"
				},
				resolveMinMaxFractionDigits(minimumFractionDigits, maximumFractionDigits)
			)
		);
		return function(value) {
			return formatter.format(value / 100);
		};
	});

	Format.registerFactory(["date", "d"], function() {
		var culture = Culture.getDateTimeCulture();
		var formatter = culture.getFormatter();
		return function(value) {
			return formatter.format(new Date(value));
		};
	});

	Format.registerFactory(["time", "t"], function() {
		var culture = Culture.getDateTimeCulture();
		var formatter = culture.getFormatter({
			hour: "numeric",
			minute: "numeric",
			second: "numeric"
		});
		return function(value) {
			return formatter.format(new Date(value));
		};
	});

	Format.registerFactory(["datetime", "dt"], function(fmt) {
		var format = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "yyyyMd hhmm";

		var culture = Culture.getDateTimeCulture();
		var formatter = culture.getFormatter(format);
		return function(value) {
			return formatter.format(new Date(value));
		};
	});

	GlobalCacheIdentifier.change();
}

var instanceId = 1000;
var Instance = (function() {
	function Instance(widget, key) {
		classCallCheck(this, Instance);

		this.widget = widget;
		this.key = key;
		this.id = String(++instanceId);
		this.cached = {};
	}

	Instance.prototype.setStore = function setStore(store) {
		this.store = store;
	};

	Instance.prototype.init = function init(context) {
		//widget is initialized when first instance is initialized
		if (!this.widget.initialized) {
			this.widget.init();
			this.widget.initialized = true;
		}

		if (!this.dataSelector) {
			this.widget.selector.init(this.store);
			this.dataSelector = this.widget.selector.createStoreSelector();
		}

		if (this.widget.controller)
			this.controller = Controller.create(this.widget.controller, {
				widget: this.widget,
				instance: this,
				store: this.store
			});

		this.widget.initInstance(context, this);
		this.widget.initState(context, this);

		if (
			this.widget.exploreCleanup ||
			this.widget.outerLayout ||
			this.widget.isContent ||
			this.widget.controller ||
			this.widget.prepareCleanup
		)
			this.needsExploreCleanup = true;
		if (this.widget.prepare || this.widget.controller) this.needsPrepare = true;
		if (this.widget.cleanup || this.widget.controller) this.needsCleanup = true;
		this.initialized = true;
	};

	Instance.prototype.checkVisible = function checkVisible(context) {
		if (!this.initialized) this.init(context);

		var wasVisible = this.visible;
		this.rawData = this.dataSelector(this.store);
		this.visible = this.widget.checkVisible(context, this, this.rawData);
		this.explored = false;
		this.prepared = false;

		if (!this.visible && wasVisible) this.destroy();

		return this.visible;
	};

	Instance.prototype.scheduleExploreIfVisible = function scheduleExploreIfVisible(context) {
		if (this.checkVisible(context)) {
			context.exploreStack.push(this);
			return true;
		}
		return false;
	};

	Instance.prototype.cache = function cache(key, value) {
		var oldValue = this.cached[key];
		if (oldValue === value) return false;

		if (!this.cacheList) this.cacheList = {};
		this.cacheList[key] = value;
		return true;
	};

	Instance.prototype.markShouldUpdate = function markShouldUpdate(context) {
		var ins = this;
		var renderList = this.renderList;
		var index = renderList.length;
		var startIndices = void 0;

		//notify all parents that child state change to bust up caching
		while (ins && !ins.shouldUpdate && ins.explored) {
			if (ins.renderList !== renderList) {
				if (!startIndices)
					startIndices = [
						{
							list: renderList,
							index: index
						}
					];
				if (
					startIndices.length == 1 ||
					startIndices.findIndex(function(l) {
						return l.list === renderList;
					}) < 0
				) {
					startIndices.push({
						list: ins.renderList,
						index: ins.renderList.length
					});
				}
				renderList = ins.renderList;
			}
			ins.shouldUpdate = true;
			renderList.push(ins);
			ins = ins.widget.isContent
				? ins.contentPlaceholder
				: ins.parent.outerLayout === ins ? ins.parent.parent : ins.parent;
		}

		if (!startIndices) reverseSlice(renderList, index);
		else
			for (var i = 0; i < startIndices.length; i++) {
				reverseSlice(startIndices[i].list, startIndices[i].index);
			}
	};

	Instance.prototype.explore = function explore(context) {
		if (!this.visible) throw new Error("Explore invisible!");

		if (this.explored) {
			if (this.widget.prepareCleanup) context.prepareList.push(this);

			if (this.widget.exploreCleanup) this.widget.exploreCleanup(context, this);

			if (this.popNextRenderList) context.getNextRenderList();

			if (this.parent.outerLayout === this) {
				context.getPrevRenderList();
				context.popNamedValue("content", "body");
			}

			if (this.widget.controller) context.pop("controller");

			return;
		}

		this.explored = true;
		if (this.needsExploreCleanup) context.exploreStack.push(this);

		if (this.needsPrepare) context.prepareList.push(this);
		else this.prepared = true;

		if (this.needsCleanup) context.cleanupList.push(this);

		this.cacheList = null;

		if (this.instanceCache) this.instanceCache.mark();

		//controller may reconfigure the widget and need to go before shouldUpdate calculation
		this.parentOptions = context.parentOptions;

		if (!this.controller) {
			if (context.controller) this.controller = context.controller;
			else if (this.parent.controller) this.controller = this.parent.controller;
		}

		this.destroyTracked = false;

		if (this.controller) {
			if (this.widget.controller) {
				context.push("controller", this.controller);
				this.controller.explore(context);
				if (this.controller.onDestroy) this.trackDestroy();
			}
		}

		if (this.widget.onDestroy) this.trackDestroy();

		this.renderList = context.getCurrentRenderList();

		var shouldUpdate =
			this.rawData !== this.cached.rawData ||
			this.state !== this.cached.state ||
			this.widget.version !== this.cached.widgetVersion ||
			this.cached.globalCacheIdentifier !== GlobalCacheIdentifier.get();

		if (shouldUpdate) {
			this.data = _extends({}, this.rawData);
			this.widget.prepareData(context, this);
			debug(processDataFlag, this.widget);
		}

		if (this.widget.isContent) {
			this.popNextRenderList = false;
			this.contentPlaceholder = context.contentPlaceholder && context.contentPlaceholder[this.widget.putInto];
			if (this.contentPlaceholder) context.contentPlaceholder[this.widget.putInto](this);
			else {
				context.pushNamedValue("content", this.widget.putInto, this);
				this.renderList = context.getPrevRenderList();
				this.popNextRenderList = true;
			}
		}

		if (this.parent.outerLayout === this) {
			this.renderList = context.getNextRenderList();
			context.pushNamedValue("content", "body", this.parent);
		}

		//onExplore might set the outer layout
		if (this.widget.onExplore) this.widget.onExplore(context, this);

		if (this.widget.outerLayout) {
			this.outerLayout = this.getChild(context, this.widget.outerLayout, null, this.store);
			this.outerLayout.scheduleExploreIfVisible(context);
			this.renderList = context.insertRenderList();
		}

		if (shouldUpdate || this.childStateDirty || !this.widget.memoize) {
			this.shouldUpdate = false;
			this.markShouldUpdate(context);
		} else {
			this.shouldUpdate = false;
		}

		this.widget.explore(context, this, this.data);

		//because tree exploration uses depth-first search using a stack,
		//helpers need to be registered last in order to be processed first

		if (this.widget.helpers) {
			this.helpers = {};
			for (var cmp in this.widget.helpers) {
				var helper = this.widget.helpers[cmp];
				if (helper) {
					var ins = this.getChild(context, helper);
					if (ins.scheduleExploreIfVisible(context)) this.helpers[cmp] = ins;
				}
			}
		}
	};

	Instance.prototype.prepare = function prepare(context) {
		if (!this.visible) throw new Error("Prepare invisible!");

		if (this.prepared) {
			if (this.widget.prepareCleanup) this.widget.prepareCleanup(context, this);
			return;
		}

		this.prepared = true;
		if (this.widget.prepare) this.widget.prepare(context, this);

		if (this.widget.controller && this.controller.prepare) this.controller.prepare(context);
	};

	Instance.prototype.render = function render(context) {
		if (!this.visible) throw new Error("Render invisible!");

		if (this.shouldUpdate) {
			debug(renderFlag, this.widget, this.key);
			var vdom = renderResultFix(this.widget.render(context, this, this.key));
			if (this.widget.isContent || this.outerLayout) this.contentVDOM = vdom;
			else this.vdom = vdom;
		}

		if (this.cacheList)
			for (var key in this.cacheList) {
				this.cached[key] = this.cacheList[key];
			}
		this.cacheList = null;

		this.cached.rawData = this.rawData;
		this.cached.state = this.state;
		this.cached.widgetVersion = this.widget.version;
		this.cached.globalCacheIdentifier = GlobalCacheIdentifier.get();
		this.childStateDirty = false;

		if (this.instanceCache) this.instanceCache.sweep();

		if (this.parent.outerLayout === this) {
			//if outer layouts are chained we need to find the originating element (last element with OL set)
			var parent = this.parent;
			while (parent.parent.outerLayout == parent) {
				parent = parent.parent;
			}
			parent.vdom = this.vdom;
		}

		return this.vdom;
	};

	Instance.prototype.cleanup = function cleanup(context) {
		if (this.widget.controller && this.controller.cleanup) this.controller.cleanup(context);

		if (this.widget.cleanup) this.widget.cleanup(context, this);
	};

	Instance.prototype.trackDestroy = function trackDestroy() {
		if (!this.destroyTracked) {
			this.destroyTracked = true;
			if (this.parent) this.parent.trackDestroyableChild(this);
		}
	};

	Instance.prototype.trackDestroyableChild = function trackDestroyableChild(child) {
		this.instanceCache.trackDestroy(child);
		this.trackDestroy();
	};

	Instance.prototype.destroy = function destroy() {
		if (this.instanceCache) {
			this.instanceCache.destroy();
			delete this.instanceCache;
		}

		if (this.destroyTracked) {
			debug(destroyFlag, this);

			if (this.widget.onDestroy) this.widget.onDestroy(this);

			if (this.widget.controller && this.controller && this.controller.onDestroy) this.controller.onDestroy();

			this.destroyTracked = false;
		}
	};

	Instance.prototype.setState = function setState(state) {
		var _this = this;

		var skip = this.state;
		if (this.state)
			for (var k in state) {
				if (this.state[k] !== state[k]) {
					skip = false;
					break;
				}
			}

		if (skip) return;

		this.cached.state = this.state;
		this.state = Object.assign({}, this.state, state);
		var parent = this.parent;
		//notify all parents that child state change to bust up caching
		while (parent) {
			parent.childStateDirty = true;
			parent = parent.parent;
		}
		batchUpdates(function() {
			_this.store.notify();
		});
	};

	Instance.prototype.set = function set$$1(prop, value) {
		var _this2 = this;

		var setter = this.setters && this.setters[prop];
		if (setter) {
			setter(value);
			return true;
		}

		var p = this.widget[prop];
		if (p && (typeof p === "undefined" ? "undefined" : _typeof(p)) == "object") {
			if (p.debounce) {
				this.definePropertySetter(
					prop,
					debounce(function(value) {
						return _this2.doSet(prop, value);
					}, p.debounce)
				);
				this.set(prop, value);
				return true;
			}

			if (p.throttle) {
				this.definePropertySetter(
					prop,
					throttle(function(value) {
						return _this2.doSet(prop, value);
					}, p.throttle)
				);
				this.set(prop, value);
				return true;
			}
		}

		return this.doSet(prop, value);
	};

	Instance.prototype.definePropertySetter = function definePropertySetter(prop, setter) {
		if (!this.setters) this.setters = {};
		this.setters[prop] = setter;
	};

	Instance.prototype.doSet = function doSet(prop, value) {
		var _this3 = this;

		var changed = false;
		batchUpdates(function() {
			var p = _this3.widget[prop];
			if (p && (typeof p === "undefined" ? "undefined" : _typeof(p)) == "object") {
				if (p.set) {
					if (isFunction(p.set)) {
						p.set(value, _this3);
						changed = true;
					} else if (isString(p.set)) {
						_this3.controller[p.set](value, _this3);
						changed = true;
					}
				} else if (p.action) {
					var action = p.action(value, _this3);
					_this3.store.dispatch(action);
					changed = true;
				} else if (p.bind) {
					changed = _this3.store.set(p.bind, value);
				}
			}
		});
		return changed;
	};

	Instance.prototype.replaceState = function replaceState(state) {
		this.cached.state = this.state;
		this.state = state;
		this.store.notify();
	};

	Instance.prototype.getInstanceCache = function getInstanceCache() {
		if (!this.instanceCache)
			this.instanceCache = new InstanceCache(this, this.widget.isPureContainer ? this.key : null);
		return this.instanceCache;
	};

	Instance.prototype.clearChildrenCache = function clearChildrenCache() {
		if (this.instanceCache) this.instanceCache.destroy();
	};

	Instance.prototype.getChild = function getChild(context, widget, key, store) {
		return this.getInstanceCache().getChild(widget, store || this.store, key);
	};

	Instance.prototype.prepareRenderCleanupChild = function prepareRenderCleanupChild(widget, store, keyPrefix, options) {
		return widget.prepareRenderCleanup(store || this.store, options, keyPrefix, this);
	};

	Instance.prototype.getJsxEventProps = function getJsxEventProps() {
		var _this4 = this;

		var widget = this.widget;

		if (!isArray(widget.jsxAttributes)) return null;

		var props = {};
		widget.jsxAttributes.forEach(function(attr) {
			if (attr.indexOf("on") == 0 && attr.length > 2)
				props[attr] = function(e) {
					return _this4.invoke(attr, e, _this4);
				};
		});
		return props;
	};

	Instance.prototype.getCallback = function getCallback(methodName) {
		var scope = this.widget;
		var method = scope[methodName];

		if (typeof method === "string") {
			if (!this.controller)
				throw new Error(
					'Cannot invoke controller method "' + methodName + '" as controller is not assigned to the widget.'
				);

			var at = this;
			while (at != null && at.controller && !at.controller[method]) {
				at = at.parent;
			}
			if (!at || !at.controller || !at.controller[method])
				throw new Error(
					'Cannot invoke controller method "' +
						methodName +
						'". The method cannot be found in any of the assigned controllers.'
				);

			scope = at.controller;
			method = scope[method];
		}

		if (typeof method !== "function")
			throw new Error("Cannot invoke callback method " + methodName + " as assigned value is not a function.");

		return method.bind(scope);
	};

	Instance.prototype.invoke = function invoke(methodName) {
		for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
			args[_key - 1] = arguments[_key];
		}

		return this.getCallback(methodName).apply(null, args);
	};

	return Instance;
})();

function renderResultFix(res) {
	return res != null && isDefined(res.content) ? res : { content: res };
}

var InstanceCache = (function() {
	function InstanceCache(parent, keyPrefix) {
		classCallCheck(this, InstanceCache);

		this.children = {};
		this.parent = parent;
		this.marked = {};
		this.monitored = null;
		this.keyPrefix = keyPrefix != null ? keyPrefix + "-" : "";
	}

	InstanceCache.prototype.getChild = function getChild(widget, store, key) {
		var k = this.keyPrefix + (key != null ? key : widget.widgetId);
		var instance = this.children[k];

		if (!instance || (!instance.visible && (instance.widget.controller || instance.widget.onInit))) {
			instance = new Instance(widget, k);
			instance.parent = this.parent;
			this.children[k] = instance;
		}
		if (instance.store !== store) instance.setStore(store);
		this.marked[k] = instance;
		return instance;
	};

	InstanceCache.prototype.mark = function mark() {
		this.marked = {};
	};

	InstanceCache.prototype.trackDestroy = function trackDestroy(instance) {
		if (!this.monitored) this.monitored = {};
		this.monitored[instance.key] = instance;
	};

	InstanceCache.prototype.destroy = function destroy() {
		this.children = {};
		this.marked = {};

		if (!this.monitored) return;

		for (var key in this.monitored) {
			this.monitored[key].destroy();
		}

		this.monitored = null;
	};

	InstanceCache.prototype.sweep = function sweep() {
		this.children = this.marked;
		if (!this.monitored) return;
		var activeCount = 0;
		for (var key in this.monitored) {
			var monitoredChild = this.monitored[key];
			var child = this.children[key];
			if (child !== monitoredChild || !monitoredChild.visible) {
				monitoredChild.destroy();
				delete this.monitored[key];
				if (child === monitoredChild) delete this.children[key];
			} else activeCount++;
		}
		if (activeCount === 0) this.monitored = null;
	};

	return InstanceCache;
})();

var Cx = (function(_VDOM$Component) {
	inherits(Cx, _VDOM$Component);

	function Cx(props) {
		classCallCheck(this, Cx);

		var _this = possibleConstructorReturn(this, _VDOM$Component.call(this, props));

		if (props.instance) {
			_this.widget = props.instance.widget;
			_this.store = props.instance.store;
		} else {
			_this.widget = Widget.create(props.widget || props.items[0]);

			if (props.parentInstance) {
				_this.parentInstance = props.parentInstance;
				_this.store = props.store || _this.parentInstance.store;
			} else {
				_this.parentInstance = new Instance(_this.widget, 0);
				_this.store = props.store;
			}

			if (!_this.store) throw new Error("Cx component requires store.");
		}

		if (props.subscribe) {
			_this.unsubscribe = _this.store.subscribe(_this.update.bind(_this));
			_this.state = { data: _this.store.getData() };
		}

		_this.flags = {};
		_this.renderCount = 0;
		return _this;
	}

	Cx.prototype.componentWillReceiveProps = function componentWillReceiveProps(props) {
		//TODO: Switch to new props
		if (props.subscribe) {
			var data = this.store.getData();
			if (data !== this.state.data) this.setState({ data: this.store.getData() });
		}
	};

	Cx.prototype.render = function render() {
		if (!this.widget) return null;

		var instance = this.props.instance || this.parentInstance.getChild(this.context, this.widget, null, this.store);

		return VDOM$1.createElement(CxContext, {
			instance: instance,
			flags: this.flags,
			options: this.props.options,
			buster: ++this.renderCount,
			contentFactory: this.props.contentFactory
		});
	};

	Cx.prototype.componentDidMount = function componentDidMount() {
		this.componentDidUpdate();

		if (this.props.options && this.props.options.onPipeUpdate) this.props.options.onPipeUpdate(this.update.bind(this));
	};

	Cx.prototype.componentDidUpdate = function componentDidUpdate() {
		if (this.flags.dirty) {
			this.update();
		}
	};

	Cx.prototype.update = function update() {
		var _this2 = this;

		var data = this.store.getData();
		debug(appDataFlag, data);
		if (this.flags.preparing) this.flags.dirty = true;
		else if (isBatchingUpdates() || this.props.immediate) {
			notifyBatchedUpdateStarting();
			this.setState({ data: data }, notifyBatchedUpdateCompleted);
		} else {
			//in standard mode sequential store commands are batched
			if (!this.pendingUpdateTimer) {
				notifyBatchedUpdateStarting();
				this.pendingUpdateTimer = setTimeout(function() {
					delete _this2.pendingUpdateTimer;
					_this2.setState({ data: data }, notifyBatchedUpdateCompleted);
				}, 0);
			}
		}
	};

	Cx.prototype.componentWillUnmount = function componentWillUnmount() {
		if (this.pendingUpdateTimer) clearTimeout(this.pendingUpdateTimer);
		if (this.unsubscribe) this.unsubscribe();
		if (this.props.options && this.props.options.onPipeUpdate) this.props.options.onPipeUpdate(null);
	};

	Cx.prototype.shouldComponentUpdate = function shouldComponentUpdate(props, state) {
		return (
			state !== this.state ||
			!props.params ||
			!shallowEquals(props.params, this.props.params) ||
			props.instance !== this.props.instance ||
			props.widget !== this.props.widget ||
			props.store !== this.props.store ||
			props.parentInstance !== this.props.parentInstance
		);
	};

	return Cx;
})(VDOM$1.Component);

var CxContext = (function(_VDOM$Component2) {
	inherits(CxContext, _VDOM$Component2);

	function CxContext(props) {
		classCallCheck(this, CxContext);

		var _this3 = possibleConstructorReturn(this, _VDOM$Component2.call(this, props));

		_this3.renderCount = 0;
		_this3.componentWillReceiveProps(props);
		return _this3;
	}

	CxContext.prototype.componentWillReceiveProps = function componentWillReceiveProps(props) {
		this.timings = {
			start: now()
		};

		var instance = props.instance,
			options = props.options,
			contentFactory = props.contentFactory;

		var count = 0,
			visible = void 0,
			context = void 0;

		if (this.props.instance !== instance && this.props.instance.destroyTracked) this.props.instance.destroy();

		this.props.flags.preparing = true;

		do {
			context = new RenderingContext(options);
			this.props.flags.dirty = false;
			visible = instance.scheduleExploreIfVisible(context);
			if (visible) {
				while (context.exploreStack.length > 0) {
					var inst = context.exploreStack.pop();
					inst.explore(context);
				}
			}
		} while (visible && this.props.flags.dirty && ++count <= 3 && Widget.optimizePrepare);

		if (visible) {
			this.timings.afterExplore = now();
			for (var i = 0; i < context.prepareList.length; i++) {
				context.prepareList[i].prepare(context);
			}
			this.timings.afterPrepare = now();

			//console.log(context.prepareList);
			//console.log(context.renderStack);

			//walk in reverse order so children get rendered first
			var renderLists = context.getRenderLists();
			for (var j = 0; j < renderLists.length; j++) {
				for (var _i = renderLists[j].length - 1; _i >= 0; _i--) {
					renderLists[j][_i].render(context);
				}
			}

			this.content = getContent(instance.vdom);
			if (contentFactory) this.content = contentFactory({ children: this.content });
			this.timings.afterRender = now();
			for (var _i2 = 0; _i2 < context.cleanupList.length; _i2++) {
				context.cleanupList[_i2].cleanup(context);
			}
		} else {
			this.content = null;
			this.timings.afterExplore = this.timings.afterPrepare = this.timings.afterRender = now();
		}

		this.timings.beforeVDOMRender = now();
		this.props.flags.preparing = false;
		this.props.flags.rendering = true;
		this.renderingContext = context;
	};

	CxContext.prototype.render = function render() {
		return this.content;
	};

	CxContext.prototype.componentDidMount = function componentDidMount() {
		this.componentDidUpdate();
	};

	CxContext.prototype.componentDidUpdate = function componentDidUpdate() {
		this.props.flags.rendering = false;
		this.timings.afterVDOMRender = now();

		//let {instance} = this.props;
		//instance.cleanup(this.renderingContext);

		this.timings.afterCleanup = now();
		this.renderCount++;

		if (process.env.NODE_ENV !== "production") {
			var _timings = this.timings,
				start = _timings.start,
				beforeVDOMRender = _timings.beforeVDOMRender,
				afterVDOMRender = _timings.afterVDOMRender,
				afterPrepare = _timings.afterPrepare,
				afterExplore = _timings.afterExplore,
				afterRender = _timings.afterRender,
				afterCleanup = _timings.afterCleanup;

			Timing.log(
				vdomRenderFlag,
				this.renderCount,
				"cx",
				(beforeVDOMRender - start + afterCleanup - afterVDOMRender).toFixed(2) + "ms",
				"vdom",
				(afterVDOMRender - beforeVDOMRender).toFixed(2) + "ms"
			);

			Timing.log(
				appLoopFlag,
				this.renderCount,
				this.renderingContext.options.name || "main",
				"total",
				(afterCleanup - start).toFixed(1) + "ms",
				"explore",
				(afterExplore - start).toFixed(1) + "ms",
				"prepare",
				(afterPrepare - afterExplore).toFixed(1),
				"render",
				(afterRender - afterPrepare).toFixed(1),
				"vdom",
				(afterVDOMRender - beforeVDOMRender).toFixed(1),
				"cleanup",
				(afterCleanup - afterVDOMRender).toFixed(1)
			);
		}
	};

	CxContext.prototype.componentWillUnmount = function componentWillUnmount() {
		var instance = this.props.instance;

		if (instance.destroyTracked) instance.destroy();
	};

	return CxContext;
})(VDOM$1.Component);

var ContentResolver = (function(_PureContainer) {
	inherits(ContentResolver, _PureContainer);

	function ContentResolver() {
		classCallCheck(this, ContentResolver);
		return possibleConstructorReturn(this, _PureContainer.apply(this, arguments));
	}

	ContentResolver.prototype.declareData = function declareData() {
		var _PureContainer$protot;

		return (_PureContainer$protot = _PureContainer.prototype.declareData).call.apply(
			_PureContainer$protot,
			[this].concat(Array.prototype.slice.call(arguments), [
				{
					params: { structured: true },
					loading: undefined
				}
			])
		);
	};

	ContentResolver.prototype.init = function init() {
		_PureContainer.prototype.init.call(this);
		this.initialItems = this.items;
	};

	ContentResolver.prototype.initInstance = function initInstance(context, instance) {
		instance.content = this.initialItems;
	};

	ContentResolver.prototype.prepareData = function prepareData(context, instance) {
		var _this2 = this;

		var data = instance.data;

		if (data.params !== instance.cachedParams && this.onResolve) {
			instance.cachedParams = data.params;
			var content = instance.invoke("onResolve", data.params, instance);
			if (isPromise(content)) {
				instance.set("loading", true);
				content.then(function(cnt) {
					_this2.setContent(instance, cnt);
					instance.setState({ cacheBuster: {} });
					instance.set("loading", false);
				});
			} else this.setContent(instance, content);
		}
	};

	ContentResolver.prototype.setContent = function setContent(instance, content) {
		if (content) {
			this.items = [];
			switch (this.mode) {
				case "prepend":
					this.add(content);
					this.add(this.initialItems);
					break;

				case "append":
					this.add(content);
					this.add(this.initialItems);
					break;

				case "replace":
					this.add(content);
					break;
			}
			instance.content = this.items;
		} else instance.content = this.initialItems;

		this.items = this.initialItems;
	};

	ContentResolver.prototype.explore = function explore(context, instance) {
		this.items = instance.content;
		_PureContainer.prototype.explore.call(this, context, instance);
	};

	return ContentResolver;
})(PureContainer);

ContentResolver.prototype.mode = "replace";
ContentResolver.prototype.params = null;

var IsolatedScope = (function(_PureContainer) {
	inherits(IsolatedScope, _PureContainer);

	function IsolatedScope() {
		classCallCheck(this, IsolatedScope);
		return possibleConstructorReturn(this, _PureContainer.apply(this, arguments));
	}

	IsolatedScope.prototype.declareData = function declareData() {
		var _PureContainer$protot;

		return (_PureContainer$protot = _PureContainer.prototype.declareData).call.apply(
			_PureContainer$protot,
			[this].concat(Array.prototype.slice.call(arguments), [
				{
					data: { structured: true }
				}
			])
		);
	};

	IsolatedScope.prototype.init = function init() {
		var _this2 = this;

		if (typeof this.bind === "string") this.data = { bind: this.bind };
		else if (isArray(this.bind)) {
			this.data = {};
			this.bind.forEach(function(x, i) {
				_this2.data[String(i)] = { bind: x };
			});
		}
		_PureContainer.prototype.init.call(this);
	};

	IsolatedScope.prototype.explore = function explore(context, instance) {
		if (instance.shouldUpdate) {
			_PureContainer.prototype.explore.call(this, context, instance);
		}
	};

	return IsolatedScope;
})(PureContainer);

var DetachedScope = (function(_IsolatedScope) {
	inherits(DetachedScope, _IsolatedScope);

	function DetachedScope() {
		classCallCheck(this, DetachedScope);
		return possibleConstructorReturn(this, _IsolatedScope.apply(this, arguments));
	}

	DetachedScope.prototype.declareData = function declareData() {
		var _IsolatedScope$protot;

		return (_IsolatedScope$protot = _IsolatedScope.prototype.declareData).call.apply(
			_IsolatedScope$protot,
			[this].concat(Array.prototype.slice.call(arguments), [
				{
					exclusiveData: { structured: true }
				}
			])
		);
	};

	DetachedScope.prototype.init = function init() {
		var _this2 = this;

		if (typeof this.exclusive === "string") this.exclusiveData = { bind: this.exclusive };
		if (Array.isArray(this.exclusive)) {
			this.exclusiveData = {};
			this.exclusive.forEach(function(x, i) {
				_this2.exclusiveData[String(i)] = { bind: x };
			});
		}

		this.container = PureContainer.create({
			type: PureContainer,
			items: this.children || this.items
		});
		delete this.items;
		delete this.children;

		if (this.name)
			this.options = _extends({}, this.options, {
				name: this.name
			});

		_IsolatedScope.prototype.init.call(this);
	};

	DetachedScope.prototype.initInstance = function initInstance(context, instance) {
		instance.subStore = new ContainmentStore({
			store: instance.store,
			selector: getSelector(this.exclusiveData || this.data)
		});
	};

	DetachedScope.prototype.render = function render(context, instance, key) {
		return VDOM$1.createElement(Cx, {
			key: key,
			widget: this.container,
			store: instance.subStore,
			parentInstance: instance,
			subscribe: true,
			options: this.options
		});
	};

	return DetachedScope;
})(IsolatedScope);

var ContainmentStore = (function(_SubscribableView) {
	inherits(ContainmentStore, _SubscribableView);

	function ContainmentStore() {
		classCallCheck(this, ContainmentStore);
		return possibleConstructorReturn(this, _SubscribableView.apply(this, arguments));
	}

	ContainmentStore.prototype.getData = function getData() {
		return this.store.getData();
	};

	ContainmentStore.prototype.setItem = function setItem() {
		var _this4 = this;

		for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
			args[_key] = arguments[_key];
		}

		return this.wrapper(function() {
			var _store;

			(_store = _this4.store).setItem.apply(_store, args);
		});
	};

	ContainmentStore.prototype.deleteItem = function deleteItem() {
		var _this5 = this;

		for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
			args[_key2] = arguments[_key2];
		}

		return this.wrapper(function() {
			var _store2;

			(_store2 = _this5.store).deleteItem.apply(_store2, args);
		});
	};

	ContainmentStore.prototype.wrapper = function wrapper(callback) {
		if (this.store.silently(callback)) {
			var data = this.getData();
			var containedData = this.selector(data);
			if (containedData === this.cache.containedData) {
				this.store.notify();
			} else {
				this.cache.containedData = containedData;
				this.notify();
			}
			return true;
		}
		return false;
	};

	return ContainmentStore;
})(SubscribableView);

var flattenProps = function flattenProps(props) {
	return props && props.$props !== undefined
		? _extends({}, props.$props, { jsxAttributes: props.jsxAttributes, children: props.children })
		: props;
};

function createFunctionalComponent(factory) {
	return createComponentFactory(function() {
		var props = arguments.length <= 0 ? undefined : arguments[0];

		//test if the component is invoked through JSX
		if (props && isArray(props.jsxAttributes)) {
			var result = factory(flattenProps(props));
			var isArr = isArray(result);
			if (isArr && result.length < 2) {
				result = result[0];
				isArr = false;
			}
			var visible = props.visible,
				controller = props.controller,
				layout = props.layout,
				outerLayout = props.outerLayout;

			if (props["if"] !== undefined) visible = props["if"];

			if (result) {
				if (isArr) {
					if (isDefined(visible))
						result.forEach(function(r) {
							if (isDefined(r.visible))
								throw new Error(
									"Functional components with defined visible property should not set visibility on its children."
								);

							r.visible = visible;
						});

					if (controller || outerLayout || layout)
						throw new Error(
							"Functional components returning multiple elements cannot use controller, outerLayout and layout properties. Consider wrapping the content inside a PureContainer."
						);
				} else {
					if (isDefined(visible)) result.visible = visible;

					if (isDefined(controller)) result.controller = controller;

					if (isDefined(layout)) result.layout = layout;

					if (isDefined(outerLayout)) result.outerLayout = outerLayout;
				}
			}

			return result;
		}

		return factory.apply(undefined, arguments);
	});
}

var Selection = (function(_Component) {
	inherits(Selection, _Component);

	function Selection() {
		classCallCheck(this, Selection);
		return possibleConstructorReturn(this, _Component.apply(this, arguments));
	}

	Selection.prototype.isSelected = function isSelected(store, record, index) {
		return this.bind && store.get(this.bind) === record;
	};

	Selection.prototype.getIsSelectedDelegate = function getIsSelectedDelegate(store) {
		var _this2 = this;

		return function(record, index) {
			return _this2.isSelected(store, record, index);
		};
	};

	Selection.prototype.select = function select(store, record, index) {};

	Selection.prototype.declareData = function declareData() {
		var declaration = {
			$selection: { structured: true }
		};

		return Object.assign.apply(Object, [declaration].concat(Array.prototype.slice.call(arguments)));
	};

	Selection.prototype.configureWidget = function configureWidget(widget) {
		if (this.record || this.index) {
			widget.$selection = Object.assign(widget.$selection || {}, {
				record: this.record,
				index: this.index
			});
		}

		return this.declareData();
	};

	Selection.prototype.selectInstance = function selectInstance(instance) {
		var store = instance.store,
			data = instance.data;

		if (!data.$selection)
			throw new Error(
				"Selection model not properly configured. Using the selectInstance method without specified record and index bindings."
			);
		return this.select(store, data.$selection.record, data.$selection.index);
	};

	Selection.prototype.isInstanceSelected = function isInstanceSelected(instance) {
		var store = instance.store,
			data = instance.data;

		return data.$selection && this.isSelected(store, data.$selection.record, data.$selection.index);
	};

	return Selection;
})(Component);

Selection.prototype.toggle = false;

Selection.namespace = "ui.selection.";

var SimpleSelection = (function(_Selection) {
	inherits(SimpleSelection, _Selection);

	function SimpleSelection() {
		classCallCheck(this, SimpleSelection);
		return possibleConstructorReturn(this, _Selection.apply(this, arguments));
	}

	SimpleSelection.prototype.isSelected = function isSelected(store, record, index) {
		return this.getIsSelectedDelegate(store)(record, index);
	};

	SimpleSelection.prototype.getIsSelectedDelegate = function getIsSelectedDelegate(store) {
		var selection = this.bind && store.get(this.bind);
		return function(record, index) {
			return record === selection;
		};
	};

	SimpleSelection.prototype.select = function select(store, record, index) {
		if (this.bind) store.set(this.bind, record);
	};

	return SimpleSelection;
})(Selection);

var DummySelection = (function(_Selection2) {
	inherits(DummySelection, _Selection2);

	function DummySelection() {
		classCallCheck(this, DummySelection);
		return possibleConstructorReturn(this, _Selection2.apply(this, arguments));
	}

	DummySelection.prototype.isSelected = function isSelected(store, record, index) {
		return false;
	};

	DummySelection.prototype.select = function select() {
		//dummy
	};

	DummySelection.prototype.selectInstance = function selectInstance() {
		//dummy
	};

	return DummySelection;
})(Selection);

DummySelection.prototype.isDummy = true;

Selection.factory = function(name) {
	if ((typeof name === "undefined" ? "undefined" : _typeof(name)) == "object") return new SimpleSelection(name);

	return new DummySelection();
};

var PropertySelection = (function(_Selection) {
	inherits(PropertySelection, _Selection);

	function PropertySelection() {
		classCallCheck(this, PropertySelection);
		return possibleConstructorReturn(this, _Selection.apply(this, arguments));
	}

	PropertySelection.prototype.select = function select(store, record, index) {
		var _this2 = this;

		var _ref = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},
			toggle = _ref.toggle;

		if (this.toggle) toggle = true;

		if (this.records && this.records.bind) {
			var array = store.get(this.records.bind);
			var rec = array[index];
			if (rec !== record) throw new Error("Stale data.");

			var value = rec[this.selectedField];
			var newValue = toggle ? !value : true;

			var newArray = [].concat(array);

			var dirty = false;

			if (newValue && !toggle)
				newArray.forEach(function(r, i) {
					if (r != record && r[_this2.selectedField]) {
						var nr = Object.assign({}, r);
						nr[_this2.selectedField] = false;
						newArray[i] = nr;
						dirty = true;
					}
				});

			if (value == newValue && !dirty) return;

			var newRec = Object.assign({}, rec);
			newRec[this.selectedField] = newValue;
			newArray[index] = newRec;
			store.set(this.records.bind, newArray);
		}
	};

	PropertySelection.prototype.isSelected = function isSelected(store, record, index) {
		return record && record[this.selectedField];
	};

	return PropertySelection;
})(Selection);

PropertySelection.prototype.selectedField = "selected";
PropertySelection.prototype.multiple = false;

Selection.alias("property", PropertySelection);

var KeySelection = (function(_Selection) {
	inherits(KeySelection, _Selection);

	function KeySelection() {
		classCallCheck(this, KeySelection);
		return possibleConstructorReturn(this, _Selection.apply(this, arguments));
	}

	KeySelection.prototype.init = function init() {
		_Selection.prototype.init.call(this);

		if (this.bind && !this.selection)
			this.selection = {
				bind: this.bind
			};

		if (!this.selection) this.selection = {};

		if (isArray(this.keyFields)) this.keyField = false;

		this.initialized = true;
	};

	KeySelection.prototype.getKey = function getKey(record) {
		if (this.key != null) return this.key;

		if (!record) return null;

		if (this.keyField) return record[this.keyField];

		var key = {};
		this.keyFields.forEach(function(k) {
			key[k] = record[k];
		});
		return key;
	};

	KeySelection.prototype.areKeysEqual = function areKeysEqual(key1, key2) {
		if (this.keyField) return key1 === key2 && key1 != null;

		if (!key1 || !key2) return false;

		return !this.keyFields.some(function(k) {
			return key1[k] !== key2[k];
		});
	};

	KeySelection.prototype.declareData = function declareData() {
		var _Selection$prototype$;

		return (_Selection$prototype$ = _Selection.prototype.declareData).call.apply(
			_Selection$prototype$,
			[
				this,
				{
					$selection: { structured: true }
				}
			].concat(Array.prototype.slice.call(arguments))
		);
	};

	KeySelection.prototype.configureWidget = function configureWidget(widget) {
		if (!this.initialized) this.init();

		widget.$selection = Object.assign(widget.$selection || {}, {
			keys: this.selection
		});

		return _Selection.prototype.configureWidget.call(this, widget);
	};

	KeySelection.prototype.select = function select(store, record, index) {
		var _this2 = this;

		var _ref = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},
			toggle = _ref.toggle;

		if (!this.selection.bind) return false;

		if (this.toggle) toggle = true;

		var key = this.getKey(record);
		var selection = store.get(this.selection.bind);
		if (!this.multiple) {
			if (!toggle) store.set(this.selection.bind, key);
			else if (this.areKeysEqual(selection, key)) store.delete(this.selection.bind);
		} else {
			if (this.storage == "array") {
				var exists =
					isArray(selection) &&
					selection.some(function(x) {
						return _this2.areKeysEqual(x, key);
					});
				if (!toggle) store.set(this.selection.bind, [key]);
				else if (!exists) store.set(this.selection.bind, [].concat(selection || [], [key]));
				else
					store.set(
						this.selection.bind,
						selection.filter(function(x) {
							return !_this2.areKeysEqual(x, key);
						})
					);
			} else if (this.storage == "hash") {
				var newSelection = Object.assign({}, selection);
				newSelection[key] = true;
				store.set(this.selection.bind, newSelection);
			}
		}
	};

	KeySelection.prototype.getIsSelectedDelegate = function getIsSelectedDelegate(store) {
		var _this3 = this;

		if (!this.selection.bind)
			return function() {
				return false;
			};

		var selection = store.get(this.selection.bind);

		if (this.multiple) {
			if (this.storage == "array") {
				selection = selection || [];
				return function(record, index) {
					return selection.some(function(k) {
						return _this3.areKeysEqual(_this3.getKey(record), k);
					});
				};
			} else {
				selection = selection || {};
				return function(record, index) {
					return selection[_this3.getKey(record)];
				};
			}
		} else
			return function(record, index) {
				return _this3.areKeysEqual(selection, _this3.getKey(record));
			};
	};

	KeySelection.prototype.isSelected = function isSelected(store, record, index) {
		return this.getIsSelectedDelegate(store)(record, index);
	};

	return KeySelection;
})(Selection);

KeySelection.prototype.multiple = false;
KeySelection.prototype.keyField = "id";
KeySelection.prototype.storage = "array";

Selection.alias("key", KeySelection);

var FirstVisibleChildLayout = (function(_Layout) {
	inherits(FirstVisibleChildLayout, _Layout);

	function FirstVisibleChildLayout() {
		classCallCheck(this, FirstVisibleChildLayout);
		return possibleConstructorReturn(this, _Layout.apply(this, arguments));
	}

	FirstVisibleChildLayout.prototype.checkVisible = function checkVisible(instance) {
		var _this2 = this;

		if (!instance.visible) return false;

		if (instance.widget.layout && instance.widget.layout.useParentLayout)
			return (
				isArray(instance.children) &&
				instance.children.some(function(c) {
					return _this2.checkVisible(c);
				})
			);

		return true;
	};

	FirstVisibleChildLayout.prototype.explore = function explore(context, instance, items) {
		instance.children = [];
		for (var i = 0; i < items.length; i++) {
			var x = instance.getChild(context, items[i]);
			if (!x.scheduleExploreIfVisible(context)) continue;

			var old = instance.cached.children;
			instance.children = old && old[0] === x ? old : [x];
			break;
		}
		if (instance.cache("children", instance.children)) instance.markShouldUpdate(context);
	};

	return FirstVisibleChildLayout;
})(Layout);

Layout.alias("firstvisiblechild", FirstVisibleChildLayout);

var UseParentLayout = (function(_Layout) {
	inherits(UseParentLayout, _Layout);

	function UseParentLayout() {
		classCallCheck(this, UseParentLayout);
		return possibleConstructorReturn(this, _Layout.apply(this, arguments));
	}

	UseParentLayout.prototype.render = function render(context, instance, keyPrefix) {
		var result = [];
		instance.children.forEach(function(c) {
			var r = c.render(context);
			if (c.widget.layout && c.widget.layout.useParentLayout && isArray(r.content)) {
				r.content.forEach(function(r) {
					result.push(r);
				});
			} else result.push(r);
		});
		return result;
	};

	return UseParentLayout;
})(Layout);

UseParentLayout.prototype.useParentLayout = true;

Layout.alias("parent", UseParentLayout);

function validContent(r) {
	var content = [];
	for (var key in r) {
		if (key != "label") contentAppend(content, r[key]);
	}
	return content;
}

var LabelsLeftLayout = (function(_Layout) {
	inherits(LabelsLeftLayout, _Layout);

	function LabelsLeftLayout() {
		classCallCheck(this, LabelsLeftLayout);
		return possibleConstructorReturn(this, _Layout.apply(this, arguments));
	}

	LabelsLeftLayout.prototype.render = function render(context, instance, keyPrefix) {
		var result = [];
		var children = instance.children;
		var CSS = this.CSS,
			baseClass = this.baseClass;

		children.forEach(function(c, i) {
			var r = c.vdom; //render(context);
			if (r) {
				if (c.widget.layout && c.widget.layout.useParentLayout && isArray(r.content)) {
					r.content.forEach(function(r, j) {
						result.push(
							VDOM$1.createElement(
								"tr",
								{ key: i + "-" + j },
								VDOM$1.createElement("td", { className: CSS.element(baseClass, "label") }, getContent(r.label)),
								VDOM$1.createElement("td", { className: CSS.element(baseClass, "field") }, validContent(r))
							)
						);
					});
				} else {
					result.push(
						VDOM$1.createElement(
							"tr",
							{ key: i },
							VDOM$1.createElement("td", { className: CSS.element(baseClass, "label") }, getContent(r.label)),
							VDOM$1.createElement("td", { className: CSS.element(baseClass, "field") }, validContent(r))
						)
					);
				}
			}
		});
		return VDOM$1.createElement(
			"table",
			{ key: keyPrefix, className: CSS.block(baseClass, this.mod) },
			VDOM$1.createElement("tbody", null, result)
		);
	};

	return LabelsLeftLayout;
})(Layout);

LabelsLeftLayout.prototype.baseClass = "labelsleftlayout";

Layout.alias("labels-left", LabelsLeftLayout);

function validContent$1(r) {
	var content = [];
	for (var key in r) {
		if (key != "label") contentAppend(content, r[key]);
	}
	return content;
}

var LabelsTopLayout = (function(_Layout) {
	inherits(LabelsTopLayout, _Layout);

	function LabelsTopLayout() {
		classCallCheck(this, LabelsTopLayout);
		return possibleConstructorReturn(this, _Layout.apply(this, arguments));
	}

	LabelsTopLayout.prototype.render = function render(context, instance, keyPrefix) {
		var children = instance.children;
		var CSS = this.CSS,
			baseClass = this.baseClass;

		var content = void 0;

		if (this.vertical) {
			var rows = [];

			children.forEach(function(c, i) {
				var r = c.vdom; //render(context);
				if (c.widget.layout && c.widget.layout.useParentLayout && isArray(r.content)) {
					r.content.forEach(function(r, j) {
						rows.push(
							VDOM$1.createElement(
								"tr",
								{ key: i + "-" + j + "-label" },
								VDOM$1.createElement("td", { className: CSS.element(baseClass, "label") }, getContent(r.label))
							)
						);
						rows.push(
							VDOM$1.createElement(
								"tr",
								{ key: i + "-" + j + "-field" },
								VDOM$1.createElement("td", { className: CSS.element(baseClass, "field") }, validContent$1(r))
							)
						);
					});
				} else {
					rows.push(
						VDOM$1.createElement(
							"tr",
							{ key: i + "-label" },
							VDOM$1.createElement("td", { className: CSS.element(baseClass, "label") }, getContent(r.label))
						)
					);
					rows.push(
						VDOM$1.createElement(
							"tr",
							{ key: i + "-field" },
							VDOM$1.createElement("td", { className: CSS.element(baseClass, "field") }, validContent$1(r))
						)
					);
				}
			});

			content = VDOM$1.createElement("tbody", null, rows);
		} else {
			var labels = [];
			var inputs = [];
			children.forEach(function(c, i) {
				var r = c.render(context);
				if (c.widget.layout && c.widget.layout.useParentLayout && isArray(r.content)) {
					r.content.forEach(function(r, j) {
						labels.push(
							VDOM$1.createElement(
								"td",
								{
									key: i + "-" + j,
									className: CSS.element(baseClass, "label")
								},
								getContent(r.label)
							)
						);
						inputs.push(
							VDOM$1.createElement(
								"td",
								{ key: i + "-" + j, className: CSS.element(baseClass, "field") },
								validContent$1(r)
							)
						);
					});
				} else {
					labels.push(
						VDOM$1.createElement("td", { key: i, className: CSS.element(baseClass, "label") }, getContent(r.label))
					);
					inputs.push(
						VDOM$1.createElement("td", { key: i, className: CSS.element(baseClass, "field") }, validContent$1(r))
					);
				}
			});

			content = VDOM$1.createElement(
				"tbody",
				null,
				VDOM$1.createElement("tr", null, labels),
				VDOM$1.createElement("tr", null, inputs)
			);
		}
		return VDOM$1.createElement("table", { key: keyPrefix, className: CSS.block(baseClass, this.mod) }, content);
	};

	return LabelsTopLayout;
})(Layout);

LabelsTopLayout.prototype.baseClass = "labelstoplayout";
LabelsTopLayout.prototype.vertical = false;

Layout.alias("labels-top", LabelsTopLayout);

var Content = (function(_PureContainer) {
	inherits(Content, _PureContainer);

	function Content() {
		classCallCheck(this, Content);
		return possibleConstructorReturn(this, _PureContainer.apply(this, arguments));
	}

	Content.prototype.init = function init() {
		_PureContainer.prototype.init.call(this);
		this.putInto = this.name;
	};

	return Content;
})(PureContainer);

Content.prototype.name = "body";
Content.prototype.isContent = true;

Widget.alias("content", Content);

var ContentPlaceholder = (function(_PureContainer) {
	inherits(ContentPlaceholder, _PureContainer);

	function ContentPlaceholder() {
		classCallCheck(this, ContentPlaceholder);
		return possibleConstructorReturn(this, _PureContainer.apply(this, arguments));
	}

	ContentPlaceholder.prototype.declareData = function declareData() {
		var _PureContainer$protot;

		(_PureContainer$protot = _PureContainer.prototype.declareData).call.apply(
			_PureContainer$protot,
			[this].concat(Array.prototype.slice.call(arguments), [
				{
					name: undefined
				}
			])
		);
	};

	ContentPlaceholder.prototype.explore = function explore(context, instance) {
		var _this2 = this;

		instance.content = null;
		var data = instance.data;

		var content = context.content && context.content[data.name];
		if (content && !this.scoped) this.setContent(context, instance, content);
		else
			context.pushNamedValue("contentPlaceholder", data.name, function(content) {
				_this2.setContent(context, instance, content);
			});

		if (this.scoped)
			instance.unregisterContentPlaceholder = function() {
				context.popNamedValue("contentPlaceholder", data.name);
			};

		_PureContainer.prototype.explore.call(this, context, instance);
	};

	ContentPlaceholder.prototype.prepare = function prepare(context, instance) {
		if (instance.content && instance.content.shouldUpdate) instance.markShouldUpdate(context);
	};

	ContentPlaceholder.prototype.setContent = function setContent(context, instance, content) {
		instance.content = content;
		content.contentPlaceholder = instance;

		if (instance.cache("content", content) || content.shouldUpdate) instance.markShouldUpdate(context);
	};

	ContentPlaceholder.prototype.render = function render(context, instance, key) {
		var content = instance.content;

		if (content) return content.contentVDOM;

		return _PureContainer.prototype.render.call(this, context, instance, key);
	};

	return ContentPlaceholder;
})(PureContainer);

ContentPlaceholder.prototype.name = "body";
ContentPlaceholder.prototype.scoped = false;

Widget.alias("content-placeholder", ContentPlaceholder);

function startAppLoop(parentDOMElement, storeOrInstance, widget) {
	var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

	if (!parentDOMElement || parentDOMElement.nodeType !== 1)
		throw new Error("First argument to startAppLoop should be a valid DOM element.");

	widget = Widget.create(widget);

	var store = void 0,
		instance = void 0,
		parentInstance = void 0;

	if (!storeOrInstance) storeOrInstance = new Store();

	if (storeOrInstance.notify) store = storeOrInstance;
	else if (storeOrInstance.getChild) {
		if (storeOrInstance.widget === widget) instance = storeOrInstance;
		else parentInstance = storeOrInstance;
	} else throw new Error("Second argument to startAppLoop should be either of type Store or Instance");

	var root = VDOM$1.createElement(Cx, {
		store: store,
		widget: widget,
		instance: instance,
		parentInstance: parentInstance,
		options: options,
		subscribe: true
	});

	VDOM$1.DOM.render(root, parentDOMElement);
	var stopped = false;

	return function() {
		if (stopped) return;

		stopped = true;

		if (!options.destroyDelay) destroy(parentDOMElement, options);
		else {
			setTimeout(function() {
				destroy(parentDOMElement, options);
			}, options.destroyDelay);
		}
	};
}

function destroy(parentDOMElement, options) {
	VDOM$1.DOM.unmountComponentAtNode(parentDOMElement);
	if (options.removeParentDOMElement && parentDOMElement.parentNode)
		parentDOMElement.parentNode.removeChild(parentDOMElement);
}

var Url = (function() {
	function Url() {
		classCallCheck(this, Url);
	}

	Url.resolve = function resolve(path) {
		return path.replace("~/", this.base);
	};

	Url.absolute = function absolute(path) {
		return path.replace("~/", this.absoluteBase);
	};

	Url.unresolve = function unresolve(path) {
		if (path.indexOf("~/") == 0) return path;

		var absBase = this.absoluteBase || "";

		if (path.indexOf(absBase) == 0) return "~/" + path.substring(absBase.length);

		return "~/" + path.substring(this.base.length);
	};

	Url.getAbsoluteBase = function getAbsoluteBase() {
		return this.absoluteBase;
	};

	Url.isLocal = function isLocal(url) {
		var absBase = this.getAbsoluteBase();
		return url.indexOf("~/") == 0 || url.indexOf(absBase) == 0 || url.indexOf(this.base) == 0;
	};

	Url.setBase = function setBase(base) {
		if (!base || base[base.length - 1] != "/") base += "/";
		this.base = base;
		if (typeof window != "undefined")
			this.absoluteBase = window.location.protocol + "//" + window.location.host + this.base;
	};

	Url.getOrigin = function getOrigin() {
		if (typeof window == "undefined") return "";
		return (
			window.location.protocol +
			"//" +
			window.location.hostname +
			(window.location.port ? ":" + window.location.port : "")
		);
	};

	Url.getBaseFromScriptSrc = function getBaseFromScriptSrc(src, scriptPath) {
		if (!(scriptPath instanceof RegExp)) scriptPath = getBasePathRegex(scriptPath);

		var index = src.search(scriptPath);
		if (index == -1) return false;

		var origin = this.getOrigin();
		return src.substring(src.indexOf(origin) == 0 ? origin.length : 0, index);
	};

	Url.setBaseFromScript = function setBaseFromScript(scriptPath) {
		var scripts = document.getElementsByTagName("script"),
			base;

		if (!(scriptPath instanceof RegExp)) scriptPath = getBasePathRegex(scriptPath);

		for (var i = 0; i < scripts.length; i++) {
			base = this.getBaseFromScriptSrc(scripts[i].src, scriptPath);
			if (base) {
				this.setBase(base);
				return;
			}
		}

		throw new Error("Could not resolve url base from script matching '" + scriptPath + "'.");
	};

	return Url;
})();

Url.setBase("/");

function getBasePathRegex(str) {
	var regex = "";
	var start = 0;
	if (str.indexOf("~/") == 0) start = 2;

	for (var i = start; i < str.length; i++) {
		switch (str[i]) {
			case ".":
				regex += "\\.";
				break;

			case "*":
				regex += ".*";
				break;

			default:
				regex += str[i];
		}
	}
	return new RegExp(regex + "(\\?.*)?$", "i");
}

var last = 0;
var next = 1;
var transitions = {};
var subscribers$2 = null;
var reload = false;

var History = (function() {
	function History() {
		classCallCheck(this, History);
	}

	History.connect = function connect(store, bind) {
		var _this = this;

		this.store = store;
		this.bind = bind;
		this.updateStore();
		window.onpopstate = function() {
			_this.updateStore();
		};
	};

	History.pushState = function pushState(state, title, url) {
		return this.navigate(state, title, url);
	};

	History.replaceState = function replaceState(state, title, url) {
		return this.navigate(state, title, url, true);
	};

	History.reloadOnNextChange = function reloadOnNextChange() {
		reload = true;
	};

	History.navigate = function navigate(state, title, url) {
		var _this2 = this;

		var replace = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

		url = Url.resolve(url);

		if (!window.history.pushState || reload) {
			window.location[replace ? "replace" : "assign"](url);
			return true;
		}

		var transition = void 0,
			changed = false;
		batchUpdatesAndNotify(
			function() {
				changed = _this2.updateStore(url);
				if (changed)
					transitions[++last] = transition = {
						url: url,
						state: state,
						title: title,
						replace: replace
					};
			},
			function() {
				if (transition) transition.completed = true;

				//update history once the page is rendered and the title is set
				while (transitions[next] && transitions[next].completed) {
					var tr = transitions[next];
					delete transitions[next];
					next++;
					var op = tr.replace ? "replaceState" : "pushState";
					window.history[op](tr.state, tr.title, tr.url);
					if (subscribers$2) subscribers$2.notify(tr.url, op);
				}
			}
		);

		return changed;
	};

	History.updateStore = function updateStore(href) {
		var url = Url.unresolve(href || document.location.href);
		var hashIndex = url.indexOf("#");
		if (hashIndex !== -1) url = url.substring(0, hashIndex);
		return this.store.set(this.bind, url);
	};

	History.subscribe = function subscribe(callback) {
		if (!subscribers$2) subscribers$2 = new SubscriberList();
		return subscribers$2.subscribe(callback);
	};

	return History;
})();

var GroupAdapter = (function(_ArrayAdapter) {
	inherits(GroupAdapter, _ArrayAdapter);

	function GroupAdapter() {
		classCallCheck(this, GroupAdapter);
		return possibleConstructorReturn(this, _ArrayAdapter.apply(this, arguments));
	}

	GroupAdapter.prototype.init = function init() {
		_ArrayAdapter.prototype.init.call(this);

		if (this.groupings) this.groupBy(this.groupings);
	};

	GroupAdapter.prototype.getRecords = function getRecords(context, instance, records, parentStore) {
		var result = _ArrayAdapter.prototype.getRecords.call(this, context, instance, records, parentStore);

		if (this.groupings) {
			var groupedResults = [];
			this.processLevel([], result, groupedResults, parentStore);
			result = groupedResults;
		}

		return result;
	};

	GroupAdapter.prototype.processLevel = function processLevel(keys, records, result, parentStore) {
		var _this2 = this;

		var level = keys.length;
		var inverseLevel = this.groupings.length - level;

		if (inverseLevel == 0) {
			for (var i = 0; i < records.length; i++) {
				records[i].store.setStore(parentStore);
				result.push(records[i]);
			}
			return;
		}

		var grouping = this.groupings[level];
		var grouper = grouping.grouper;

		grouper.reset();
		grouper.processAll(records);
		var results = grouper.getResults();

		results.forEach(function(gr) {
			var _data;

			keys.push(gr.key);

			var $group = _extends({}, gr.key, gr.aggregates, { $name: gr.name, $level: inverseLevel });
			var groupStore = new ReadOnlyDataView({
				store: parentStore,
				data: ((_data = {}), (_data[_this2.groupName] = $group), _data),
				immutable: _this2.immutable
			});

			var group = {
				key: keys
					.map(function(key) {
						return Object.keys(key)
							.map(function(k) {
								return key[k];
							})
							.join(":");
					})
					.join("|"),
				data: gr.records[0],
				group: $group,
				grouping: grouping,
				store: groupStore,
				level: inverseLevel
			};

			if (grouping.includeHeader !== false)
				result.push(
					_extends({}, group, {
						type: "group-header",
						key: "header:" + group.key
					})
				);

			_this2.processLevel(keys, gr.records, result, groupStore);

			if (grouping.includeFooter !== false)
				result.push(
					_extends({}, group, {
						type: "group-footer",
						key: "footer:" + group.key
					})
				);

			keys.pop();
		});
	};

	GroupAdapter.prototype.groupBy = function groupBy(groupings) {
		var _this3 = this;

		if (!groupings) this.groupings = null;
		else if (isArray(groupings)) {
			this.groupings = groupings;
			this.groupings.forEach(function(g) {
				var key = {};
				for (var name in g.key) {
					if (!g.key[name] || !isDefined(g.key[name].direction) || !isDefined(g.key[name].value))
						g.key[name] = { value: g.key[name], direction: "ASC" };
					key[name] = g.key[name].value;
				}
				g.grouper = new Grouper(
					key,
					_extends({}, _this3.aggregates, g.aggregates),
					function(r) {
						return r.store.getData();
					},
					g.text
				);
			});
		} else throw new Error("Invalid grouping provided.");
		this.updateSorter();
	};

	GroupAdapter.prototype.updateSorter = function updateSorter() {
		var sorters = [];
		if (this.groupings)
			this.groupings.forEach(function(g) {
				for (var k in g.key) {
					sorters.push({ value: g.key[k].value, direction: g.key[k].direction });
				}
			});
		if (this.sorters) sorters.push.apply(sorters, this.sorters);
		this.buildSorter(sorters);
	};

	GroupAdapter.prototype.sort = function sort(sorters) {
		this.sorters = sorters;
		this.updateSorter();
	};

	return GroupAdapter;
})(ArrayAdapter);

GroupAdapter.prototype.groupName = "$group";

var TreeAdapter = (function(_ArrayAdapter) {
	inherits(TreeAdapter, _ArrayAdapter);

	function TreeAdapter() {
		classCallCheck(this, TreeAdapter);
		return possibleConstructorReturn(this, _ArrayAdapter.apply(this, arguments));
	}

	TreeAdapter.prototype.mapRecords = function mapRecords(context, instance, data, parentStore, recordsBinding) {
		var nodes = _ArrayAdapter.prototype.mapRecords.call(this, context, instance, data, parentStore, recordsBinding);
		var result = [];
		this.processList(context, instance, 0, "", nodes, result);
		return result;
	};

	TreeAdapter.prototype.processList = function processList(context, instance, level, parentKey, nodes, result) {
		var _this2 = this;

		var nonLeafs = [],
			leafs = [];
		nodes.forEach(function(record) {
			record.key = parentKey + record.key;
			_this2.processNode(context, instance, level, record.data.$leaf ? leafs : nonLeafs, record);
		});
		result.push.apply(result, nonLeafs.concat(leafs));
	};

	TreeAdapter.prototype.processNode = function processNode(context, instance, level, result, record) {
		var _this3 = this;

		result.push(record);
		var data = record.data,
			store = record.store;

		data.$level = level;
		if (!data[this.leafField]) {
			if (data[this.expandedField]) {
				if (data[this.childrenField]) {
					var childNodes = _ArrayAdapter.prototype.mapRecords.call(
						this,
						context,
						instance,
						data[this.childrenField],
						store,
						Binding.get(this.recordName + "." + this.childrenField)
					);
					this.processList(context, instance, level + 1, record.key + ":", childNodes, result);
				} else if (!data[this.loadedField]) {
					if (this.load) {
						store.set(this.recordName + "." + this.loadedField, true);
						var response = this.load(context, instance, data);
						Promise.resolve(response)
							.then(function(children) {
								store.set(_this3.recordName + "." + _this3.childrenField, children);
								store.set(_this3.recordName + "." + _this3.loadedField, true);
								store.set(_this3.recordName + "." + _this3.loadingField, false);
							})
							.catch(function(response) {
								if (_this3.onLoadError) _this3.onLoadError(response);
							});
					}
				}
			} else data[this.expandedField] = false;
		}
	};

	return TreeAdapter;
})(ArrayAdapter);

TreeAdapter.prototype.childrenField = "$children";
TreeAdapter.prototype.expandedField = "$expanded";
TreeAdapter.prototype.leafField = "$leaf";
TreeAdapter.prototype.loadingField = "$loading";
TreeAdapter.prototype.loadedField = "$loaded";

function bind(path, defaultValue) {
	return {
		bind: path,
		defaultValue: defaultValue
	};
}

function tpl(text) {
	return {
		tpl: text
	};
}

function expr(text) {
	return {
		expr: text
	};
}

//re-export computable here

export {
	Component,
	createComponentFactory,
	isComponentFactory,
	Controller,
	VDOM$1 as VDOM,
	Widget,
	contentAppend,
	getContentArray,
	getContent,
	Container,
	PureContainer,
	Repeater,
	Rescope,
	StaticText,
	Text,
	CSS,
	CSSHelper,
	FocusManager,
	oneFocusOut,
	offFocusOut,
	preventFocus,
	preventFocusOnTouch,
	ResizeManager,
	ZIndexManager,
	Format$1 as Format,
	enableCultureSensitiveFormatting,
	Culture,
	Localization,
	Cx,
	Instance,
	InstanceCache,
	RenderingContext,
	ContentResolver,
	batchUpdates,
	isBatchingUpdates,
	notifyBatchedUpdateStarting,
	notifyBatchedUpdateCompleted,
	batchUpdatesAndNotify,
	IsolatedScope,
	DetachedScope,
	createFunctionalComponent,
	flattenProps,
	Selection,
	PropertySelection,
	KeySelection,
	Layout,
	FirstVisibleChildLayout,
	UseParentLayout,
	LabelsLeftLayout,
	LabelsTopLayout,
	Content,
	ContentPlaceholder,
	exploreChildren,
	startAppLoop,
	History,
	Url,
	DataAdapter,
	ArrayAdapter,
	GroupAdapter,
	TreeAdapter,
	bind,
	tpl,
	expr
};
export { computable } from "./data";
